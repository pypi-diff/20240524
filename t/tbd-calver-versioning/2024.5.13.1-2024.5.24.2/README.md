# Comparing `tmp/tbd_calver_versioning-2024.5.13.1-py3-none-any.whl.zip` & `tmp/tbd_calver_versioning-2024.5.24.2-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,18 +1,18 @@
-Zip file size: 16459 bytes, number of entries: 16
--rw-rw-rw-  2.0 fat     5765 b- defN 24-May-13 20:02 tbd_calver_versioning.py
--rw-rw-rw-  2.0 fat      298 b- defN 23-Aug-21 16:26 tbd_calver_versioning-2024.5.13.1.data/data/bin/README.md
--rw-rw-rw-  2.0 fat     6364 b- defN 24-May-13 20:02 tbd_calver_versioning-2024.5.13.1.data/data/bin/determine_tbd_calver_version_number.sh
--rw-rw-rw-  2.0 fat      496 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/bin/tag_repo_with_version_number.sh
--rw-rw-rw-  2.0 fat      336 b- defN 23-Aug-21 16:26 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/README.md
--rw-rw-rw-  2.0 fat     1455 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/checkout_git_repo_properly.sh
--rw-rw-rw-  2.0 fat     1829 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/configure_credential_helper.sh
--rw-rw-rw-  2.0 fat     1169 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_commit_where_branch_created.sh
--rw-rw-rw-  2.0 fat     3397 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh
--rw-rw-rw-  2.0 fat      533 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_commit_is_merge_commit.sh
--rw-rw-rw-  2.0 fat     1417 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_on_branch.sh
--rw-rw-rw-  2.0 fat      595 b- defN 24-Jan-17 21:50 tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_since_commit.sh
--rw-rw-rw-  2.0 fat     5593 b- defN 24-May-13 20:16 tbd_calver_versioning-2024.5.13.1.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-May-13 20:16 tbd_calver_versioning-2024.5.13.1.dist-info/WHEEL
--rw-rw-rw-  2.0 fat       22 b- defN 24-May-13 20:16 tbd_calver_versioning-2024.5.13.1.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2036 b- defN 24-May-13 20:16 tbd_calver_versioning-2024.5.13.1.dist-info/RECORD
-16 files, 31397 bytes uncompressed, 12847 bytes compressed:  59.1%
+Zip file size: 16348 bytes, number of entries: 16
+-rw-r--r--  2.0 unx     5635 b- defN 24-May-23 18:53 tbd_calver_versioning.py
+-rw-r--r--  2.0 unx      292 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/bin/README.md
+-rwxr-xr-x  2.0 unx     6218 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/bin/determine_tbd_calver_version_number.sh
+-rwxr-xr-x  2.0 unx      469 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/bin/tag_repo_with_version_number.sh
+-rw-r--r--  2.0 unx      326 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/README.md
+-rwxr-xr-x  2.0 unx     1404 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/checkout_git_repo_properly.sh
+-rwxr-xr-x  2.0 unx     1773 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/configure_credential_helper.sh
+-rwxr-xr-x  2.0 unx     1134 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_commit_where_branch_created.sh
+-rwxr-xr-x  2.0 unx     3297 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh
+-rwxr-xr-x  2.0 unx      511 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_commit_is_merge_commit.sh
+-rwxr-xr-x  2.0 unx     1379 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_on_branch.sh
+-rwxr-xr-x  2.0 unx      576 b- defN 24-May-23 18:53 tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_since_commit.sh
+-rw-r--r--  2.0 unx     5498 b- defN 24-May-24 16:59 tbd_calver_versioning-2024.5.24.2.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-24 16:59 tbd_calver_versioning-2024.5.24.2.dist-info/WHEEL
+-rw-r--r--  2.0 unx       22 b- defN 24-May-24 16:59 tbd_calver_versioning-2024.5.24.2.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     2036 b- defN 24-May-24 16:59 tbd_calver_versioning-2024.5.24.2.dist-info/RECORD
+16 files, 30662 bytes uncompressed, 12736 bytes compressed:  58.5%
```

## zipnote {}

```diff
@@ -1,49 +1,49 @@
 Filename: tbd_calver_versioning.py
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/bin/README.md
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/bin/README.md
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/bin/determine_tbd_calver_version_number.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/bin/determine_tbd_calver_version_number.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/bin/tag_repo_with_version_number.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/bin/tag_repo_with_version_number.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/README.md
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/README.md
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/checkout_git_repo_properly.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/checkout_git_repo_properly.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/configure_credential_helper.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/configure_credential_helper.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_commit_where_branch_created.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_commit_where_branch_created.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_commit_is_merge_commit.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_commit_is_merge_commit.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_on_branch.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_on_branch.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_since_commit.sh
+Filename: tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_since_commit.sh
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.dist-info/METADATA
+Filename: tbd_calver_versioning-2024.5.24.2.dist-info/METADATA
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.dist-info/WHEEL
+Filename: tbd_calver_versioning-2024.5.24.2.dist-info/WHEEL
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.dist-info/top_level.txt
+Filename: tbd_calver_versioning-2024.5.24.2.dist-info/top_level.txt
 Comment: 
 
-Filename: tbd_calver_versioning-2024.5.13.1.dist-info/RECORD
+Filename: tbd_calver_versioning-2024.5.24.2.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tbd_calver_versioning.py

 * *Ordering differences only*

```diff
@@ -1,131 +1,131 @@
-from ShellUtilities import Shell
-import os
-import logging
-from pathlib import Path
-import sys
-import platform
-
-# This contains python functions which invokes the bash script to determine the version number.
-
-def determine_version_number(repo_path=None, adjust_for_pep_440=True, adjust_for_pypi=False):
-    
-    # Determine if we are using conda
-    try:
-        if os.environ["CONDA_DEFAULT_ENV"]:
-            logging.info("Detected that a conda environment is being used.")
-            using_conda = True
-            conda_env_name = os.environ["CONDA_DEFAULT_ENV"]
-            conda_env_path = os.environ["CONDA_PREFIX"]
-    except:
-        using_conda = False
-    
-    script_name = "determine_tbd_calver_version_number.sh"
-    script_installed = False
-    
-    # Determine the platform
-    if platform.system() == "Linux" and not using_conda:
-        # Check the environment variable named PATH to see if the script was installed
-        logging.debug("Searching PATH for installed bash script.")
-        logging.debug(os.linesep + os.environ["PATH"])
-        script_installed = False
-        for path in os.environ["PATH"].split(":"):
-            script_path = os.path.join(path, script_name)
-            if os.path.exists(script_path):
-                script_installed = True
-                logging.debug(f"Found script at '{script_path}'")
-                break
-        logging.warn("Script not found in environment PATH.")       
-    elif platform.system() == "Windows" and not using_conda:
-        # On windows, the user is expected to use a bash-like environment
-        logging.warn("Script not found in windows environment.")
-        pass
-    elif using_conda:
-        script_path = os.path.join(conda_env_path, "bin", script_name)
-        logging.debug(f"Checking conda environment for: {script_path}")
-        if os.path.exists(script_path):
-            script_installed = True
-            logging.debug(f"Found script at '{script_path}'")
-        else:
-            logging.warn("Script not found in conda environment.")
- 
-    # If the script is not installed into the PATH, assume we are running from inside the git repo
-    # Check if the script can be found locally
-    if not script_installed:
-        logging.warn("Assuming script is being run from the local git repo instead.")  
-        current_dir = os.path.dirname(os.path.abspath(__file__))
-        if not repo_path:
-            repo_path = os.getcwd()
-        logging.debug(f"Repo path set to: {repo_path}")
-        src_root_dir = os.path.dirname(current_dir)
-        bash_dir = os.path.join(src_root_dir, "bash", "bin")
-        script_path = os.path.join(bash_dir, script_name)
-        if os.path.exists(script_path):
-            script_installed = True
-            logging.debug(f"Found script at '{script_path}'")
-
-    if not script_installed:
-        raise Exception("Unable to determine location of determine_tbd_calver_version_number.sh.")
-    
-    # Now that we know where the script is, we can run it
-    # Before we can run it however, we need to identify the bash interpreter we will use
-    interpreter = ""
-    try:
-        Shell.execute_shell_command(f"bash --version", cwd=repo_path).Stdout
-        interpreter = "bash"
-    except:
-        pass
-    if not interpreter:
-        logging.warning("The bash executable was not found or not configured properly. Checking for sh executable.")
-        try:
-            Shell.execute_shell_command(f"sh --version", cwd=repo_path).Stdout
-            interpreter = "sh"
-        except:
-            pass
-    if not interpreter:
-        logging.fatal("Unable to find a working bash interpreter")
-    
-    version_number = Shell.execute_shell_command(f"{interpreter} {script_path}", cwd=repo_path).Stdout
-    
-    if not adjust_for_pep_440 and not adjust_for_pypi:
-        return version_number
-    
-    # With PEP 440 version specifier is `<public identifier>[+<local label>]`
-    # This means we need to adjust our version number to use a + rather than a .
-    # for the fourth element in the version number
-    #
-        
-    parts = version_number.split(".")
-    year = parts[0]
-    month = parts[1]
-    day = parts[2]
-    branch_type = parts[3]
-    build_or_commit = parts[4]
-    
-    if adjust_for_pep_440:
-        version_number = f"{year}.{month}.{day}+{branch_type}.{build_or_commit}"
-    
-    # Note that Pypi does not allow local labels to be used. It is very strict
-    # that it is a public package repository meant to serve public packages.
-    # As such, the version numbers output by this library will not be compliant
-    # with pypi (though they will work with other systems like artifactory).
-    # 
-    # One of the main issues is that the PEP 440 scheme really only allows numbers
-    # which it represents with N:
-    #
-    #        [N!]N(.N)*[{a|b|rc}N][.postN][.devN]
-    #
-    # This means that only integration branches can have version numbers because 
-    # they are synchronous in nature. Asynchronous branches cannot be assigned 
-    # sequential numbers because they are non-sequention by nature.
-    
-    if adjust_for_pypi:
-        if branch_type == "master":
-            version_number = f"{year}.{month}.{day}.rc{build_or_commit}"
-        elif branch_type == "release":
-            version_number = f"{year}.{month}.{day}.{build_or_commit}"
-        else:
-            logging.debug(adjust_for_pep_440)
-            logging.debug(adjust_for_pypi)
-            raise Exception(f"Unable to determine version number for a branch of type {branch_type} as it is not compliant with pypi's enforcement of PEP 440. See notes in source code for more details.")
-
+from ShellUtilities import Shell
+import os
+import logging
+from pathlib import Path
+import sys
+import platform
+
+# This contains python functions which invokes the bash script to determine the version number.
+
+def determine_version_number(repo_path=None, adjust_for_pep_440=True, adjust_for_pypi=False):
+    
+    # Determine if we are using conda
+    try:
+        if os.environ["CONDA_DEFAULT_ENV"]:
+            logging.info("Detected that a conda environment is being used.")
+            using_conda = True
+            conda_env_name = os.environ["CONDA_DEFAULT_ENV"]
+            conda_env_path = os.environ["CONDA_PREFIX"]
+    except:
+        using_conda = False
+    
+    script_name = "determine_tbd_calver_version_number.sh"
+    script_installed = False
+    
+    # Determine the platform
+    if platform.system() == "Linux" and not using_conda:
+        # Check the environment variable named PATH to see if the script was installed
+        logging.debug("Searching PATH for installed bash script.")
+        logging.debug(os.linesep + os.environ["PATH"])
+        script_installed = False
+        for path in os.environ["PATH"].split(":"):
+            script_path = os.path.join(path, script_name)
+            if os.path.exists(script_path):
+                script_installed = True
+                logging.debug(f"Found script at '{script_path}'")
+                break
+        logging.warn("Script not found in environment PATH.")       
+    elif platform.system() == "Windows" and not using_conda:
+        # On windows, the user is expected to use a bash-like environment
+        logging.warn("Script not found in windows environment.")
+        pass
+    elif using_conda:
+        script_path = os.path.join(conda_env_path, "bin", script_name)
+        logging.debug(f"Checking conda environment for: {script_path}")
+        if os.path.exists(script_path):
+            script_installed = True
+            logging.debug(f"Found script at '{script_path}'")
+        else:
+            logging.warn("Script not found in conda environment.")
+ 
+    # If the script is not installed into the PATH, assume we are running from inside the git repo
+    # Check if the script can be found locally
+    if not script_installed:
+        logging.warn("Assuming script is being run from the local git repo instead.")  
+        current_dir = os.path.dirname(os.path.abspath(__file__))
+        if not repo_path:
+            repo_path = os.getcwd()
+        logging.debug(f"Repo path set to: {repo_path}")
+        src_root_dir = os.path.dirname(current_dir)
+        bash_dir = os.path.join(src_root_dir, "bash", "bin")
+        script_path = os.path.join(bash_dir, script_name)
+        if os.path.exists(script_path):
+            script_installed = True
+            logging.debug(f"Found script at '{script_path}'")
+
+    if not script_installed:
+        raise Exception("Unable to determine location of determine_tbd_calver_version_number.sh.")
+    
+    # Now that we know where the script is, we can run it
+    # Before we can run it however, we need to identify the bash interpreter we will use
+    interpreter = ""
+    try:
+        Shell.execute_shell_command(f"bash --version", cwd=repo_path).Stdout
+        interpreter = "bash"
+    except:
+        pass
+    if not interpreter:
+        logging.warning("The bash executable was not found or not configured properly. Checking for sh executable.")
+        try:
+            Shell.execute_shell_command(f"sh --version", cwd=repo_path).Stdout
+            interpreter = "sh"
+        except:
+            pass
+    if not interpreter:
+        logging.fatal("Unable to find a working bash interpreter")
+    
+    version_number = Shell.execute_shell_command(f"{interpreter} {script_path}", cwd=repo_path).Stdout
+    
+    if not adjust_for_pep_440 and not adjust_for_pypi:
+        return version_number
+    
+    # With PEP 440 version specifier is `<public identifier>[+<local label>]`
+    # This means we need to adjust our version number to use a + rather than a .
+    # for the fourth element in the version number
+    #
+        
+    parts = version_number.split(".")
+    year = parts[0]
+    month = parts[1]
+    day = parts[2]
+    branch_type = parts[3]
+    build_or_commit = parts[4]
+    
+    if adjust_for_pep_440:
+        version_number = f"{year}.{month}.{day}+{branch_type}.{build_or_commit}"
+    
+    # Note that Pypi does not allow local labels to be used. It is very strict
+    # that it is a public package repository meant to serve public packages.
+    # As such, the version numbers output by this library will not be compliant
+    # with pypi (though they will work with other systems like artifactory).
+    # 
+    # One of the main issues is that the PEP 440 scheme really only allows numbers
+    # which it represents with N:
+    #
+    #        [N!]N(.N)*[{a|b|rc}N][.postN][.devN]
+    #
+    # This means that only integration branches can have version numbers because 
+    # they are synchronous in nature. Asynchronous branches cannot be assigned 
+    # sequential numbers because they are non-sequention by nature.
+    
+    if adjust_for_pypi:
+        if branch_type == "master":
+            version_number = f"{year}.{month}.{day}.rc{build_or_commit}"
+        elif branch_type == "release":
+            version_number = f"{year}.{month}.{day}.{build_or_commit}"
+        else:
+            logging.debug(adjust_for_pep_440)
+            logging.debug(adjust_for_pypi)
+            raise Exception(f"Unable to determine version number for a branch of type {branch_type} as it is not compliant with pypi's enforcement of PEP 440. See notes in source code for more details.")
+
     return version_number
```

## Comparing `tbd_calver_versioning-2024.5.13.1.data/data/bin/determine_tbd_calver_version_number.sh` & `tbd_calver_versioning-2024.5.24.2.data/data/bin/determine_tbd_calver_version_number.sh`

 * *Ordering differences only*

 * *Files 10% similar despite different names*

```diff
@@ -1,146 +1,146 @@
-#!/bin/bash
-
-set -e
-set -x
-
-# This script will determine the version number of a commit based on the 
-# Trunk Based Development branching strategy and a CalVer versioning strategy
-#
-# The branching strategy assumes that the following branches/branch types exist:
-#
-#   release/<yyyy.mm.dd>
-#   patch/<human-friendly-description>
-#   master
-#   bug/<human-friendly-description>
-#   feature/<human-friendly-description>
-#
-# We can expect version numbers to resemble the following:
-#
-#   2022.03.31.release.5
-#   2022.03.31.patch.2a00f14b
-#   2022.03.31.main.1
-#   2022.03.31.feature.2a00f143
-#   2022.03.31.bug.2a00f143028f
-#
-# The build number or SHA will be added based on the branch type. Build numbers 
-# will increment with each merge that occurs on a given day.
-#
-
-# Collect information about bash environment
-
-SHELL_VERSION=$(bash --version | grep GNU || true)
-SHELL_COMMAND="bash"
-if [ -z "${SHELL_VERSION}" ]; then
-	>&2 echo "WARNING: The bash executable was not found or not configured properly. Checking for sh executable."
-	SHELL_VERSION=$(sh --version | grep GNU || true)
-	SHELL_COMMAND="sh"
-fi
-if [ -z "${SHELL_VERSION}" ]; then
-	>&2 echo "Unable to find a working bash interpreter"
-	exit
-fi
-
-# Collect information from the git client
-
-	GIT_VERSION=$(git --version)
-	BRANCH_NAME=$(git branch | grep "*" | awk '{print $2}')
-	BRANCH_TYPE=$(echo "${BRANCH_NAME}" | awk -F/ '{print $1}')
-	BRANCH_NAME_PART_COUNT=$(echo "${BRANCH_NAME}" | sed 's/\// /g' | wc -w)
-	COMMIT_HASH=$(git log -1 --format=format:"%h")
-	COMMIT_DATE=$(git log -1 --format="%at" | xargs -I{} date -d @{} +'%Y-%m-%d')
-	COMMIT_DATE_PRETTY=$(date -d "${COMMIT_DATE}" +'%Y.%m.%d')
-	PREVIOUS_DATE=$(date -d "${COMMIT_DATE} -1 days" +'%Y-%m-%d')
-	if [ -z "${MAINLINE_BRANCH}" ]; then
-		export MAINLINE_BRANCH=master
-	fi
-
-# Determine if we are dealing with a merge commit (likely a merge request or pull request)
-
-	# https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
-	SOURCE=${BASH_SOURCE[0]}
-	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
-		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
-		SOURCE=$(readlink "$SOURCE")
-		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
-	done
-	CURRENT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
-
-	ROOT_DIR=$(dirname $(realpath "$CURRENT_DIR"))
-	IS_MERGE_COMMIT=$($SHELL_COMMAND "${ROOT_DIR}/repo_inspection/determine_if_commit_is_merge_commit.sh")
-
-# Validate the information we collected and raise an exception if something doesnt look right
-
-	if 	[[ "${BRANCH_TYPE}" != "release" ]] && \
-		[[ "${BRANCH_TYPE}" != "patch" ]] && \
-		[[ "${BRANCH_TYPE}" != "${MAINLINE_BRANCH}" ]] && \
-		[[ "${BRANCH_TYPE}" != "bug" ]] && \
-		[[ "${BRANCH_TYPE}" != "feature" ]]
-	then
-		echo "The branch type ${BRANCH_TYPE} is not supported"
-		exit 1
-	fi
-	
-	if [[ "${BRANCH_NAME_PART_COUNT}" != 1 && "${BRANCH_NAME_PART_COUNT}" != 2 ]]; then
-		echo "The branch name ${BRANCH_NAME} did not have the right number of parts"
-		exit 1
-	fi
-
-# Collect more information for the edge cases
-
-	# When a commit is made, the commit has parents marking the branches involved
-	# Typically, first perent represents the branch where the commit was originally made
-	# The first-parent flag allows us to filter out commit/merges which occurred on our branch
-	# as opposed to another branch
-	
-	FIRST_COMMIT=$(git log --pretty=tformat:"%h" --first-parent | tail -n 1)
-
-	# If we are on an integration branch we will consider all merges and commits
-	# but if we are on a non-integration branch we will only consider merges and commits
-	# that occur after the commit that created the branch. This means we need special logic 
-	# for the release branch and master branch.
-
-	if [[ "${BRANCH_TYPE}" == "release" ]]; then
-		COMMIT_WHERE_BRANCH_CREATED=$($SHELL_COMMAND "${ROOT_DIR}/repo_inspection/determine_commit_where_branch_created.sh")	
-		MERGES_COUNT=$(git rev-list --first-parent --count ${COMMIT_WHERE_BRANCH_CREATED}..HEAD --merges)
-		COMMIT_COUNT=$(git rev-list --first-parent --count ${COMMIT_WHERE_BRANCH_CREATED}..HEAD --no-merges)
-		VERSION_COUNT=$((MERGES_COUNT + COMMIT_COUNT + 1)) 
-		# Note: We add one because the revlist command above does not include the commit in question
-	elif [[ "${BRANCH_TYPE}" == "master" ]]; then
-		MERGES_COUNT=$(git rev-list --first-parent --count HEAD --since=${PREVIOUS_DATE} --merges)
-		COMMIT_COUNT=$(git rev-list --first-parent --count HEAD --since=${PREVIOUS_DATE} --no-merges)
-		VERSION_COUNT=$((MERGES_COUNT + COMMIT_COUNT))
-	fi
-
-
-	# =========================================================
-	# Special case #1: Committing directly to mainline or release
-	# =========================================================
-	# Normally we should not be committing directly to the integration branches (master/release)
-	# However there is a special case when we are allowed to have commits appear without merges
-	# For master, the initial commit on the branch 
-	# For release, when branching from master and inheriting that initial commit
-
-	if [[ "${COMMIT_HASH}" != "${FIRST_COMMIT}" ]]; then
-		echo "WARNING: A regular (non-merge) commit is not allowed on a ${BRANCH_TYPE} type branch." >&2
-		echo "All commits made to this branch must be merge commits!" >&2
-	fi
-
-# Set the version number
-
-	if [[ "${BRANCH_TYPE}" == "bug" || "${BRANCH_TYPE}" == "feature" || "${BRANCH_TYPE}" == "patch" ]]; then
-		VERSION_NUMBER="${COMMIT_DATE_PRETTY}.${BRANCH_TYPE}.${COMMIT_HASH}"
-	elif [[ "${BRANCH_TYPE}" == "${MAINLINE_BRANCH}" || "${BRANCH_TYPE}" == "release" ]]; then
-		# Count the number of merge commits
-        VERSION_NUMBER="${COMMIT_DATE_PRETTY}.${BRANCH_TYPE}.${VERSION_COUNT}"
-	fi
-
-	VERSION_REGEX="^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.(release|patch|${MAINLINE_BRANCH}|feature|bug)\.([a-z0-9]{7}|[0-9]+)$"
-	VERSION_CHECK=$(echo "${VERSION_NUMBER}" | grep -o -E "${VERSION_REGEX}")
-
-	if [ -z "${VERSION_NUMBER}" ] || [[ "${VERSION_CHECK}" != "${VERSION_NUMBER}" ]]; then
-		echo "The version number was not set correctly"
-		exit 1
-	fi
-
-	echo "${VERSION_NUMBER}"
-
+#!/bin/bash
+
+set -e
+set -x
+
+# This script will determine the version number of a commit based on the 
+# Trunk Based Development branching strategy and a CalVer versioning strategy
+#
+# The branching strategy assumes that the following branches/branch types exist:
+#
+#   release/<yyyy.mm.dd>
+#   patch/<human-friendly-description>
+#   master
+#   bug/<human-friendly-description>
+#   feature/<human-friendly-description>
+#
+# We can expect version numbers to resemble the following:
+#
+#   2022.03.31.release.5
+#   2022.03.31.patch.2a00f14b
+#   2022.03.31.main.1
+#   2022.03.31.feature.2a00f143
+#   2022.03.31.bug.2a00f143028f
+#
+# The build number or SHA will be added based on the branch type. Build numbers 
+# will increment with each merge that occurs on a given day.
+#
+
+# Collect information about bash environment
+
+SHELL_VERSION=$(bash --version | grep GNU || true)
+SHELL_COMMAND="bash"
+if [ -z "${SHELL_VERSION}" ]; then
+	>&2 echo "WARNING: The bash executable was not found or not configured properly. Checking for sh executable."
+	SHELL_VERSION=$(sh --version | grep GNU || true)
+	SHELL_COMMAND="sh"
+fi
+if [ -z "${SHELL_VERSION}" ]; then
+	>&2 echo "Unable to find a working bash interpreter"
+	exit
+fi
+
+# Collect information from the git client
+
+	GIT_VERSION=$(git --version)
+	BRANCH_NAME=$(git branch | grep "*" | awk '{print $2}')
+	BRANCH_TYPE=$(echo "${BRANCH_NAME}" | awk -F/ '{print $1}')
+	BRANCH_NAME_PART_COUNT=$(echo "${BRANCH_NAME}" | sed 's/\// /g' | wc -w)
+	COMMIT_HASH=$(git log -1 --format=format:"%h")
+	COMMIT_DATE=$(git log -1 --format="%at" | xargs -I{} date -d @{} +'%Y-%m-%d')
+	COMMIT_DATE_PRETTY=$(date -d "${COMMIT_DATE}" +'%Y.%m.%d')
+	PREVIOUS_DATE=$(date -d "${COMMIT_DATE} -1 days" +'%Y-%m-%d')
+	if [ -z "${MAINLINE_BRANCH}" ]; then
+		export MAINLINE_BRANCH=master
+	fi
+
+# Determine if we are dealing with a merge commit (likely a merge request or pull request)
+
+	# https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
+	SOURCE=${BASH_SOURCE[0]}
+	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
+		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
+		SOURCE=$(readlink "$SOURCE")
+		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
+	done
+	CURRENT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
+
+	ROOT_DIR=$(dirname $(realpath "$CURRENT_DIR"))
+	IS_MERGE_COMMIT=$($SHELL_COMMAND "${ROOT_DIR}/repo_inspection/determine_if_commit_is_merge_commit.sh")
+
+# Validate the information we collected and raise an exception if something doesnt look right
+
+	if 	[[ "${BRANCH_TYPE}" != "release" ]] && \
+		[[ "${BRANCH_TYPE}" != "patch" ]] && \
+		[[ "${BRANCH_TYPE}" != "${MAINLINE_BRANCH}" ]] && \
+		[[ "${BRANCH_TYPE}" != "bug" ]] && \
+		[[ "${BRANCH_TYPE}" != "feature" ]]
+	then
+		echo "The branch type ${BRANCH_TYPE} is not supported"
+		exit 1
+	fi
+	
+	if [[ "${BRANCH_NAME_PART_COUNT}" != 1 && "${BRANCH_NAME_PART_COUNT}" != 2 ]]; then
+		echo "The branch name ${BRANCH_NAME} did not have the right number of parts"
+		exit 1
+	fi
+
+# Collect more information for the edge cases
+
+	# When a commit is made, the commit has parents marking the branches involved
+	# Typically, first perent represents the branch where the commit was originally made
+	# The first-parent flag allows us to filter out commit/merges which occurred on our branch
+	# as opposed to another branch
+	
+	FIRST_COMMIT=$(git log --pretty=tformat:"%h" --first-parent | tail -n 1)
+
+	# If we are on an integration branch we will consider all merges and commits
+	# but if we are on a non-integration branch we will only consider merges and commits
+	# that occur after the commit that created the branch. This means we need special logic 
+	# for the release branch and master branch.
+
+	if [[ "${BRANCH_TYPE}" == "release" ]]; then
+		COMMIT_WHERE_BRANCH_CREATED=$($SHELL_COMMAND "${ROOT_DIR}/repo_inspection/determine_commit_where_branch_created.sh")	
+		MERGES_COUNT=$(git rev-list --first-parent --count ${COMMIT_WHERE_BRANCH_CREATED}..HEAD --merges)
+		COMMIT_COUNT=$(git rev-list --first-parent --count ${COMMIT_WHERE_BRANCH_CREATED}..HEAD --no-merges)
+		VERSION_COUNT=$((MERGES_COUNT + COMMIT_COUNT + 1)) 
+		# Note: We add one because the revlist command above does not include the commit in question
+	elif [[ "${BRANCH_TYPE}" == "master" ]]; then
+		MERGES_COUNT=$(git rev-list --first-parent --count HEAD --since=${PREVIOUS_DATE} --merges)
+		COMMIT_COUNT=$(git rev-list --first-parent --count HEAD --since=${PREVIOUS_DATE} --no-merges)
+		VERSION_COUNT=$((MERGES_COUNT + COMMIT_COUNT))
+	fi
+
+
+	# =========================================================
+	# Special case #1: Committing directly to mainline or release
+	# =========================================================
+	# Normally we should not be committing directly to the integration branches (master/release)
+	# However there is a special case when we are allowed to have commits appear without merges
+	# For master, the initial commit on the branch 
+	# For release, when branching from master and inheriting that initial commit
+
+	if [[ "${COMMIT_HASH}" != "${FIRST_COMMIT}" ]]; then
+		echo "WARNING: A regular (non-merge) commit is not allowed on a ${BRANCH_TYPE} type branch." >&2
+		echo "All commits made to this branch must be merge commits!" >&2
+	fi
+
+# Set the version number
+
+	if [[ "${BRANCH_TYPE}" == "bug" || "${BRANCH_TYPE}" == "feature" || "${BRANCH_TYPE}" == "patch" ]]; then
+		VERSION_NUMBER="${COMMIT_DATE_PRETTY}.${BRANCH_TYPE}.${COMMIT_HASH}"
+	elif [[ "${BRANCH_TYPE}" == "${MAINLINE_BRANCH}" || "${BRANCH_TYPE}" == "release" ]]; then
+		# Count the number of merge commits
+        VERSION_NUMBER="${COMMIT_DATE_PRETTY}.${BRANCH_TYPE}.${VERSION_COUNT}"
+	fi
+
+	VERSION_REGEX="^[0-9]{4}\.[0-9]{2}\.[0-9]{2}\.(release|patch|${MAINLINE_BRANCH}|feature|bug)\.([a-z0-9]{7}|[0-9]+)$"
+	VERSION_CHECK=$(echo "${VERSION_NUMBER}" | grep -o -E "${VERSION_REGEX}")
+
+	if [ -z "${VERSION_NUMBER}" ] || [[ "${VERSION_CHECK}" != "${VERSION_NUMBER}" ]]; then
+		echo "The version number was not set correctly"
+		exit 1
+	fi
+
+	echo "${VERSION_NUMBER}"
+
```

## Comparing `tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/checkout_git_repo_properly.sh` & `tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/checkout_git_repo_properly.sh`

 * *Ordering differences only*

 * *Files 26% similar despite different names*

```diff
@@ -1,51 +1,51 @@
-#!/bin/bash
-
-set -e
-set -x
-
-# This script will fetch all branches and tags fromthe remote and then checkout a branch and reset it to a specific commit
-#
-# It assumes we have already authenticated as a git user
-#
-
-# Retrieve parameters from environment variables	
-
-	if [ -z "${BRANCH_NAME}" ]; then
-		echo "The BRANCH_NAME was not supplied"
-		exit 1
-	fi
-        if [ -z "${COMMIT_HASH}" ]; then
-			echo "The COMMIT_HASH was not supplied"
-			exit 1
-        fi
-	if [ -z "${MAINLINE_BRANCH}" ]; then
-		echo "The MAINLINE_BRANCH was not supplied"
-		exit 1
-	fi
-
-	if [ -z "${GIT_URL}" ]; then
-			echo "The GIT_URL was not supplied attempting to retrieve from repo"
-		GIT_URL=$(git remote --v | grep fetch | awk '{print $2}')
-		if [ -z "${GIT_URL}" ]; then
-			echo "The git url could not be determined"
-			exit 1
-		fi
-    fi
-
-# Configure git so we can pull the branches
-
-	git config --list
-	# This command will return non-zero exit code if nothing is currently set
-	git config --unset-all remote.origin.fetch || true
-	git config --global --unset-all remote.origin.fetch || true
-	git config remote.origin.fetch refs/heads/${MAINLINE_BRANCH}:refs/remotes/origin/${MAINLINE_BRANCH}
-	git config --add remote.origin.fetch refs/heads/${BRANCH_NAME}:refs/remotes/origin/${BRANCH_NAME}
-	git config --list
-
-# Do the checkout
-
-
-	git fetch --all --tags
-
-	git checkout "${BRANCH_NAME}"
-    git reset --hard "${COMMIT_HASH}"
+#!/bin/bash
+
+set -e
+set -x
+
+# This script will fetch all branches and tags fromthe remote and then checkout a branch and reset it to a specific commit
+#
+# It assumes we have already authenticated as a git user
+#
+
+# Retrieve parameters from environment variables	
+
+	if [ -z "${BRANCH_NAME}" ]; then
+		echo "The BRANCH_NAME was not supplied"
+		exit 1
+	fi
+        if [ -z "${COMMIT_HASH}" ]; then
+			echo "The COMMIT_HASH was not supplied"
+			exit 1
+        fi
+	if [ -z "${MAINLINE_BRANCH}" ]; then
+		echo "The MAINLINE_BRANCH was not supplied"
+		exit 1
+	fi
+
+	if [ -z "${GIT_URL}" ]; then
+			echo "The GIT_URL was not supplied attempting to retrieve from repo"
+		GIT_URL=$(git remote --v | grep fetch | awk '{print $2}')
+		if [ -z "${GIT_URL}" ]; then
+			echo "The git url could not be determined"
+			exit 1
+		fi
+    fi
+
+# Configure git so we can pull the branches
+
+	git config --list
+	# This command will return non-zero exit code if nothing is currently set
+	git config --unset-all remote.origin.fetch || true
+	git config --global --unset-all remote.origin.fetch || true
+	git config remote.origin.fetch refs/heads/${MAINLINE_BRANCH}:refs/remotes/origin/${MAINLINE_BRANCH}
+	git config --add remote.origin.fetch refs/heads/${BRANCH_NAME}:refs/remotes/origin/${BRANCH_NAME}
+	git config --list
+
+# Do the checkout
+
+
+	git fetch --all --tags
+
+	git checkout "${BRANCH_NAME}"
+    git reset --hard "${COMMIT_HASH}"
```

## Comparing `tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/configure_credential_helper.sh` & `tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/configure_credential_helper.sh`

 * *Ordering differences only*

 * *Files 21% similar despite different names*

```diff
@@ -1,56 +1,56 @@
-#!/bin/bash
-
-#This script will configure the git credential helper to store git credentials locally so that git commands 
-#authenticate automatically against a remote. Some solutions natively build in this integration (eg. Azure devops). 
-#Some do not (eg. Jenkins and gitlab).
-
-set -e
-set -x
-
-# Check the environment variables are set
-
-	if [ -z "${GIT_USERNAME}" ]; then
-		echo "The git username was not supplied"
-		exit 1
-	fi
-
-	if [ -z "${GIT_PASSWORD}" ]; then
-		echo "The git password was not supplied"
-		exit 1
-	fi
-
-	if [ -z "${GIT_URL}" ]; then
-		echo "The git url was not supplied"
-		exit 1
-	fi
-
-# Disect the URL and extract components
-
-    URL_HEAD=$(echo "${GIT_URL}" | grep -o -E 'http[s]?://')
-	URL_TAIL=$(echo "${GIT_URL}" | sed -e 's/^.*:\/\///g')
-	URL_SERVER=$(echo "${URL_TAIL}" | sed -e 's/\/.*$//g')
-
-# Url encode the necessary components
-
-	ENCODED_URL_SERVER=$( echo "${URL_SERVER}" | python -c "import urllib;print urllib.quote(raw_input())" )
-	ENCODED_USERNAME=$( echo "${GIT_USERNAME}" | python -c "import urllib;print urllib.quote(raw_input())" )
-    ENCODED_PASSWORD=$( echo "${GIT_PASSWORD}" | python -c "import urllib;print urllib.quote(raw_input())" )
-
-# Construct the string for the credential store
-
-    CREDENTIAL_STRING="${URL_HEAD}${ENCODED_USERNAME}:${ENCODED_PASSWORD}@${ENCODED_URL_SERVER}"
-
-# Add the password if it is not already added to the credential store password file
-
-	if [ ! -f ~/.git-credentials ]; then
-		echo "${CREDENTIAL_STRING}" > ~/.git-credentials
-	else
-		CREDENTIALS_EXIST=$(cat ~/.git-credentials | grep ${CREDENTIAL_STRING} || true)
-		if [ -z "${CREDENTIALS_EXIST}" ]; then
-			echo "${CREDENTIAL_STRING}" >> ~/.git-credentials
-		fi
-	fi
-
-# Configure git to use the credential store
-
-	git config credential.helper store
+#!/bin/bash
+
+#This script will configure the git credential helper to store git credentials locally so that git commands 
+#authenticate automatically against a remote. Some solutions natively build in this integration (eg. Azure devops). 
+#Some do not (eg. Jenkins and gitlab).
+
+set -e
+set -x
+
+# Check the environment variables are set
+
+	if [ -z "${GIT_USERNAME}" ]; then
+		echo "The git username was not supplied"
+		exit 1
+	fi
+
+	if [ -z "${GIT_PASSWORD}" ]; then
+		echo "The git password was not supplied"
+		exit 1
+	fi
+
+	if [ -z "${GIT_URL}" ]; then
+		echo "The git url was not supplied"
+		exit 1
+	fi
+
+# Disect the URL and extract components
+
+    URL_HEAD=$(echo "${GIT_URL}" | grep -o -E 'http[s]?://')
+	URL_TAIL=$(echo "${GIT_URL}" | sed -e 's/^.*:\/\///g')
+	URL_SERVER=$(echo "${URL_TAIL}" | sed -e 's/\/.*$//g')
+
+# Url encode the necessary components
+
+	ENCODED_URL_SERVER=$( echo "${URL_SERVER}" | python -c "import urllib;print urllib.quote(raw_input())" )
+	ENCODED_USERNAME=$( echo "${GIT_USERNAME}" | python -c "import urllib;print urllib.quote(raw_input())" )
+    ENCODED_PASSWORD=$( echo "${GIT_PASSWORD}" | python -c "import urllib;print urllib.quote(raw_input())" )
+
+# Construct the string for the credential store
+
+    CREDENTIAL_STRING="${URL_HEAD}${ENCODED_USERNAME}:${ENCODED_PASSWORD}@${ENCODED_URL_SERVER}"
+
+# Add the password if it is not already added to the credential store password file
+
+	if [ ! -f ~/.git-credentials ]; then
+		echo "${CREDENTIAL_STRING}" > ~/.git-credentials
+	else
+		CREDENTIALS_EXIST=$(cat ~/.git-credentials | grep ${CREDENTIAL_STRING} || true)
+		if [ -z "${CREDENTIALS_EXIST}" ]; then
+			echo "${CREDENTIAL_STRING}" >> ~/.git-credentials
+		fi
+	fi
+
+# Configure git to use the credential store
+
+	git config credential.helper store
```

## Comparing `tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_commit_where_branch_created.sh` & `tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_commit_where_branch_created.sh`

 * *Ordering differences only*

 * *Files 17% similar despite different names*

```diff
@@ -1,35 +1,35 @@
-#!/bin/bash
-
-# Overview:
-#     This script will do some git-magic to find the first commit on a branch
-#     This magic is done using the git rev-list command (which is not subject to ref log expiration)
-#
-# Explanation:
-#     We basically get a list of commits on the mainline/integration branch and a list of commits on our non-mainline
-#     We then diff the lists to generate a list of commits that are in the non-mainline but not mainline
-#     We then take the last item (earliers) from this list
-#
-# Assumptions:
-#     This command script assumes you are currently checked out on a branch
-#
-# Credits:
-#     https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git
-
-set -e
-set -x
-
-# Ensure environment variables are set
-
-	if [ -z "${MAINLINE_BRANCH}" ]; then
-		echo "The mainline branch name was not set."
-		exit 1
-	fi
-
-# Do some magic to diff the two revision lists
-
-	FISRT_COMMIT_ON_BRANCH=$( diff --old-line-format='' --new-line-format='' \
-		<(git rev-list --first-parent "${1:-${MAINLINE_BRANCH}}") \
-	        <(git rev-list --first-parent "${2:-HEAD}") | head -1)
-
-	echo "${FISRT_COMMIT_ON_BRANCH=$}"
-
+#!/bin/bash
+
+# Overview:
+#     This script will do some git-magic to find the first commit on a branch
+#     This magic is done using the git rev-list command (which is not subject to ref log expiration)
+#
+# Explanation:
+#     We basically get a list of commits on the mainline/integration branch and a list of commits on our non-mainline
+#     We then diff the lists to generate a list of commits that are in the non-mainline but not mainline
+#     We then take the last item (earliers) from this list
+#
+# Assumptions:
+#     This command script assumes you are currently checked out on a branch
+#
+# Credits:
+#     https://stackoverflow.com/questions/1527234/finding-a-branch-point-with-git
+
+set -e
+set -x
+
+# Ensure environment variables are set
+
+	if [ -z "${MAINLINE_BRANCH}" ]; then
+		echo "The mainline branch name was not set."
+		exit 1
+	fi
+
+# Do some magic to diff the two revision lists
+
+	FISRT_COMMIT_ON_BRANCH=$( diff --old-line-format='' --new-line-format='' \
+		<(git rev-list --first-parent "${1:-${MAINLINE_BRANCH}}") \
+	        <(git rev-list --first-parent "${2:-HEAD}") | head -1)
+
+	echo "${FISRT_COMMIT_ON_BRANCH=$}"
+
```

## Comparing `tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh` & `tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh`

 * *Ordering differences only*

 * *Files 18% similar despite different names*

```diff
@@ -1,100 +1,100 @@
-#!/bin/bash
-
-#This file will accept an array of file paths and will compare those files paths with the list of modified files being tracked 
-#in git for this branch. It does a log of git magic to get this list of files and more importantly to determine the commit 
-#where the branch started. Once it has the list of files that have changed it compares that list with the list of triggers 
-#and print a list of the files which match the triggers. The triggers are regex patterns and are expected to be defined on the 
-#pipelines.
-
-set -e
-set -x
-
-# Ensure environment variables are set
-
-	if [ -z "${MAINLINE_BRANCH}" ]; then
-		echo "The mainline branch was not set"
-		exit 1
-	fi
-
-	# TRIGGER_PATTERNS is expected to be a space delimited list of string"
-
-	if [ -z "${TRIGGER_PATTERNS}" ]; then
-		echo "The list of trigger patterns was not set"
-		exit 1
-	fi
-
-# Parse the array
-
-	declare -a TRIGGER_PATTERNS_ARRAY
-	read -a TRIGGER_PATTERNS_ARRAY <<< "${TRIGGER_PATTERNS}"
-
-	# Print statement for debugging purposes
-        echo "${TRIGGER_PATTERNS_ARRAY[@]}" >&2
-
-        echo "Trigger pattern array length: ${#TRIGGER_PATTERNS_ARRAY[@]}" >&2
-
-# Determine where we are
-
-	# https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
-	SOURCE=${BASH_SOURCE[0]}
-	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
-		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
-		SOURCE=$(readlink "$SOURCE")
-		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
-	done
-	CURRENT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
-
-# Determine if the current branch is a mainline branch or not
-
-        BRANCH_NAME=$(git branch | grep "*" | awk '{print $2}')
-        if [ -z "${BRANCH_NAME}" ]; then
-		echo "Branch name could not bet determined" >&2
-		exit 1
-	fi
-	if [ "${BRANCH_NAME}" = "${MAINLINE_BRANCH}" ]; then
-		IS_MAINLINE="true"
-	else
-		IS_MAINLINE="false"
-	fi
-
-# If this is a mainline branch, determine the commit hash of the previous merge commit
-# Otherwise get the previous commit
-
-	if [ "${IS_MAINLINE}" = "true" ]; then
-		PREVIOUS_COMMIT_HASH=$(git log --merges "${MAINLINE_BRANCH}" --pretty=oneline | awk '{print $1}' | head -n 1)
-	fi
-	
-	if [ "${IS_MAINLINE}" = "false" ] || [ -z "${PREVIOUS_COMMIT_HASH}" ]; then
-		PREVIOUS_COMMIT_HASH=$(git rev-list HEAD~1 | head -n 1)
-	fi
-
-# Get a list of files that have changed
-
-	CHANGED_FILES=( $(bash "${CURRENT_DIR}/get_changed_files_since_commit.sh" "${PREVIOUS_COMMIT_HASH}") )
-
-# Check if the changed files match any of ther triggers
-
-	MATCHING_FILE=""
-	for TRIGGER_PATTERN in "${TRIGGER_PATTERNS_ARRAY[@]}"
-	do
-		TRIGGER_PATTERN=$(echo "${TRIGGER_PATTERN}" | tr -d '\047') # Remove wrapped single quotes
-
-		for CHANGED_FILE in "${CHANGED_FILES[@]}"
-		do
-			TRIGGER_MATCH=$(echo "${CHANGED_FILE}" | grep -o -E "${TRIGGER_PATTERN}" || true)
-
-			if [[ ! -z "${TRIGGER_MATCH}" ]]; then
-				echo "Changed file '${CHANGED_FILE}' matched trigger pattern '${TRIGGER_PATTERN}'" >&2
-				MATCHING_FILE="${CHANGED_FILE}"
-				echo "true"
-				exit 0
-			fi
-		done
-	done
-
-
-	if [ -z "${MATCHING_FILE}" ]; then
-		echo "false"
-	else
-		echo "true"
-	fi
+#!/bin/bash
+
+#This file will accept an array of file paths and will compare those files paths with the list of modified files being tracked 
+#in git for this branch. It does a log of git magic to get this list of files and more importantly to determine the commit 
+#where the branch started. Once it has the list of files that have changed it compares that list with the list of triggers 
+#and print a list of the files which match the triggers. The triggers are regex patterns and are expected to be defined on the 
+#pipelines.
+
+set -e
+set -x
+
+# Ensure environment variables are set
+
+	if [ -z "${MAINLINE_BRANCH}" ]; then
+		echo "The mainline branch was not set"
+		exit 1
+	fi
+
+	# TRIGGER_PATTERNS is expected to be a space delimited list of string"
+
+	if [ -z "${TRIGGER_PATTERNS}" ]; then
+		echo "The list of trigger patterns was not set"
+		exit 1
+	fi
+
+# Parse the array
+
+	declare -a TRIGGER_PATTERNS_ARRAY
+	read -a TRIGGER_PATTERNS_ARRAY <<< "${TRIGGER_PATTERNS}"
+
+	# Print statement for debugging purposes
+        echo "${TRIGGER_PATTERNS_ARRAY[@]}" >&2
+
+        echo "Trigger pattern array length: ${#TRIGGER_PATTERNS_ARRAY[@]}" >&2
+
+# Determine where we are
+
+	# https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
+	SOURCE=${BASH_SOURCE[0]}
+	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
+		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
+		SOURCE=$(readlink "$SOURCE")
+		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
+	done
+	CURRENT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
+
+# Determine if the current branch is a mainline branch or not
+
+        BRANCH_NAME=$(git branch | grep "*" | awk '{print $2}')
+        if [ -z "${BRANCH_NAME}" ]; then
+		echo "Branch name could not bet determined" >&2
+		exit 1
+	fi
+	if [ "${BRANCH_NAME}" = "${MAINLINE_BRANCH}" ]; then
+		IS_MAINLINE="true"
+	else
+		IS_MAINLINE="false"
+	fi
+
+# If this is a mainline branch, determine the commit hash of the previous merge commit
+# Otherwise get the previous commit
+
+	if [ "${IS_MAINLINE}" = "true" ]; then
+		PREVIOUS_COMMIT_HASH=$(git log --merges "${MAINLINE_BRANCH}" --pretty=oneline | awk '{print $1}' | head -n 1)
+	fi
+	
+	if [ "${IS_MAINLINE}" = "false" ] || [ -z "${PREVIOUS_COMMIT_HASH}" ]; then
+		PREVIOUS_COMMIT_HASH=$(git rev-list HEAD~1 | head -n 1)
+	fi
+
+# Get a list of files that have changed
+
+	CHANGED_FILES=( $(bash "${CURRENT_DIR}/get_changed_files_since_commit.sh" "${PREVIOUS_COMMIT_HASH}") )
+
+# Check if the changed files match any of ther triggers
+
+	MATCHING_FILE=""
+	for TRIGGER_PATTERN in "${TRIGGER_PATTERNS_ARRAY[@]}"
+	do
+		TRIGGER_PATTERN=$(echo "${TRIGGER_PATTERN}" | tr -d '\047') # Remove wrapped single quotes
+
+		for CHANGED_FILE in "${CHANGED_FILES[@]}"
+		do
+			TRIGGER_MATCH=$(echo "${CHANGED_FILE}" | grep -o -E "${TRIGGER_PATTERN}" || true)
+
+			if [[ ! -z "${TRIGGER_MATCH}" ]]; then
+				echo "Changed file '${CHANGED_FILE}' matched trigger pattern '${TRIGGER_PATTERN}'" >&2
+				MATCHING_FILE="${CHANGED_FILE}"
+				echo "true"
+				exit 0
+			fi
+		done
+	done
+
+
+	if [ -z "${MATCHING_FILE}" ]; then
+		echo "false"
+	else
+		echo "true"
+	fi
```

## Comparing `tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_on_branch.sh` & `tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_on_branch.sh`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,38 +1,38 @@
-#!/bin/bash
-
-#This file will get a list of files that have changed in any of the git commits that exist on the branch, since the branch was created.
-
-set -e
-set -x
-
-# Ensure required variables are set
-
-	if [ -z "${MAINLINE_BRANCH}" ]; then
-	        echo "The mainline branch was not set"
-		exit 1
-	fi
-
-# Set the current directory
-
-	# https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
-	SOURCE=${BASH_SOURCE[0]}
-	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
-		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
-		SOURCE=$(readlink "$SOURCE")
-		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
-	done
-	CURRENT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
-
-# Determine the commit where this branch originally deviated from the mainline branch
-
-	COMMIT_HASH=$(bash "${CURRENT_DIR}/determine_commit_where_branch_created.sh")
-
-	if [ -z "${COMMIT_HASH}" ]; then
-	        echo "The commit hash where the branch wascreated could not be determined"
-	        exit 1
-	fi
-
-# Get a list of files which changed after this commit
-
-	CHANGED_FILES=$(bash "${CURRENT_DIR}/get_changed_files_since_commit.sh" "${COMMIT_HASH}")
-	echo "${CHANGED_FILES}"
+#!/bin/bash
+
+#This file will get a list of files that have changed in any of the git commits that exist on the branch, since the branch was created.
+
+set -e
+set -x
+
+# Ensure required variables are set
+
+	if [ -z "${MAINLINE_BRANCH}" ]; then
+	        echo "The mainline branch was not set"
+		exit 1
+	fi
+
+# Set the current directory
+
+	# https://stackoverflow.com/questions/59895/how-do-i-get-the-directory-where-a-bash-script-is-located-from-within-the-script
+	SOURCE=${BASH_SOURCE[0]}
+	while [ -L "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
+		DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
+		SOURCE=$(readlink "$SOURCE")
+		[[ $SOURCE != /* ]] && SOURCE=$DIR/$SOURCE # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
+	done
+	CURRENT_DIR=$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )
+
+# Determine the commit where this branch originally deviated from the mainline branch
+
+	COMMIT_HASH=$(bash "${CURRENT_DIR}/determine_commit_where_branch_created.sh")
+
+	if [ -z "${COMMIT_HASH}" ]; then
+	        echo "The commit hash where the branch wascreated could not be determined"
+	        exit 1
+	fi
+
+# Get a list of files which changed after this commit
+
+	CHANGED_FILES=$(bash "${CURRENT_DIR}/get_changed_files_since_commit.sh" "${COMMIT_HASH}")
+	echo "${CHANGED_FILES}"
```

## Comparing `tbd_calver_versioning-2024.5.13.1.dist-info/METADATA` & `tbd_calver_versioning-2024.5.24.2.dist-info/METADATA`

 * *Files 6% similar despite different names*

```diff
@@ -1,95 +1,95 @@
-Metadata-Version: 2.1
-Name: tbd-calver-versioning
-Version: 2024.5.13.1
-Summary: A set of tools to manage a code repository using trunk based development and CalVer.
-Home-page: https://github.com/taylor-schneider/tbd-calver-versioning
-Author: tschneider
-Author-email: tschneider@live.com
-Classifier: Programming Language :: Unix Shell
-Classifier: Programming Language :: Python :: 3
-Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
-Classifier: Operating System :: OS Independent
-Description-Content-Type: text/markdown
-Requires-Dist: ShellUtilities ==2.1.11
-
-# Overview
-
-This repository contains several useful components:
-1. A [BASH script](src/bash/bin/determine_tbd_calver_version_number.sh) which determines the version number of a git repository
-2. A [python module](src/python/tbd_calver_versioning.py) which contains a function which calls the BASH script and then produces a PEP440 compliant version number.
-3. Scripts to [install](scripts/install.sh)/[uninstall](scripts/uninstall.sh) the BASH script, and accompanying libraries, to `/usr/local/bin`
-4. A [setup.py](setup.py) allowing this project to be installed as a pip package
-5. A [pyproject.toml](pyproject.toml) which will install prerequisite packages (ShellUtilities) before running the setup.py.
-6. An [example Setup.py](tests/dummy_files/setup.py) and [example pyproject.toml](tests/dummy_files/pyproject.toml) showing how a function in this python library can be called to version a package automatically as part of another project's setup.py.
-
-
-# Versioning
-
-The version number follows the [CalVer](https://calver.org/) versioning scheme. Each version consists of 5 parts:
-- **Major** - Year of the commit
-- **Minor** - Month of the commit
-- **Micro** - Day of the commit
-- **Modifier** - Branch and either commit hash or build number
-
-The version number will thus be as follows:
-
-```
-<year>.<month>.<day>.<branch_type>.<commit_hash_or_build_number>
-```
-
-**Note**: For the PEP440 standard compliance, the python function will return a version number as follows (notice the '+'):
-
-```
-<year>.<month>.<day>+<branch_type>.<commit_hash_or_build_number>
-```
-
-The logic to construct the version number assumes the repository is following the Trunk Based Development branching strategy:
-
-```
-Branch Type                                  Branch Flow
-==================================================================
-
-release/*                          -------------          ----------
-                                 /   \       /          /      / 
-patch/*                         /      -----           /      /
-                               /             \        /      /
-master                    --------------------------------------------
-(aka. main, integration)     \ \                 /\          /
-                              \ \               /  \        /
-feature/*                      \  --------------    \      /
-                                \                    \    /
-bug/*                             ------------------------
-
-```
-
-Each commit in the branch flow will be given a version number based on the CalVer versioning strategy.
-
-Integration branches like master and release will use a build number for the suffix. Non-integration branches which can occur in parallel will use the first 7 digits of the commit hash as the suffix.
-
-Examples include:
-- 2023.05.23.master.1
-- 2022.12.01.feature.f3b24e1
-
-### Note On Merging
-When merging a non-integration branch into an integration branch we must ensure that there is a merge commit. If we allow the branch to simply fast forward, the logic for determining the version number cannot work. This is because a "branch" is simply a version history and if the version histories are identical between two branches, then our logic breaks. To fix this, use the --no-ff to force a merge commit. For example, if merging main up into a release branch, us the --no-ff to ensure a new merge commit is created on the release and guarantee the release number will be incremented properly.
-
-## Requirements
-- BASH >= 4.2
-- git >= 1.8
-
-## Installation
-There are two options for installing the utilities in this repository:
-- bash scripts only (no python dependency)
-- python module and bash scipts
-
-The bash scripts can be installed by themselves (i.e. without a python dependency) by running the [install.sh](scripts/install.sh) found in the `scrips/` directory of this repository. This script will copy the scripts from the git repo to the `/usr/local/bin` and the libraries to `/usr/local/<directory-name>` paths.
-
-The python package (and the scripts) can be installed by installing the pip package. The [setup.py](setup.py) is configured to copy the bash scripts to the same place as the `install.sh`. It will also install a python module which hosts a function. Once installed, the module can be imported and the function can be run. The function in turn calls the installed bash scripts.
-
-**NOTE**: If using conda, the bin path will automagically change to a conda env path. As such the paths of the installed scripts may differ depending on whether one used the install.sh or the pip install method.
-
-# Usage
-Once installed, simply navigate the current working directory to be inside a git repository and run the bash script or call the python function to determine the version number for that repository.
-
-# TODO
-- repo-flag: add a flag to allow inspecting repositories by specifying a path rather than manipulating the CWD.
+Metadata-Version: 2.1
+Name: tbd-calver-versioning
+Version: 2024.5.24.2
+Summary: A set of tools to manage a code repository using trunk based development and CalVer.
+Home-page: https://github.com/taylor-schneider/tbd-calver-versioning
+Author: tschneider
+Author-email: tschneider@live.com
+Classifier: Programming Language :: Unix Shell
+Classifier: Programming Language :: Python :: 3
+Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
+Classifier: Operating System :: OS Independent
+Description-Content-Type: text/markdown
+Requires-Dist: ShellUtilities ==2.1.11
+
+# Overview
+
+This repository contains several useful components:
+1. A [BASH script](src/bash/bin/determine_tbd_calver_version_number.sh) which determines the version number of a git repository
+2. A [python module](src/python/tbd_calver_versioning.py) which contains a function which calls the BASH script and then produces a PEP440 compliant version number.
+3. Scripts to [install](scripts/install.sh)/[uninstall](scripts/uninstall.sh) the BASH script, and accompanying libraries, to `/usr/local/bin`
+4. A [setup.py](setup.py) allowing this project to be installed as a pip package
+5. A [pyproject.toml](pyproject.toml) which will install prerequisite packages (ShellUtilities) before running the setup.py.
+6. An [example Setup.py](tests/dummy_files/setup.py) and [example pyproject.toml](tests/dummy_files/pyproject.toml) showing how a function in this python library can be called to version a package automatically as part of another project's setup.py.
+
+
+# Versioning
+
+The version number follows the [CalVer](https://calver.org/) versioning scheme. Each version consists of 5 parts:
+- **Major** - Year of the commit
+- **Minor** - Month of the commit
+- **Micro** - Day of the commit
+- **Modifier** - Branch and either commit hash or build number
+
+The version number will thus be as follows:
+
+```
+<year>.<month>.<day>.<branch_type>.<commit_hash_or_build_number>
+```
+
+**Note**: For the PEP440 standard compliance, the python function will return a version number as follows (notice the '+'):
+
+```
+<year>.<month>.<day>+<branch_type>.<commit_hash_or_build_number>
+```
+
+The logic to construct the version number assumes the repository is following the Trunk Based Development branching strategy:
+
+```
+Branch Type                                  Branch Flow
+==================================================================
+
+release/*                          -------------          ----------
+                                 /   \       /          /      / 
+patch/*                         /      -----           /      /
+                               /             \        /      /
+master                    --------------------------------------------
+(aka. main, integration)     \ \                 /\          /
+                              \ \               /  \        /
+feature/*                      \  --------------    \      /
+                                \                    \    /
+bug/*                             ------------------------
+
+```
+
+Each commit in the branch flow will be given a version number based on the CalVer versioning strategy.
+
+Integration branches like master and release will use a build number for the suffix. Non-integration branches which can occur in parallel will use the first 7 digits of the commit hash as the suffix.
+
+Examples include:
+- 2023.05.23.master.1
+- 2022.12.01.feature.f3b24e1
+
+### Note On Merging
+When merging a non-integration branch into an integration branch we must ensure that there is a merge commit. If we allow the branch to simply fast forward, the logic for determining the version number cannot work. This is because a "branch" is simply a version history and if the version histories are identical between two branches, then our logic breaks. To fix this, use the --no-ff to force a merge commit. For example, if merging main up into a release branch, us the --no-ff to ensure a new merge commit is created on the release and guarantee the release number will be incremented properly.
+
+## Requirements
+- BASH >= 4.2
+- git >= 1.8
+
+## Installation
+There are two options for installing the utilities in this repository:
+- bash scripts only (no python dependency)
+- python module and bash scipts
+
+The bash scripts can be installed by themselves (i.e. without a python dependency) by running the [install.sh](scripts/install.sh) found in the `scrips/` directory of this repository. This script will copy the scripts from the git repo to the `/usr/local/bin` and the libraries to `/usr/local/<directory-name>` paths.
+
+The python package (and the scripts) can be installed by installing the pip package. The [setup.py](setup.py) is configured to copy the bash scripts to the same place as the `install.sh`. It will also install a python module which hosts a function. Once installed, the module can be imported and the function can be run. The function in turn calls the installed bash scripts.
+
+**NOTE**: If using conda, the bin path will automagically change to a conda env path. As such the paths of the installed scripts may differ depending on whether one used the install.sh or the pip install method.
+
+# Usage
+Once installed, simply navigate the current working directory to be inside a git repository and run the bash script or call the python function to determine the version number for that repository.
+
+# TODO
+- repo-flag: add a flag to allow inspecting repositories by specifying a path rather than manipulating the CWD.
```

## Comparing `tbd_calver_versioning-2024.5.13.1.dist-info/RECORD` & `tbd_calver_versioning-2024.5.24.2.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,16 +1,16 @@
-tbd_calver_versioning.py,sha256=C4NtL_sMggNtaMv8iMMdyrwHVhLp2Ej4_zdKQHhp_r8,5765
-tbd_calver_versioning-2024.5.13.1.data/data/bin/README.md,sha256=8LNjNbbD-niwzpN06UaF5mRaHRnyVtND2NCARBGD24s,298
-tbd_calver_versioning-2024.5.13.1.data/data/bin/determine_tbd_calver_version_number.sh,sha256=GfbWtGutGsD64qfKW2Eih9J0u7kCy9NLxjPn859uc8w,6364
-tbd_calver_versioning-2024.5.13.1.data/data/bin/tag_repo_with_version_number.sh,sha256=0Vqq-vGxGKbM4haP2IIy4k0xK3RA2N4trui_hbuBPQU,496
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/README.md,sha256=IwDUvYQypE_3dzR5FiXHdVClEMBfD-cDsBOxPfS5qIA,336
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/checkout_git_repo_properly.sh,sha256=6D144rNiSoGNiDU-OMiCBjeRSzRYXwz0P7i5J2kuKCo,1455
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/configure_credential_helper.sh,sha256=efZ1_g0lkTL7w3LrFT6d-z348en4of5ziAe1uQIWJ90,1829
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_commit_where_branch_created.sh,sha256=31Ud1euRY5pBWcVxq-SiYglMEveRHKSm3PIlqo3w4e4,1169
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh,sha256=E9_SjckN_c92EpHXVl8fIGCsFGyIXf8wVeNrevF8spQ,3397
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/determine_if_commit_is_merge_commit.sh,sha256=ZhfjzsLf9Dd1rOAZ7_WFrsrz_ROoohDMsHJZPG1VCbY,533
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_on_branch.sh,sha256=B1l3kT4AeKazvFpNsSWdxeYAoYlf7F1lmTPXSD8tuxQ,1417
-tbd_calver_versioning-2024.5.13.1.data/data/repo_inspection/get_changed_files_since_commit.sh,sha256=l6nA6lBns26RLz2ZN1QfWEgKNfeltyn5L7WUs6k_z-E,595
-tbd_calver_versioning-2024.5.13.1.dist-info/METADATA,sha256=u-sKEH74lKHgxcaa1Xju7hO7V2DAD5ln-oKOS9Wyio0,5593
-tbd_calver_versioning-2024.5.13.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-tbd_calver_versioning-2024.5.13.1.dist-info/top_level.txt,sha256=uD3scoDXjDgk_uJrmSo2HvaDYNBNlc6ao6_W4NS1lQM,22
-tbd_calver_versioning-2024.5.13.1.dist-info/RECORD,,
+tbd_calver_versioning.py,sha256=JJKTJbPWdXntHLC5KqV1oc36aoltjuq-dZsSy-Bisok,5635
+tbd_calver_versioning-2024.5.24.2.data/data/bin/README.md,sha256=0g5mx6Zqidw_lLlqF9vCL1SPDpCrjpu3-HuNyqTNH4A,292
+tbd_calver_versioning-2024.5.24.2.data/data/bin/determine_tbd_calver_version_number.sh,sha256=xYitPMKPcmmGzbc70JOP1hJ5gurN8W_fu-KLUHTz1_k,6218
+tbd_calver_versioning-2024.5.24.2.data/data/bin/tag_repo_with_version_number.sh,sha256=dVTmDWmKyQI1YtXhdYC9aPDfZEI5TbyNFqo1z2w1cLM,469
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/README.md,sha256=de1d6heAP3iAqKzfYjkBZg-JnWxKYdOaahNaFWGdMVM,326
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/checkout_git_repo_properly.sh,sha256=wkF_WlhkYeKHbi29uoYkDUIU6_bP-ZhdY2n1DrMZjqo,1404
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/configure_credential_helper.sh,sha256=CHs1GBqSMl4mvD3N8rCy_fwJ_BdpTR97mW2dJPdtijE,1773
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_commit_where_branch_created.sh,sha256=0YMZ6pG3mf0xqNTBT1jNFWNdSMoLMY7CJAhxiuCeZlM,1134
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_changed_files_match_triggers.sh,sha256=Mm97ETydK8sm4w9pvpNOwMeyb6ldV7ksSEB8LAwYQIY,3297
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/determine_if_commit_is_merge_commit.sh,sha256=04zlIGl2rle4W0YPnCcgO7rGnY-ZM2jG1Z176dN4yEU,511
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_on_branch.sh,sha256=Hc1H0--l9y8jhgPmVA_x4sQ_74d1UyO8BYCYdLbf3Mw,1379
+tbd_calver_versioning-2024.5.24.2.data/data/repo_inspection/get_changed_files_since_commit.sh,sha256=DJvlu9JDH7ztK4WPl6F5Kj809l3MFLSviHdndXkGjgg,576
+tbd_calver_versioning-2024.5.24.2.dist-info/METADATA,sha256=QvTU8ZF7oUec_e1Y7RrAzKrpPVD92CVE1kkuLL__QxA,5498
+tbd_calver_versioning-2024.5.24.2.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+tbd_calver_versioning-2024.5.24.2.dist-info/top_level.txt,sha256=uD3scoDXjDgk_uJrmSo2HvaDYNBNlc6ao6_W4NS1lQM,22
+tbd_calver_versioning-2024.5.24.2.dist-info/RECORD,,
```

