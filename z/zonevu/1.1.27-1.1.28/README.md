# Comparing `tmp/zonevu-1.1.27-py3-none-any.whl.zip` & `tmp/zonevu-1.1.28-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,8 +1,9 @@
-Zip file size: 191444 bytes, number of entries: 136
+Zip file size: 194203 bytes, number of entries: 137
+-rw-r--r--  2.0 fat      499 b- defN 80-Jan-01 00:00 CHANGELOG.md
 -rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 zonevu/__init__.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/__init__.py
 -rw-r--r--  2.0 fat     1971 b- defN 80-Jan-01 00:00 zonevu/DataModels/Company.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Completions/__init__.py
 -rw-r--r--  2.0 fat     1544 b- defN 80-Jan-01 00:00 zonevu/DataModels/Completions/DepthFeature.py
 -rw-r--r--  2.0 fat     3043 b- defN 80-Jan-01 00:00 zonevu/DataModels/Completions/Frac.py
 -rw-r--r--  2.0 fat     1420 b- defN 80-Jan-01 00:00 zonevu/DataModels/Completions/FracEntry.py
@@ -21,22 +22,22 @@
 -rw-r--r--  2.0 fat     2875 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geospatial/Crs.py
 -rw-r--r--  2.0 fat     1101 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geospatial/Enums.py
 -rw-r--r--  2.0 fat     2504 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geospatial/GeoBox.py
 -rw-r--r--  2.0 fat     2955 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geospatial/GeoLocation.py
 -rw-r--r--  2.0 fat     1317 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geospatial/GridCorner.py
 -rw-r--r--  2.0 fat     4154 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geospatial/GridGeometry.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/__init__.py
--rw-r--r--  2.0 fat    12985 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Blocks.py
--rw-r--r--  2.0 fat    10466 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Calcs.py
+-rw-r--r--  2.0 fat    10411 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Blocks.py
+-rw-r--r--  2.0 fat    16927 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Calcs.py
 -rw-r--r--  2.0 fat     2368 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Conditioning.py
--rw-r--r--  2.0 fat     1537 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/CurveDef.py
+-rw-r--r--  2.0 fat     2536 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/CurveDef.py
 -rw-r--r--  2.0 fat     2939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Fault.py
 -rw-r--r--  2.0 fat     2500 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Horizon.py
--rw-r--r--  2.0 fat     3041 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Interpretation.py
--rw-r--r--  2.0 fat     3264 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Pick.py
+-rw-r--r--  2.0 fat     3502 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Interpretation.py
+-rw-r--r--  2.0 fat     4251 b- defN 80-Jan-01 00:00 zonevu/DataModels/Geosteering/Pick.py
 -rw-r--r--  2.0 fat     2377 b- defN 80-Jan-01 00:00 zonevu/DataModels/Helpers.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Map/__init__.py
 -rw-r--r--  2.0 fat     4018 b- defN 80-Jan-01 00:00 zonevu/DataModels/Map/UserLayer.py
 -rw-r--r--  2.0 fat     4786 b- defN 80-Jan-01 00:00 zonevu/DataModels/PrimaryDataObject.py
 -rw-r--r--  2.0 fat     5794 b- defN 80-Jan-01 00:00 zonevu/DataModels/Project.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Seismic/__init__.py
 -rw-r--r--  2.0 fat     4419 b- defN 80-Jan-01 00:00 zonevu/DataModels/Seismic/SeismicInfo.py
@@ -46,15 +47,15 @@
 -rw-r--r--  2.0 fat     3026 b- defN 80-Jan-01 00:00 zonevu/DataModels/Strat/StratColumn.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Styles/__init__.py
 -rw-r--r--  2.0 fat     1859 b- defN 80-Jan-01 00:00 zonevu/DataModels/Styles/Colors.py
 -rw-r--r--  2.0 fat     1726 b- defN 80-Jan-01 00:00 zonevu/DataModels/Styles/FillStyle.py
 -rw-r--r--  2.0 fat     1717 b- defN 80-Jan-01 00:00 zonevu/DataModels/Styles/LineStyle.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/__init__.py
 -rw-r--r--  2.0 fat     4547 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Curve.py
--rw-r--r--  2.0 fat     2003 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/CurveGroup.py
+-rw-r--r--  2.0 fat     2179 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/CurveGroup.py
 -rw-r--r--  2.0 fat     1609 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Note.py
 -rw-r--r--  2.0 fat     1144 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/NoteCategory.py
 -rw-r--r--  2.0 fat     2126 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Station.py
 -rw-r--r--  2.0 fat     4109 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Survey.py
 -rw-r--r--  2.0 fat    11225 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Well.py
 -rw-r--r--  2.0 fat     4668 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Wellbore.py
 -rw-r--r--  2.0 fat     3356 b- defN 80-Jan-01 00:00 zonevu/DataModels/Wells/Welllog.py
@@ -75,23 +76,23 @@
 -rw-r--r--  2.0 fat     2657 b- defN 80-Jan-01 00:00 zonevu/Examples/DataMgmt/DeleteProjectWells.py
 -rw-r--r--  2.0 fat     1456 b- defN 80-Jan-01 00:00 zonevu/Examples/DataMgmt/DeleteWell.py
 -rw-r--r--  2.0 fat     3154 b- defN 80-Jan-01 00:00 zonevu/Examples/DataMgmt/GeomodelSample.py
 -rw-r--r--  2.0 fat     3228 b- defN 80-Jan-01 00:00 zonevu/Examples/DataMgmt/ModifyFrac.py
 -rw-r--r--  2.0 fat     2263 b- defN 80-Jan-01 00:00 zonevu/Examples/DataMgmt/ProjectCopy.py
 -rw-r--r--  2.0 fat     2197 b- defN 80-Jan-01 00:00 zonevu/Examples/DataMgmt/UploadWellDoc.py
 -rw-r--r--  2.0 fat      931 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/__init__.py
--rw-r--r--  2.0 fat     4274 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/EvenlySpaced.py
+-rw-r--r--  2.0 fat     4432 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/EvenlySpaced.py
 -rw-r--r--  2.0 fat     2534 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/ListGeosteering.py
--rw-r--r--  2.0 fat     3327 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/PrintBlocks.py
+-rw-r--r--  2.0 fat     3619 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/PrintBlocks.py
 -rw-r--r--  2.0 fat     3933 b- defN 80-Jan-01 00:00 zonevu/Examples/Geosteering/PrintPicks.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/Examples/Plot/__init__.py
 -rw-r--r--  2.0 fat     6738 b- defN 80-Jan-01 00:00 zonevu/Examples/Plot/CrossSection.py
--rw-r--r--  2.0 fat     6399 b- defN 80-Jan-01 00:00 zonevu/Examples/Plot/CrossSection2.py
+-rw-r--r--  2.0 fat     6615 b- defN 80-Jan-01 00:00 zonevu/Examples/Plot/CrossSection2.py
 -rw-r--r--  2.0 fat      939 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/__init__.py
--rw-r--r--  2.0 fat     2773 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/BulkWellRetrieval.py
+-rw-r--r--  2.0 fat     4209 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/BulkWellRetrieval.py
 -rw-r--r--  2.0 fat     2130 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/DownloadDoc.py
 -rw-r--r--  2.0 fat     1855 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/GetSeismicInfo.py
 -rw-r--r--  2.0 fat     2128 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/ListFracs.py
 -rw-r--r--  2.0 fat     1885 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/ListGeomodels.py
 -rw-r--r--  2.0 fat     1963 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/ListProjects.py
 -rw-r--r--  2.0 fat     1868 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/ListSeismic.py
 -rw-r--r--  2.0 fat     1588 b- defN 80-Jan-01 00:00 zonevu/Examples/Retrieval/ListStratColumns.py
@@ -114,25 +115,25 @@
 -rw-r--r--  2.0 fat     2388 b- defN 80-Jan-01 00:00 zonevu/Services/CompanyService.py
 -rw-r--r--  2.0 fat     4414 b- defN 80-Jan-01 00:00 zonevu/Services/CompletionsService.py
 -rw-r--r--  2.0 fat     7802 b- defN 80-Jan-01 00:00 zonevu/Services/CoordinatesService.py
 -rw-r--r--  2.0 fat     5021 b- defN 80-Jan-01 00:00 zonevu/Services/DocumentService.py
 -rw-r--r--  2.0 fat     3301 b- defN 80-Jan-01 00:00 zonevu/Services/EndPoint.py
 -rw-r--r--  2.0 fat     1973 b- defN 80-Jan-01 00:00 zonevu/Services/Error.py
 -rw-r--r--  2.0 fat     8353 b- defN 80-Jan-01 00:00 zonevu/Services/GeomodelService.py
--rw-r--r--  2.0 fat     5161 b- defN 80-Jan-01 00:00 zonevu/Services/GeosteeringService.py
+-rw-r--r--  2.0 fat     5412 b- defN 80-Jan-01 00:00 zonevu/Services/GeosteeringService.py
 -rw-r--r--  2.0 fat     2893 b- defN 80-Jan-01 00:00 zonevu/Services/MapService.py
 -rw-r--r--  2.0 fat     2534 b- defN 80-Jan-01 00:00 zonevu/Services/NoteService.py
 -rw-r--r--  2.0 fat     7155 b- defN 80-Jan-01 00:00 zonevu/Services/ProjectService.py
 -rw-r--r--  2.0 fat     5996 b- defN 80-Jan-01 00:00 zonevu/Services/SeismicService.py
 -rw-r--r--  2.0 fat    11301 b- defN 80-Jan-01 00:00 zonevu/Services/Storage.py
 -rw-r--r--  2.0 fat     2535 b- defN 80-Jan-01 00:00 zonevu/Services/StratService.py
 -rw-r--r--  2.0 fat     3296 b- defN 80-Jan-01 00:00 zonevu/Services/SurveyService.py
 -rw-r--r--  2.0 fat     3959 b- defN 80-Jan-01 00:00 zonevu/Services/Utils.py
 -rw-r--r--  2.0 fat     2736 b- defN 80-Jan-01 00:00 zonevu/Services/WellData.py
--rw-r--r--  2.0 fat     4842 b- defN 80-Jan-01 00:00 zonevu/Services/WelllogService.py
--rw-r--r--  2.0 fat    15131 b- defN 80-Jan-01 00:00 zonevu/Services/WellService.py
+-rw-r--r--  2.0 fat     5421 b- defN 80-Jan-01 00:00 zonevu/Services/WelllogService.py
+-rw-r--r--  2.0 fat    15173 b- defN 80-Jan-01 00:00 zonevu/Services/WellService.py
 -rw-r--r--  2.0 fat     2947 b- defN 80-Jan-01 00:00 zonevu/Services/WelltopService.py
 -rw-r--r--  2.0 fat     7308 b- defN 80-Jan-01 00:00 zonevu/Zonevu.py
--rw-r--r--  2.0 fat     1146 b- defN 80-Jan-01 00:00 zonevu-1.1.27.dist-info/METADATA
--rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 zonevu-1.1.27.dist-info/WHEEL
-?rw-r--r--  2.0 fat    12654 b- defN 16-Jan-01 00:00 zonevu-1.1.27.dist-info/RECORD
-136 files, 435244 bytes uncompressed, 171140 bytes compressed:  60.7%
+-rw-r--r--  2.0 fat     1146 b- defN 80-Jan-01 00:00 zonevu-1.1.28.dist-info/METADATA
+-rw-r--r--  2.0 fat       88 b- defN 80-Jan-01 00:00 zonevu-1.1.28.dist-info/WHEEL
+?rw-r--r--  2.0 fat    12722 b- defN 16-Jan-01 00:00 zonevu-1.1.28.dist-info/RECORD
+137 files, 445295 bytes uncompressed, 173799 bytes compressed:  61.0%
```

## zipnote {}

```diff
@@ -1,7 +1,10 @@
+Filename: CHANGELOG.md
+Comment: 
+
 Filename: zonevu/__init__.py
 Comment: 
 
 Filename: zonevu/DataModels/__init__.py
 Comment: 
 
 Filename: zonevu/DataModels/Company.py
@@ -393,17 +396,17 @@
 
 Filename: zonevu/Services/WelltopService.py
 Comment: 
 
 Filename: zonevu/Zonevu.py
 Comment: 
 
-Filename: zonevu-1.1.27.dist-info/METADATA
+Filename: zonevu-1.1.28.dist-info/METADATA
 Comment: 
 
-Filename: zonevu-1.1.27.dist-info/WHEEL
+Filename: zonevu-1.1.28.dist-info/WHEEL
 Comment: 
 
-Filename: zonevu-1.1.27.dist-info/RECORD
+Filename: zonevu-1.1.28.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## zonevu/DataModels/Geosteering/Blocks.py

```diff
@@ -27,43 +27,32 @@
 import numpy as np
 from itertools import groupby
 from abc import ABC, abstractmethod
 
 
 @dataclass
 class GeosteerItem(ABC):
+    next_item: Optional['GeosteerItem']
+
     @property
     @abstractmethod
     def kind(self) -> str:
         pass
 
     @property
-    @abstractmethod
+    # @abstractmethod
     def next(self) -> 'GeosteerItem':
-        pass
+        return self.next_item
 
-
-class GeosteerIter:
-    """
-    Iterator to easily iterate through the block and faults in MD order of a geosteering interpretation.
-    """
-    def __init__(self, interp: Interpretation):
-        blocks, faults = make_blocks_and_faults(interp)
-        self._item = blocks[0]
-
-    def __iter__(self):
-        return self
-
-    def __next__(self):
-        if self._item.next is None:
-            raise StopIteration
-        else:
-            item = self._item
-            self._item = self._item.next
-            return item
+    def find_next_block(self) -> Union['Block', None]:
+        item = self
+        while True:
+            item = item.next
+            if item is None or isinstance(item, Block):
+                return item
 
 
 @dataclass
 class Layer:
     """
     A layer in a geosteering block corresponding to a horizon in a geosteering interpretation
     """
@@ -98,25 +87,29 @@
     NOTE: start = the heel-ward direction, and end = the toe-ward direction
     NOTE: in the interpretation, each block is followed by either a block or a fault.
     """
     start_pick: Pick
     end_pick: Pick
     layers: List[Layer] = field(default_factory=list[Layer])
     target_layer: Optional[Layer] = None
-    next_block: Optional['Block'] = None
-    next_fault: Optional['Fault'] = None
+    # next_block: Optional['Block'] = None  # Either 'next_block' or 'next_fault' will not be None
+    # next_fault: Optional['Fault'] = None
 
     @property
     def kind(self) -> str:
         return 'Block'
 
-    @property
-    def next(self) -> 'GeosteerItem':
-        next_item = self.next_fault if self.next_block is None else self.next_block
-        return next_item
+    # @property
+    # def next(self) -> 'GeosteerItem':
+    #     """
+    #     Return next block (while skipping over any faults) after this block
+    #     :return:
+    #     """
+    #     next_item = self.next_fault if self.next_block is None else self.next_block
+    #     return next_item
 
     @property
     def md_start(self) -> float:
         return self.start_pick.md
 
     @property
     def md_end(self) -> float:
@@ -153,15 +146,15 @@
         :return:
         """
         return self.end_pick.target_elevation
 
     @property
     def dip(self) -> float:
         """
-        Get dip of block in direction of increasing MD
+        Get geologic dip of block in direction of increasing MD
         :return:
         """
         c1 = self.xyz_start.vector
         c2 = self.xyz_end.vector
         v: Vector3 = c2 - c1  # Vector pointing along top of block
         h = Vector3(v.x, v.y, 0)  # Vector pointing along plane in direction of block
         cos_theta = v.dot(h) / (v.length * h.length)
@@ -174,14 +167,18 @@
             dip_degrees = math.degrees(dip_radians)
             return dip_degrees
         except ValueError as err:
             return np.nan
 
     @property
     def inclination(self) -> float:
+        """
+        This is the "MD dip" - inclination relative to the wellbore inclination
+        :return:
+        """
         dHX = self.end_pick.md - self.start_pick.md
         dTVD = self.end_pick.target_tvd - self.start_pick.target_tvd
         incl = 90 + math.atan2(-dTVD, dHX) * 180 / math.pi
         return incl
 
     @property
     def length(self) -> float:
@@ -195,31 +192,38 @@
         return v.length
 
     @property
     def md_length(self) -> float:
         md_len = self.md_end - self.md_start
         return md_len
 
-    def find_next_block(self) -> Union['Block', None]:
-        next_item = self.next
-        if next_item is None:
-            return None
-        next_next_item = next_item.next
-        if isinstance(next_item, Block):
-            return next_item
-        elif isinstance(next_next_item, Block):
-            return next_next_item
-        else:
-            return None
-
     def contains_md(self, md: float):
         if self.md_start <= md < self.md_end:
             return True
         return False
 
+    def make_copy(self) -> 'Block':
+        block_copy = Block(next_item=None, start_pick=self.start_pick, end_pick=self.end_pick)
+        for L in self.layers:
+            l_copy = Layer(block=block_copy, tvd_start=L.tvd_start, tvd_end=L.tvd_end, horz=L.horz,
+                           thickness=L.thickness)
+            block_copy.layers.append(l_copy)
+        return block_copy
+
+    @classmethod
+    def make_infill_block(cls, b1: 'Block', b2: 'Block') -> 'Block':
+        b = Block(next_item=None, start_pick=b1.end_pick, end_pick=b2.start_pick)
+        for l1, l2 in zip(b1.layers, b2.layers):
+            infill_layer = Layer(block=b, tvd_start=l1.tvd_end, tvd_end=l2.tvd_start, horz=l1.horz,
+                                 thickness=(l2.tvd_start - l1.tvd_end))
+            b.layers.append(infill_layer)
+            if b1.target_layer is not None and infill_layer.horz == b1.target_layer.horz:
+                b.target_layer = infill_layer
+        return b
+
     def make_pick(self, md: float) -> Pick:
         p1 = self.start_pick
         p2 = self.end_pick
         m = (md - p1.md) / (p2.md - p1.md)
 
         def lerp(a, b):
             return a + (b - a) * m
@@ -253,33 +257,29 @@
     @property
     def line(self) -> LineString:
         line = LineString([(self.fault.md, self.tvd_start), (self.fault.md, self.tvd_end)])
         return line
 
 
 @dataclass
-class Fault:
+class Fault(GeosteerItem):
     """
     A geosteering fault derived from a pair of geosteering interpretation picks
     NOTE: in the interpretation, each fault is followed by a block.
     """
     pick: Pick
     throws: List[Throw] = field(default_factory=list[Throw])
     target_throw: Optional[Throw] = None
-    next_block: Optional[Block] = None
+    # next_block: Optional[Block] = None
 
     @property
     def kind(self) -> str:
         return 'Fault'
 
     @property
-    def next(self) -> 'GeosteerItem':
-        return self.next_block
-
-    @property
     def md(self) -> float:
         return self.pick.md
 
     @property
     def location(self) -> GeoLocation:
         return GeoLocation(self.pick.latitude, self.pick.longitude)
 
@@ -297,72 +297,14 @@
         :return:
         """
         return self.pick.target_elevation
 
     @property
     def trace(self) -> LineString:
         pts = [(self.md, min(t.tvd_start, t.tvd_end)) for t in self.throws]
-        last_t = self.throws[-1]
-        max_tvd = max(last_t.tvd_start, last_t.tvd_end)
-        pts.append((self.md, max_tvd))
+        if len(self.throws) > 0:
+            last_t = self.throws[-1]
+            max_tvd = max(last_t.tvd_start, last_t.tvd_end)
+            pts.append((self.md, max_tvd))
         return LineString(pts)
 
 
-def make_blocks_and_faults(interp: Interpretation) -> Tuple[List[Block], List[Fault]]:
-    """
-    Computes the blocks and faults for a geosteering interpretation
-    :param interp: A geosteering interpretation
-    :return: a list of geosteering blocks and faults
-    """
-    # Make a list of layer thicknesses for each employed typewell
-    interp.typewell_horizon_depths.sort(key=lambda d: d.type_wellbore_id)  # Make sure horz depths in type well order
-    target_formation = interp.target_formation_id
-    type_well_groups = groupby(interp.typewell_horizon_depths, key=lambda d: d.type_wellbore_id)  # Group by type well
-    type_well_depth_dict = {key: list(group) for key, group in type_well_groups}  # Make depth list LUT by type well id
-    for wellbore_id, h_depths in type_well_depth_dict.items():
-        h_depths.sort(key=lambda h_depth: h_depth.tvt)  # Make sure lists are in TVT order
-
-    # Create a list of geosteering blocks
-    horizons_dict = {h.id: h for h in interp.horizons}  # Make a horizon lookup dictionary
-    picks = interp.picks
-    blocks: List[Block] = []
-    faults: List[Fault] = []
-
-    p1 = picks[0]
-    last_block_or_fault: Union[Block, Fault, None] = None
-    for p2 in picks[1:]:
-        h_depths = type_well_depth_dict[p1.type_wellbore_id]  # Get type well horizon depths for this pick
-        depth_pairs = zip(h_depths, h_depths[1:])
-        if p1.block_flag:   # Create block
-            block = Block(p1, p2)
-            blocks.append(block)
-            if last_block_or_fault is not None:
-                last_block_or_fault.next_block = block
-            last_block_or_fault = block
-            for d, d2 in depth_pairs:
-                tvd1 = p1.target_tvd + d.tvt  # Compute geometry of the layer for this horizon pair
-                tvd2 = p2.target_tvd + d.tvt
-                thickness = d2.tvt - d.tvt
-                horizon = horizons_dict[d.horizon_id]  # Find horizon for this type well depth
-                layer = Layer(block, horizon, tvd1, tvd2, thickness)
-                block.layers.append(layer)  # Create layer and add to block for this pick
-                if horizon.formation_id == target_formation:
-                    block.target_layer = layer
-        elif p1.fault_flag:  # Create fault
-            fault = Fault(p1)
-            faults.append(fault)
-            if last_block_or_fault is not None:
-                last_block_or_fault.next_fault = fault
-            last_block_or_fault = fault
-            for d in h_depths:
-                tvd1 = p1.target_tvd + d.tvt  # Compute geometry of the layer for this horizon pair
-                tvd2 = p2.target_tvd + d.tvt
-                throw_amt = tvd2 - tvd1
-                if math.fabs(throw_amt) > 0:
-                    horizon = horizons_dict[d.horizon_id]  # Find horizon for this type well depth
-                    throw = Throw(fault, horizon, tvd1, tvd2, throw_amt)
-                    fault.throws.append(throw)  # Create fault throw and add to block for this pick
-                    if horizon.formation_id == target_formation:
-                        fault.target_throw = throw
-        p1 = p2
-
-    return blocks, faults
```

## zonevu/DataModels/Geosteering/Calcs.py

```diff
@@ -16,27 +16,29 @@
 #
 #
 
 from dataclasses import dataclass, field
 from ...DataModels.Geosteering.Horizon import TypewellHorizonDepth, Horizon
 from ...DataModels.Geosteering.Pick import Pick
 from ...DataModels.Geosteering.Interpretation import Interpretation
+from ...DataModels.Geosteering.CurveDef import CurveDef
 from ...DataModels.Wells.Station import Station
 from ...DataModels.Strat.StratColumn import StratColumn, Formation
 from ...DataModels.Wells.Welllog import Welllog
 from ...DataModels.Wells.Curve import Curve
 from shapely.geometry import LineString
-from typing import List, Optional, Dict
+from typing import List, Optional, Dict, Union, Tuple
 import numpy as np
 from ...DataModels.DataModel import WellElevationUnitsEnum
 from ...Services.Client import UnitsSystemEnum
 from ...Zonevu import Zonevu
 from itertools import groupby
 import math
-from ...DataModels.Geosteering.Blocks import Block, Layer, make_blocks_and_faults
+from ...DataModels.Geosteering.Blocks import Block, Layer, Fault, Throw
+import warnings
 
 """
 Utilities to convert geosteering interpretation into blocks, and to compute percent in zone
 """
 
 
 @dataclass
@@ -97,35 +99,45 @@
         calc.percent = 100 * calc.length / zones_length  # Compute percent in zone for this horizon
     return zone_calc_list
 
 
 def make_evenly_spaced_picks(interp: Interpretation, interval: float, first_md: Optional[float] = None,
                              last_md: Optional[float] = None) -> List[Pick]:
     """
-
+    Converts the actual picks in a geosteering interpretation into evenly spaced picks, with no faults.
     :param interp: A geosteering interpretation
     :param interval: The sample interval in MD for output picks
     :param first_md: Beginning MD for output picks
     :param last_md: Ending MD for output picks
     :return:
+    Note: faults are discarded.
     """
-    blocks, faults = make_blocks_and_faults(interp)
+    blocks = make_contiguous_blocks(interp)
     first_block = blocks[0]
     last_block = blocks[-1]
     first_md = first_block.md_start if first_md is None else first_md
     last_md = last_block.md_end if last_md is None else last_md
     md = first_md
     current_block = first_block
     evenly_spaced_picks: List[Pick] = []
-    while md < last_md:
-        while not current_block.contains_md(md):
-            current_block = current_block.find_next_block()
-        pick = current_block.make_pick(md)
-        evenly_spaced_picks.append(pick)
-        md += interval
+    with warnings.catch_warnings():
+        warnings.filterwarnings('error')
+        while md < last_md:
+            while not current_block.contains_md(md):
+                current_block = current_block.find_next_block()
+                if current_block is None:
+                    break
+            try:
+                pick = current_block.make_pick(md)
+            except RuntimeWarning as e:
+                print('*** Runtime Error at md = %s: %s' % (md, e))
+                pick = current_block.make_pick(md)   # Redo calc to cause error
+            evenly_spaced_picks.append(pick)
+            md += interval
+
     return evenly_spaced_picks
 
 
 def create_extended_picks(interp: Interpretation, strat_col: StratColumn,
                           picks: Optional[List[Pick]] = None) -> List[PickEx]:
     """
     Flattens the data in a geosteering interpretation into a list of extended geosteering picks
@@ -160,14 +172,117 @@
             target_hd.tvt = p.target_tvt - type_hd.tvt
             target_hd.target = interp.target_formation_id == formation.id
             pick_ex.horizon_depths.append(target_hd)
 
     return extended_picks
 
 
+def make_blocks_and_faults(interp: Interpretation, interval: Optional[float] = None) -> Tuple[List[Block], List[Fault]]:
+    """
+    Computes the blocks and faults for a geosteering interpretation
+    :param interp: A geosteering interpretation
+    :param interval: If provided, blocks will be of width 'interval' and no faults will be generated.
+    :return: a list of geosteering blocks and faults
+    """
+    # Make a list of layer thicknesses for each employed typewell
+    interp.typewell_horizon_depths.sort(key=lambda d: d.type_wellbore_id)  # Make sure horz depths in type well order
+    target_formation = interp.target_formation_id
+    type_well_groups = groupby(interp.typewell_horizon_depths, key=lambda d: d.type_wellbore_id)  # Group by type well
+    type_well_depth_dict = {key: list(group) for key, group in type_well_groups}  # Make depth list LUT by type well id
+    for wellbore_id, h_depths in type_well_depth_dict.items():
+        h_depths.sort(key=lambda h_depth: h_depth.tvt)  # Make sure lists are in TVT order
+
+    # Create a list of geosteering blocks
+    horizons_dict = {h.id: h for h in interp.horizons}  # Make a horizon lookup dictionary
+    picks = interp.picks if interval is None else make_evenly_spaced_picks(interp, interval)
+    blocks: List[Block] = []
+    faults: List[Fault] = []
+
+    p1 = picks[0]
+    last_block_or_fault: Union[Block, Fault, None] = None
+    for p2 in picks[1:]:
+        h_depths = type_well_depth_dict[p1.type_wellbore_id]  # Get type well horizon depths for this pick
+        depth_pairs = zip(h_depths, h_depths[1:])
+        if p1.block_flag:   # Create block
+            block = Block(next_item=None, start_pick=p1, end_pick=p2)
+            blocks.append(block)
+            if last_block_or_fault is not None:
+                last_block_or_fault.next_item = block
+            last_block_or_fault = block
+            for d, d2 in depth_pairs:
+                tvd1 = p1.target_tvd + d.tvt  # Compute geometry of the layer for this horizon pair
+                tvd2 = p2.target_tvd + d.tvt
+                thickness = d2.tvt - d.tvt
+                horizon = horizons_dict[d.horizon_id]  # Find horizon for this type well depth
+                layer = Layer(block, horizon, tvd1, tvd2, thickness)
+                block.layers.append(layer)  # Create layer and add to block for this pick
+                if horizon.formation_id == target_formation:
+                    block.target_layer = layer
+        elif p1.fault_flag:  # Create fault
+            fault = Fault(next_item=None, pick=p1)
+            faults.append(fault)
+            if last_block_or_fault is not None:
+                last_block_or_fault.next_item = fault
+            last_block_or_fault = fault
+            for d in h_depths:
+                tvd1 = p1.target_tvd + d.tvt  # Compute geometry of the layer for this horizon pair
+                tvd2 = p2.target_tvd + d.tvt
+                throw_amt = tvd2 - tvd1
+                if math.fabs(throw_amt) > 0:
+                    horizon = horizons_dict[d.horizon_id]  # Find horizon for this type well depth
+                    throw = Throw(fault, horizon, tvd1, tvd2, throw_amt)
+                    fault.throws.append(throw)  # Create fault throw and add to block for this pick
+                    if horizon.formation_id == target_formation:
+                        fault.target_throw = throw
+        p1 = p2
+
+    return blocks, faults
+
+
+def get_block_type_curve_info(interp: Interpretation, block: Block) -> Optional[CurveDef]:
+    """
+    Find information about the type curve used on a geosteering block.
+    :param interp: The geosteering interpretation that this block is from
+    :param block: The block in question
+    :return:
+    """
+    curve_defs = interp.curve_defs  # All the well log curve definitions used in this interpretation
+    pick = block.start_pick  # A block is defined by two geosteering picks. The first pick establishes the type curve.
+    curve_def_id = pick.type_curve_def_id
+    curve_def = next((d for d in curve_defs if d.id == curve_def_id), None)  # Lookup the curve def for this block
+    return curve_def
+
+
+def make_contiguous_blocks(interp: Interpretation) -> List[Block]:
+    """
+    Computes a "blocks only" set of blocks of the interpretation, where blocks are contiguous in MD (any gaps filled).
+    :param interp: a geosteering interpretation
+    :return: a list of geosteering blocks that are contiguous with no faults
+    """
+    blocks, faults = make_blocks_and_faults(interp)
+    just_blocks = [b.make_copy() for b in blocks]  # Make a list of copies of blocks
+    contiguous_blocks: List[Block] = []
+
+    for bb1, bb2 in zip(just_blocks, just_blocks[1:]):
+        b1: Block = bb1
+        b2: Block = bb2
+        b1.next_item = b2
+        contiguous_blocks.append(b1)
+        if b1.md_end < b2.md_start:  # Check for gap and make an infill block if needed
+            infill_block = Block.make_infill_block(b1, b2)
+            b1.next_item = infill_block
+            infill_block.next_item = b2
+            contiguous_blocks.append(infill_block)
+
+    last_block = just_blocks[-1]
+    last_block.next_item = None
+    contiguous_blocks.append(last_block)
+    return contiguous_blocks
+
+
 def create_pseudo_welllog(zonevu: Zonevu, interp: Interpretation, strat_col: StratColumn, interval: float,
                           first_md: Optional[float] = None, last_md: Optional[float] = None) -> Welllog:
     """
     Convert the picks and horizons of a geosteering interpretation into a well log data structure.
     :param zonevu: ZoneVu client instance
     :param interp: A geosteering interpretation
     :param strat_col: The strat column referenced by the geosteering interpretation
@@ -208,7 +323,31 @@
     for h in reference_pick.horizon_depths:
         samples = samples_lut[h.formation.symbol]
         curve = Curve(id=0, name=h.formation.name, description='A pseudo well log curve of a geosteering horizon',
                       mnemonic=h.formation.symbol, unit=well_depth_units, samples=samples)
         log.curves.append(curve)
 
     return log
+
+
+class GeosteerIter:
+    """
+    Iterator to easily iterate through the block and faults in MD order of a geosteering interpretation.
+    """
+    def __init__(self, interp: Interpretation):
+        blocks, faults = make_blocks_and_faults(interp)
+        self._item = blocks[0]
+
+    def __iter__(self):
+        return self
+
+    def __next__(self):
+        if self._item.next is None:
+            raise StopIteration
+        else:
+            item = self._item
+            self._item = self._item.next
+            return item
+
+
+
+
```

## zonevu/DataModels/Geosteering/CurveDef.py

```diff
@@ -19,24 +19,44 @@
 from dataclasses import dataclass, field
 from typing import Optional
 from ..DataModel import DataModel
 from .Conditioning import Conditioning
 from strenum import StrEnum
 
 
+class CurveDefWellboreRoleEnum(StrEnum):
+    TargetWellbore = 'TargetWellbore'
+    TypeWellbore = 'TypeWellbore'
+
+
 class CurveGroupRoleEnum(StrEnum):
     Image = 'Image'
     Litho = 'Litho'
     Splice = 'Splice'
 
 
 @dataclass
 class CurveDef(DataModel):
     """
-    Represents a ZoneVu geosteering curve definition
+    Represents a ZoneVu geosteering curve definition 
     """
+    #: Name of well from which this well log curve comes
+    well_name: Optional[str] = None
+    #: Id of Well from which this well log curve comes
+    well_id: Optional[int] = None
+    #: Id of Wellbore from which this well log curve comes
+    wellbore_id: Optional[int] = None
+    #: Role of wellbore from which this well log curve comes
+    wellbore_role: Optional[CurveDefWellboreRoleEnum] = None
+    #: Id of Well log from which this well log curve comes
+    well_log_id: Optional[int] = None
+    #: Well log curve system id. Note either this or curve_group_id will be populated
     curve_id: Optional[int] = None
+    #: Well log curve group id. Note either this or curve_group_id will be populated
     curve_group_id: Optional[int] = None
+    #: If this def is using a curve group, specifies type of curve def
     role: Optional[CurveGroupRoleEnum] = None
+    #: Whether this curve is the active one in the interpretation workflow
     active: bool = False
+    #: Curve conditioning applied to this curve
     conditioning: Optional[Conditioning] = None
```

## zonevu/DataModels/Geosteering/Interpretation.py

```diff
@@ -11,15 +11,15 @@
 #  PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 #  FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 #  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
 #
 #
 #
-
+import math
 from dataclasses import dataclass, field
 from typing import Optional
 from ..DataModel import DataModel
 from .Pick import Pick
 from .CurveDef import CurveDef
 from .Horizon import Horizon, TypewellHorizonDepth
 from datetime import datetime
@@ -49,21 +49,35 @@
     def copy_ids_from(self, source: DataModel):
         super().copy_ids_from(source)
         if isinstance(source, Interpretation):
             DataModel.merge_lists(self.picks, source.picks)
             DataModel.merge_lists(self.curve_defs, source.curve_defs)
             DataModel.merge_lists(self.horizons, source.horizons)
 
+    @property
+    def valid(self) -> bool:
+        """
+        Check if the picks in the interpretation are valid and in order.
+        :return:
+        """
+        enough_picks = len(self.picks) > 1
+        picks_valid = all(p.valid for p in self.picks)
+        picks_md_increases = all(p1.md <= p2.md for p1, p2 in zip(self.picks, self.picks[1:]))
+        ok = enough_picks and picks_valid and picks_md_increases
+        return ok
+
 
 @dataclass
 class InterpretationEntry(DataModel):
     # Represents a ZoneVu Geosteering interpretation catalog entry Object (lightweight)
     description: Optional[str] = ''
     starred: bool = False
     last_modified_by_name: str = ''
     last_modified_date: Optional[datetime] = MakeIsodateOptionalField()
 
     @property
     def interpretation(self) -> Interpretation:
         return Interpretation(id=self.id, name=self.name, row_version=self.row_version, description=self.description,
                               starred=self.starred)
 
+
+
```

## zonevu/DataModels/Geosteering/Pick.py

```diff
@@ -11,15 +11,15 @@
 #  PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
 #  FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 #  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
 #
 #
 #
-
+import math
 from dataclasses import dataclass, field
 from typing import Optional
 from dataclasses_json import config
 from ..DataModel import DataModel
 
 
 @dataclass
@@ -53,9 +53,28 @@
     elevation: Optional[float] = None
     #: If true, this pick represents the end of the last block and the beginning of the next block.
     block_flag: bool = False
     # If true, this pick represents the end of the last block and a fault throw, and start of the next block.
     fault_flag: bool = False
     #: The system id of the type wellbore
     type_wellbore_id: int = -1
-    #: The system id of the type well log curve
+    #: The system id of the type well log curve def
     type_curve_def_id: Optional[int] = None
+
+    @property
+    def valid(self) -> bool:
+        """
+        Validity check on this pick.
+        :return:
+        """
+        correct_flags = (self.block_flag and not self.fault_flag) or (not self.block_flag and self.fault_flag)
+        md_ok = self.md is not None and math.isfinite(self.md)
+        tvd_ok = self.target_tvd is not None and math.isfinite(self.target_tvd)
+        tvt_ok = self.target_tvt is not None and math.isfinite(self.target_tvt)
+        x_ok = self.x is not None and math.isfinite(self.x)
+        y_ok = self.y is not None and math.isfinite(self.y)
+        lat_ok = self.latitude is not None and math.isfinite(self.latitude)
+        lon_ok = self.longitude is not None and math.isfinite(self.longitude)
+        elev_ok = self.target_elevation is not None and math.isfinite(self.target_elevation)
+        ok = correct_flags and md_ok and tvd_ok and tvt_ok and x_ok and y_ok and lat_ok and lon_ok and elev_ok
+        return ok
+
```

## zonevu/DataModels/Wells/CurveGroup.py

```diff
@@ -12,14 +12,15 @@
 #  FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 #  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #
 #
 
 from typing import Optional, Callable, Dict
 from dataclasses import dataclass, field
+from dataclasses_json import LetterCase, config, DataClassJsonMixin
 from dataclasses_json import config
 from ...DataModels.DataModel import DataModel
 import numpy as np
 from numpy.typing import NDArray
 from strenum import StrEnum
 from pathlib import Path
 import io
@@ -33,15 +34,16 @@
 class CurveGroupRoleEnum(StrEnum):
     Image = "Image"
     Litho = "Litho"
     Splice = "Splice"
 
 
 @dataclass
-class CurveGroupParam:
+class CurveGroupParam(DataClassJsonMixin):
+    dataclass_json_config = config(letter_case=LetterCase.PASCAL)["dataclasses_json"]
     id: int
     curve_id: int
     conditioning: Optional[Conditioning]
 
 
 @dataclass
 class CurveGroup(DataModel):
```

## zonevu/Examples/Geosteering/EvenlySpaced.py

```diff
@@ -24,15 +24,15 @@
 from ...Services.WellService import WellData
 from ...DataModels.Geosteering.Calcs import create_extended_picks
 from ...Services.GeosteeringService import PickAdjustEnum
 from tabulate import tabulate
 from ...DataModels.Geosteering.Calcs import make_evenly_spaced_picks, create_extended_picks, create_pseudo_welllog
 from ...DataModels.Wells.Curve import Curve
 from ...DataModels.Wells.Welllog import Welllog
-from ...DataModels.Geosteering.Blocks import make_blocks_and_faults, Block, Fault
+from ...DataModels.Geosteering.Blocks import Block, Fault
 import numpy as np
 
 
 def main_evenly_spaced(zonevu: Zonevu, well_name: str):
     """
     Retrieve well data from ZoneVu
     For the first geosteering interpretation, create flattened geosteering picks.
@@ -57,24 +57,28 @@
     interp_entries = geosteer_svc.get_interpretations(wellbore.id)
     has_geosteering = len(interp_entries) > 0
     if has_geosteering:
         interp_entry = next((g for g in interp_entries if g.starred),
                             interp_entries[0])  # Get starred or first interpretation
         # Get interpretation with picks interpolated to every 1 ft (or meters)
         interp = geosteer_svc.get_interpretation(interp_entry.id)
-        interval = 1
-        evenly_spaced_picks = make_evenly_spaced_picks(interp=interp, interval=interval, first_md=9000)
+        if not interp.valid:
+            print('Invalid geosteering interpretation')
+            return
+
+        interval = 50
+        evenly_spaced_picks = make_evenly_spaced_picks(interp=interp, interval=interval)
+        # evenly_spaced_picks = make_evenly_spaced_picks(interp=interp, interval=interval, first_md=9000)
 
         # Transform picks into extended picks where each pick has a list of horizon depths.
         evenly_spaced_picks_ex = create_extended_picks(interp, strat_col, evenly_spaced_picks)
         print('%s evenly spaced geosteering picks created with an interval of %s %s' %
               (len(evenly_spaced_picks), 1, zonevu.distance_units))
 
         # Convert the interpretation into a pseudo well log
         # NOTE: each pseudo curve will be one horizon from the geosteering interpretation with its curve mnemonic
         #     set to the formation symbol of that horizon.
         #       The index_curve_id of the well log will be set to the curve index of the target horizon.
-        interval = 1
-        pseudo_welllog = create_pseudo_welllog(zonevu, interp, strat_col, interval)
+        # pseudo_welllog = create_pseudo_welllog(zonevu, interp, strat_col, interval)
 
         print('A pseudo well log of the geosteering interpretation has been created')
         print()
```

## zonevu/Examples/Geosteering/PrintBlocks.py

```diff
@@ -16,18 +16,19 @@
 
 from ...Zonevu import Zonevu
 from ...Services.Client import ZonevuError
 from ...Services.WellService import WellData
 from ...DataModels.Geosteering.Calcs import create_extended_picks
 from tabulate import tabulate
 from typing import Union, List
-from ...DataModels.Geosteering.Blocks import Block, Fault, make_blocks_and_faults, GeosteerIter
+from ...DataModels.Geosteering.Blocks import Block, Fault
+from ...DataModels.Geosteering.Calcs import make_blocks_and_faults, get_block_type_curve_info, GeosteerIter
 
 
-def main_geometry_table(zonevu: Zonevu, well_name: str):
+def print_blocks_table(zonevu: Zonevu, well_name: str):
     """
     Retrieve well data from ZoneVu
     For the first geosteering interpretation, output a table of geosteering blocks and faults
     """
     well_svc = zonevu.well_service
     well = well_svc.get_first_named(well_name)
     if well is None:
@@ -45,22 +46,26 @@
     interps = wellbore.interpretations
     has_geosteering = len(interps) > 0
     if has_geosteering:
         interp = next((g for g in interps if g.starred), interps[0])  # Get starred or first interpretation
         print('Geosteering blocks and faults for interpretation "%s"' % interp.name)
         table = []
         n = 0
-        headers = ['N', 'Type', 'MD Start', 'MD End', 'MDLength', 'TVD Start', 'TVD End', 'Throw', 'Inclination']
+        headers = ['N', 'Type', 'MD Start', 'MD End', 'MDLength', 'TVD Start', 'TVD End', 'Throw',
+                   'Inclination', 'Type Curve']
         for item in GeosteerIter(interp):
             if isinstance(item, Block):
                 n += 1
                 layer = item.target_layer
                 inclination = item.inclination
+                type_curve = get_block_type_curve_info(interp, item)
+                info = type_curve.name if type_curve is not None else 'Unknown'
                 table.append([n, item.kind, round(item.md_start, 1), round(item.md_end, 1), round(item.md_length, 1),
-                              round(layer.tvd_start, 1), round(layer.tvd_end, 1), '', round(inclination, 3)])
+                              round(layer.tvd_start, 1), round(layer.tvd_end, 1), '',
+                              round(inclination, 3), info])
             elif isinstance(item, Fault):
                 throw = item.target_throw
                 table.append([n, item.kind, round(item.md), '', '', round(throw.tvd_start),
                               round(throw.tvd_end), round(throw.throw_amt, 1), ''])
         print(tabulate(table, headers=headers, tablefmt='plain'))
```

## zonevu/Examples/Plot/CrossSection2.py

```diff
@@ -20,16 +20,16 @@
 from ...Zonevu import Zonevu
 from ...Services.Client import ZonevuError
 from ...Services.WellService import WellData
 from matplotlib import pyplot as plt
 from shapely.ops import unary_union
 from shapely.geometry import Polygon
 from ...DataModels.Styles.Colors import RgbType
-from ...DataModels.Geosteering.Blocks import make_blocks_and_faults, Block, Fault
-from ...DataModels.Geosteering.Calcs import calc_percent_in_zone
+from ...DataModels.Geosteering.Blocks import Block, Fault
+from ...DataModels.Geosteering.Calcs import make_blocks_and_faults
 
 
 def main_cross_section(zonevu: Zonevu, well_name: str):
     """
     Retrieve well data from ZoneVu and plot a cross-section
     that includes the first geosteering interpretation
     NOTE: this version converts the interpretation picks into blocks, and plots those.
@@ -78,55 +78,58 @@
 
     # If available, plot the starred or first geosteering interpretation
     geosteering_data = wellbore.interpretations
     plot_geosteering = len(geosteering_data) > 0
     if plot_geosteering:
         interp = next((g for g in geosteering_data if g.starred), geosteering_data[0])  # Get starred or first interpretation
         zonevu.geosteering_service.load_interpretation(interp)      # Load picks into interpretation
-        showing_horizons = [h for h in interp.horizons if h.show]   # Find visible horizons
-        target_horizon = next((h for h in showing_horizons if h.formation_id == interp.target_formation_id), None)
-
-        blocks, faults = make_blocks_and_faults(interp)
-
-        plot_end_md = max(plot_end_md, *[p.md for p in interp.picks])
-        plot_min_tvd = 100000000
-        plot_max_tvd = -10000000
-
-        # Plot blocks and faults
-        for block in blocks:
-            for layer in block.layers:
-                (p_minx, p_miny, p_maxx, p_maxy) = layer.polygon.bounds
-                plot_min_tvd = min(plot_min_tvd, p_miny)
-                plot_max_tvd = max(plot_max_tvd, p_maxy)
-                x, y = layer.polygon.exterior.xy
-                horz = layer.horz
-                is_target = horz == target_horizon
-                horz_color = horz.line_style.get_color(RgbType.Rgb1)
-                fill_color = horz.fill_style.get_color(RgbType.Rgb1)
-                opacity = horz.fill_style.opacity / 100
-                line_width, line_style, line_color = (2, '--', 'black') if is_target else (1, '-', horz_color)
-                ax.fill(x, y, alpha=opacity, color=fill_color)
-                if is_target:
-                    ax.plot(x, y, color=line_color, linewidth=1, zorder=1, linestyle=line_style)
-
-        for fault in faults:
-            # Plot overall fault trace
-            trace = fault.trace
-            ax.plot(trace.xy[0], trace.xy[1], color='gray', linewidth=1, zorder=2, alpha=1)
-            # Plot fault throws on individual horizons
-            for throw in fault.throws:
-                x = throw.line.xy[0]
-                y = throw.line.xy[1]
-                ax.plot(x, y, color='black', linewidth=2, zorder=2, alpha=1)
-
-        # Choose sensible plot limits for tvd
-        dtvd = plot_max_tvd - plot_min_tvd
-        plot_start_tvd = plot_min_tvd - dtvd / 10
-        plot_end_tvd = plot_max_tvd + dtvd / 10
-        plot_name += ' with Geosteering Interpretation "%s" for Target Formation "%s"' % (interp.name, target_horizon.name)
+        if interp.valid:
+            showing_horizons = [h for h in interp.horizons if h.show]   # Find visible horizons
+            target_horizon = next((h for h in showing_horizons if h.formation_id == interp.target_formation_id), None)
+
+            # interval = None
+            interval = 50
+            blocks, faults = make_blocks_and_faults(interp, interval)
+
+            plot_end_md = max(plot_end_md, *[p.md for p in interp.picks])
+            plot_min_tvd = 100000000
+            plot_max_tvd = -10000000
+
+            # Plot blocks and faults
+            for block in blocks:
+                for layer in block.layers:
+                    (p_minx, p_miny, p_maxx, p_maxy) = layer.polygon.bounds
+                    plot_min_tvd = min(plot_min_tvd, p_miny)
+                    plot_max_tvd = max(plot_max_tvd, p_maxy)
+                    x, y = layer.polygon.exterior.xy
+                    horz = layer.horz
+                    is_target = horz == target_horizon
+                    horz_color = horz.line_style.get_color(RgbType.Rgb1)
+                    fill_color = horz.fill_style.get_color(RgbType.Rgb1)
+                    opacity = horz.fill_style.opacity / 100
+                    line_width, line_style, line_color = (2, '--', 'black') if is_target else (1, '-', horz_color)
+                    ax.fill(x, y, alpha=opacity, color=fill_color)
+                    if is_target:
+                        ax.plot(x, y, color=line_color, linewidth=1, zorder=1, linestyle=line_style)
+
+            for fault in faults:
+                # Plot overall fault trace
+                trace = fault.trace
+                ax.plot(trace.xy[0], trace.xy[1], color='gray', linewidth=1, zorder=2, alpha=1)
+                # Plot fault throws on individual horizons
+                for throw in fault.throws:
+                    x = throw.line.xy[0]
+                    y = throw.line.xy[1]
+                    ax.plot(x, y, color='black', linewidth=2, zorder=2, alpha=1)
+
+            # Choose sensible plot limits for tvd
+            dtvd = plot_max_tvd - plot_min_tvd
+            plot_start_tvd = plot_min_tvd - dtvd / 10
+            plot_end_tvd = plot_max_tvd + dtvd / 10
+            plot_name += ' with Geosteering Interpretation "%s" for Target Formation "%s"' % (interp.name, target_horizon.name)
 
     # Finish plot
     plt.ylim(plot_start_tvd, plot_end_tvd)
     plt.xlim(plot_start_md, plot_end_md)
     plt.xlabel("MD")
     plt.ylabel("TVD")
     plt.legend()
```

## zonevu/Examples/Retrieval/BulkWellRetrieval.py

```diff
@@ -18,42 +18,78 @@
 
 from ...Zonevu import Zonevu
 from typing import List
 from ...DataModels.Wells.Well import WellEntry
 from typing import Optional
 from ...Services.WellService import WellData
 from ...Services.Client import ZonevuError
+from ...DataModels.Geosteering.Calcs import make_evenly_spaced_picks
+from ...DataModels.Geosteering.Interpretation import Interpretation
 import time
 
 
-def main(zonevu: Zonevu, exact_match: bool = True, name: Optional[str] = None):
+def main(zonevu: Zonevu, exact_match: bool = True, name: Optional[str] = None, max_count: Optional[int] = None):
     print('List wells in ZoneVu account with geosteering interpretations')
     well_svc = zonevu.well_service
     geosteer_svc = zonevu.geosteering_service
-    wells = well_svc.find_by_name(name, exact_match)
-    well_data_types = {WellData.geosteering}
-    print('Number of wells retrieved = %s' % len(wells))
-    counter = 2000
-    num_wells = len(wells)
-    num_with_geosteering = 0
-    for index, well_entry in enumerate(wells):
-        well = well_svc.find_by_id(well_entry.id)
-        wellbore = well.primary_wellbore
-        if wellbore is not None:
-            geosteering_entries = geosteer_svc.get_interpretations(wellbore.id)
-            has_geosteering = len(geosteering_entries) > 0
-            if has_geosteering:
-                print('%s - %s - %s geosteer interps' % (index, well_entry.full_name, len(geosteering_entries)))
-                num_with_geosteering += 1
-                for geosteer_entry in geosteering_entries:
-                    try:
-                        interp = geosteer_svc.get_interpretation(geosteer_entry.id)
-                        # print('  # geosteering interpretations = %s' % len(geosteering_entries))
-                    except ZonevuError as err:
-                        print('  Could not retrieve geosteering interp = %s (%s) because %s' %
-                              (geosteer_entry.name, geosteer_entry.id, err.message))
-                    time.sleep(1)  # Give zonevu a break
-        if index > counter:
+    entries = well_svc.find_by_name(name, exact_match)
+
+    num_interps_processed = 0
+    max_interps_to_process = max_count if max_count is not None else 100
+    num_successes = 0
+    num_failures = 0
+    valid_interps: List[Interpretation] = []
+    invalid_interps: List[(WellEntry, Interpretation)] = []
+    for entry in entries:
+        well = well_svc.find_by_id(entry.id)
+        well_svc.load_well(well, {WellData.geosteering, WellData.logs})
+
+        # Hard-wired test.  Delete.
+        # wellbore = well.primary_wellbore
+        # logs = wellbore.welllogs
+        # log = logs[1]
+        # curve_groups = log.curve_groups
+        # curve_group = curve_groups[0]
+        # # Get curve group samples
+        # well_log_svc = zonevu.welllog_service
+        # well_log_svc.load_splice_curve_samples(curve_group)
+
+        interps = well.primary_wellbore.interpretations
+        for interp in interps:
+            num_interps_processed += 1
+            bad_picks = [p for p in interp.picks if not p.valid]
+            print('Well "%s": Processing geosteering interp "%s"' % (well.full_name, interp.name))
+            print('   - Num picks = %s' % len(interp.picks))
+
+            if not interp.valid:
+                invalid_interps.append((entry, interp))
+                print('   - Warning: Interpretation %s has messed up picks!' % interp.name)
+                continue
+
+            try:
+                valid_interps.append(interp)
+                interval = 1
+                evenly_spaced_picks = make_evenly_spaced_picks(interp=interp, interval=interval)
+                num_successes += 1
+
+                print('   - Made %s evenly spaced picks MD %s - %s.' %
+                      (len(evenly_spaced_picks), round(evenly_spaced_picks[0].md), round(evenly_spaced_picks[-1].md)))
+            except ZonevuError as err:
+                print('   * Processing picks failed because %s' % err.message)
+                num_failures += 1
+
+        if num_interps_processed >= max_interps_to_process:
             break
 
+    print('Completed geosteering interpretation processing.')
+    print('   %s successfully processed.' % num_interps_processed)
+    print('   %s failed to process.' % num_failures)
+    print('   %s in total processed' % num_interps_processed)
+
+    print('Interpretations with invalid picks = %s:' % len(invalid_interps))
+    for item in invalid_interps:
+        well_entry, interp = item
+        bad_picks = [p for p in interp.picks if not p.valid]
+        print('  Well "%s" - interp "%s"' % (well_entry.full_name, interp.name))
+
```

## zonevu/Services/GeosteeringService.py

```diff
@@ -15,15 +15,15 @@
 #
 #
 #
 #
 #
 
 import json
-from typing import Union
+from typing import Union, Optional
 from ..DataModels.Geosteering.Interpretation import Interpretation, InterpretationEntry
 from ..DataModels.Wells.Wellbore import Wellbore
 from .Client import Client
 from enum import Enum
 
 
 class PickAdjustEnum(Enum):
@@ -77,25 +77,30 @@
         query_params = {'pickadjust': str(pic_adjust.value)}
         if interval is not None:
             query_params['interval'] = str(interval)
 
         item = self.client.get(interpUrl, query_params, True)
         interp = Interpretation.from_dict(item)
 
-        # r = self.client.call_api_get(interpUrl, query_params)
-        # interp = Interpretation.from_json(r.text)
+        # Do a little cleanup of interpretation
+        interp.picks = [p for p in interp.picks if p.md >= 0]   # Remove any picks at negative MDs
+        for p in interp.picks:
+            if not p.block_flag and not p.fault_flag:
+                p.block_flag = True         # Convert intra-block picks to start-of-block picks
+
+        valid = interp.valid
 
         return interp
 
     def load_interpretation(self, interp: Interpretation, pic_adjust: PickAdjustEnum = PickAdjustEnum.BlockBoundaries,
                             interval: Union[float, None] = None) -> Interpretation:
         full_interp = self.get_interpretation(interp.id, pic_adjust, interval)
-        # interp.copy_ids_from(full_interp)
-        for field in full_interp.__dataclass_fields__:
-            setattr(interp, field, getattr(full_interp, field))
+        if full_interp.valid:
+            for field in full_interp.__dataclass_fields__:
+                setattr(interp, field, getattr(full_interp, field))
         return interp
 
     def add_interpretation(self, wellbore_id: int, interp: Interpretation, overwrite: bool = False) -> None:
         # NOTE: we assume that the curve ids in the interp curve defs refer to curves that exist on this wellbore on
         #       the server.
         interp.target_wellbore_id = wellbore_id  # Must match
         url = "geosteer/interpretation/add/%s" % wellbore_id
```

## zonevu/Services/WelllogService.py

```diff
@@ -18,14 +18,15 @@
 #
 #
 
 import numpy as np
 from ..DataModels.Wells.Welllog import Welllog
 from ..DataModels.Wells.Wellbore import Wellbore
 from ..DataModels.Wells.Curve import Curve
+from ..DataModels.Wells.CurveGroup import CurveGroup
 from .Client import Client
 from typing import Optional
 
 
 class WelllogService:
     client: Client
 
@@ -106,12 +107,23 @@
         self.client.post(url, {}, False, {"overwrite": overwrite})
 
     def load_curve_samples(self, curve: Curve):
         url = "welllog/curvedatabytes/%s" % curve.id
         curve_float_bytes = self.client.get_data(url)
         curve.samples = np.frombuffer(curve_float_bytes, dtype=np.float32)
 
+    def load_splice_curve_samples(self, curve_group: CurveGroup):
+        url = "welllog/splicecurvedatabytes/%s" % curve_group.id
+        curve_float_bytes = self.client.get_data(url)
+        samples = np.frombuffer(curve_float_bytes, dtype=np.float32)
+        pass
+
+    # def load_curve_samples_by_id(self, curve_id: int):
+    #     url = "welllog/curvedatabytes/%s" % curve.id
+    #     curve_float_bytes = self.client.get_data(url)
+    #     curve.samples = np.frombuffer(curve_float_bytes, dtype=np.float32)
+
     def add_curve_samples(self, curve: Curve) -> None:
         url = "welllog/curvedatabytes/%s" % curve.id
         if curve.samples is not None:
             curve_float_bytes = curve.samples.tobytes()
             self.client.post_data(url, curve_float_bytes, 'application/octet-stream')
```

## zonevu/Services/WellService.py

```diff
@@ -156,15 +156,16 @@
         if options.geosteering:
             try:
                 primary_wb.interpretations.clear()
                 geosteer_svc = GeosteeringService(self.client)
                 geosteering_entries = geosteer_svc.get_interpretations(primary_wb.id)
                 for interp_entry in geosteering_entries:
                     interp = geosteer_svc.get_interpretation(interp_entry.id)
-                    primary_wb.interpretations.append(interp)
+                    if interp.valid:
+                        primary_wb.interpretations.append(interp)
             except Exception as err:
                 print('Could not load well geosteering interpretations because %s' % err)
 
         if options.notes:
             try:
                 notes_svc = NoteService(self.client)
                 notes_svc.load_notes(primary_wb)
```

## Comparing `zonevu-1.1.27.dist-info/METADATA` & `zonevu-1.1.28.dist-info/METADATA`

 * *Files 11% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: zonevu
-Version: 1.1.27
+Version: 1.1.28
 Summary: ZoneVu Web API Python SDK Package
 Home-page: https://www.ubiterra.com/
 License: MIT
 Author: Ubiterra
 Author-email: support@ubiterra.com
 Requires-Python: >=3.11,<4.0
 Classifier: Development Status :: 4 - Beta
```

## Comparing `zonevu-1.1.27.dist-info/RECORD` & `zonevu-1.1.28.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,7 +1,8 @@
+CHANGELOG.md,sha256=6mkdTKEomLCBntfTdNiMYri8tXCMDw473nhyPqt68cw,499
 zonevu/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 zonevu/DataModels/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/DataModels/Company.py,sha256=f0F74xUM_TUvnuwJTcrIy7T-U_YfVRxicIjNOWkIeUA,1971
 zonevu/DataModels/Completions/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/DataModels/Completions/DepthFeature.py,sha256=SWkcpck_nfe2CIWsqVARdB7Kh61t9gmBFxNNZ4mOjbM,1544
 zonevu/DataModels/Completions/Frac.py,sha256=Z2r2wQMpUKsjyfNSvirIwsRP3C0dfOxejwyj_u9_XlM,3043
 zonevu/DataModels/Completions/FracEntry.py,sha256=oueSLKsmrTBfIW9k00HeWKVWVVjfmgPKKBjM4dvOWMY,1420
@@ -20,22 +21,22 @@
 zonevu/DataModels/Geospatial/Crs.py,sha256=VejQioaj4SwvI5n0kBK42PwS0QRshmcFbijE0T1kAyY,2875
 zonevu/DataModels/Geospatial/Enums.py,sha256=sJeeSYosAQE1ipyu3lCs1WQ8gKmCRqKGuFcj62AIfh4,1101
 zonevu/DataModels/Geospatial/GeoBox.py,sha256=lCS1q3__0PzqbSEYSFoVKMctZ8mUv7qzQ8CIRylwIz0,2504
 zonevu/DataModels/Geospatial/GeoLocation.py,sha256=yXbA5H4m-gqeDWSGdeMey2BtfRosr9A9pdeTAGhN9Tk,2955
 zonevu/DataModels/Geospatial/GridCorner.py,sha256=Sz5HPJzqmYf7GttJW4gZnhEu2nhFKZsPEN2IaI_cVVY,1317
 zonevu/DataModels/Geospatial/GridGeometry.py,sha256=WTdsSMyyERgg6C1jY-nme2Nyf8pd_7facLXfCgChXaw,4154
 zonevu/DataModels/Geosteering/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
-zonevu/DataModels/Geosteering/Blocks.py,sha256=244nXL6ahBzDZFxz0bIc-1qqU9Znj5sXTfI4tXTd6bY,12985
-zonevu/DataModels/Geosteering/Calcs.py,sha256=BI8csLmBms6FCtVknek9tLZNVxAFpea-cf2VHzh58qw,10466
+zonevu/DataModels/Geosteering/Blocks.py,sha256=Ubv2Iuq6MOugz_aBQzWexTPqM-GaW0S_4nx4J66aEGs,10411
+zonevu/DataModels/Geosteering/Calcs.py,sha256=6pFKS020MJY-FaQb1p_LAtLO9iHxbZeHmBorBf0SEHA,16927
 zonevu/DataModels/Geosteering/Conditioning.py,sha256=Dzer0gGvPao9CUOsWSFgzaQXxzHBih9vk9TaqgVrC04,2368
-zonevu/DataModels/Geosteering/CurveDef.py,sha256=ZyeNZ1UqOEAVbpsO82LHVq90jcaj4D-FbHG6D42fZAQ,1537
+zonevu/DataModels/Geosteering/CurveDef.py,sha256=OWIKLAKo8YukSahrYFWf5SiNnr4F5dHKgHisnQKdf5I,2536
 zonevu/DataModels/Geosteering/Fault.py,sha256=iVWYI-253FTRGs866dcf5P-rVPDNG-6RUIo8qse31MU,2939
 zonevu/DataModels/Geosteering/Horizon.py,sha256=bQTSn2RsK3ZGhYTnlFiXdifaOh2kGzp2XgxVBPVhGmk,2500
-zonevu/DataModels/Geosteering/Interpretation.py,sha256=Te5AeTqVFgfCxSwEHxqR0aveuh3UKcRYCmtQIQv4uWI,3041
-zonevu/DataModels/Geosteering/Pick.py,sha256=GfLlv88d_yP5HSVtg9aJglGiRZX7TzDywEMW6BK-uU0,3264
+zonevu/DataModels/Geosteering/Interpretation.py,sha256=1N4MMyVJOHzGUKfpyHkBCX8gHFhUwxv_ttBQ-tomO0s,3502
+zonevu/DataModels/Geosteering/Pick.py,sha256=ZcI9cEzO_2esKtGW5WvOwio2gce8exIlxmWFCWeHUSI,4251
 zonevu/DataModels/Helpers.py,sha256=HZXxuTUnBHAJgB4-_XC-3JYHTG697ubzdks5NI3qnTk,2377
 zonevu/DataModels/Map/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/DataModels/Map/UserLayer.py,sha256=GjXuRosUKwXRUv4MsVlGgy8wSUBKMhDnze5yBeZSXlg,4018
 zonevu/DataModels/PrimaryDataObject.py,sha256=nR-XVgkpPZnbtzpF2ZQwMjxvvfa1TQYnBTvIjaBRws0,4786
 zonevu/DataModels/Project.py,sha256=L6ngA20Jyld4OhOmYydQDWyMFy7u7ciJG_oV0t6q_Pw,5794
 zonevu/DataModels/Seismic/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/DataModels/Seismic/SeismicInfo.py,sha256=tleQLxL4J4eknORSH7gW-8mtCtx6E0FSqTqOre7MHPY,4419
@@ -45,15 +46,15 @@
 zonevu/DataModels/Strat/StratColumn.py,sha256=zG6ehCu1PrYLhaVL4_El4p4Ck3brSXv5F1T9dyKuDjg,3026
 zonevu/DataModels/Styles/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/DataModels/Styles/Colors.py,sha256=9OMjFYED6vTr9MgzMs_DGHg1ywH3ECr3ewdJxDJRVlU,1859
 zonevu/DataModels/Styles/FillStyle.py,sha256=aBUCfgC9KEyIJxKqJhr87cCUeupNclMKbZAL_K_FBqc,1726
 zonevu/DataModels/Styles/LineStyle.py,sha256=sZ5zHuvaVQ9Z7c22RvoNwHCKA5AvyogWSxpjl74r-cw,1717
 zonevu/DataModels/Wells/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/DataModels/Wells/Curve.py,sha256=dG3tDc3pGopSwJEA5GLqjhFdlOhzHrNSZLTlvjIYDME,4547
-zonevu/DataModels/Wells/CurveGroup.py,sha256=QsQldwUwO-cJSw3874AXa4MbrMceVIe-HfiT9NcMKX8,2003
+zonevu/DataModels/Wells/CurveGroup.py,sha256=sCxI0IJ_j-7i_2uDr28Hse6KPgZTihMJ031p_0Nrxzc,2179
 zonevu/DataModels/Wells/Note.py,sha256=76vB3IoBmXn5j881alk7SRORH7egYfDoSDzEcsMhw4U,1609
 zonevu/DataModels/Wells/NoteCategory.py,sha256=xK41i8CNh_Kyas1fe399bzg48QmEyxnlGX9D4odx6vM,1144
 zonevu/DataModels/Wells/Station.py,sha256=I5PTm72lqDFTyBlWG6qTOlSe8KCzTcO4XIJATzBIESQ,2126
 zonevu/DataModels/Wells/Survey.py,sha256=68TupRhSzqMUYRBqZ8h2c9VaQW5W7542mubEhF03LY8,4109
 zonevu/DataModels/Wells/Well.py,sha256=iZioGdsUCv7axl3oPZe5a_QgmMM1siJEBURa_CzL_CI,11225
 zonevu/DataModels/Wells/Wellbore.py,sha256=38gYuZiC0G-JwsmI3TOdWgHZyCWWtdl81uJ7Mgx36pI,4668
 zonevu/DataModels/Wells/Welllog.py,sha256=vwfvqelcP9SdCXFy9py7mLAaX2q8d0-WkCwz_qNAJHU,3356
@@ -74,23 +75,23 @@
 zonevu/Examples/DataMgmt/DeleteProjectWells.py,sha256=wAkhc4z3EvXMRLCeoeMw79GZ8zWXr7yiv6N8pRLVb5U,2657
 zonevu/Examples/DataMgmt/DeleteWell.py,sha256=X_ljkM4dCEPrGOrphaDu5fa7ch7QhyL3c_zRWEPSzD8,1456
 zonevu/Examples/DataMgmt/GeomodelSample.py,sha256=1GU_z0uc6hp62EkXO5Ro-JBQBRKC82Wui9Ja9FScBOs,3154
 zonevu/Examples/DataMgmt/ModifyFrac.py,sha256=3q7eVuoMb_vsksaOvC9qRIO2oimqKOkmjXdiN9B5qNE,3228
 zonevu/Examples/DataMgmt/ProjectCopy.py,sha256=Kc3CFU_XJ0S7upBahwp6eO1Rl_ZUOqx6PatXmGJoBqo,2263
 zonevu/Examples/DataMgmt/UploadWellDoc.py,sha256=-zb__TOdRRSIiIKAjko5sFcqfFi6U8nJBan1x3y_yrQ,2197
 zonevu/Examples/Geosteering/__init__.py,sha256=SJzAl57oZTS9NV3fUFsRj-A_1hQwpX5PKHvZ82DN760,931
-zonevu/Examples/Geosteering/EvenlySpaced.py,sha256=zToB3bhKZJzuheO_xZYskSVSyRVdCns-92oZmhf3DeE,4274
+zonevu/Examples/Geosteering/EvenlySpaced.py,sha256=CdZx-sUXFHMjvNE87oTFJdPj5wyAP88PKb3IMUIGQkg,4432
 zonevu/Examples/Geosteering/ListGeosteering.py,sha256=h7BfZEQ199jjh83e2r-VJQuzXSBXr2HKkosLNWKLiF8,2534
-zonevu/Examples/Geosteering/PrintBlocks.py,sha256=0b8f2AGE-YFX37_IrAJXzBkYf4lv6X_nz-IHCtFJDyo,3327
+zonevu/Examples/Geosteering/PrintBlocks.py,sha256=W_b4pxs0S9aA_Ijq99k9QUs3je6QK6oXuRkAmIV-wwc,3619
 zonevu/Examples/Geosteering/PrintPicks.py,sha256=5fF0EKovM-ijDCksnr2jsrfC9_IyGD52Rk6Zii8XgeE,3933
 zonevu/Examples/Plot/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
 zonevu/Examples/Plot/CrossSection.py,sha256=tITBxDZVSYs9K4PS9UJO2B2AKUmZvXMrtE1MVgt7HWs,6738
-zonevu/Examples/Plot/CrossSection2.py,sha256=jefZGSIxZiphhMfdcFz2XzPSjnQvvl6FuD6ocIrNSfI,6399
+zonevu/Examples/Plot/CrossSection2.py,sha256=JBmjI4AQnv60hkmCF-sv17ZDU6-2GairxY2zDAnwsrg,6615
 zonevu/Examples/Retrieval/__init__.py,sha256=ta94hT_auG1VMuo8VmZM8oZFueox_QkSYyb1CLRJers,939
-zonevu/Examples/Retrieval/BulkWellRetrieval.py,sha256=aYZlkE7wGhKtJdovQI0d8rASKpKJoC7wS32tbew2LOs,2773
+zonevu/Examples/Retrieval/BulkWellRetrieval.py,sha256=5A-XEogP-CI8nc0NcAk9z7RfJeUwci72NHj0rRjBE1U,4209
 zonevu/Examples/Retrieval/DownloadDoc.py,sha256=oH0LwZA13KM1o2oJlKTWtfD7A5MBu8a1HKXyI_YPI9Y,2130
 zonevu/Examples/Retrieval/GetSeismicInfo.py,sha256=aHyjO7fXQRU0-9TI8uvirMQRRTyle2ElVqUA7zy7kBo,1855
 zonevu/Examples/Retrieval/ListFracs.py,sha256=N3q_n7VlYA0dBg0d5pWhhLc0MBV9BnLi1vWaeTiGsNM,2128
 zonevu/Examples/Retrieval/ListGeomodels.py,sha256=UG3z13CmDU5HbzVbqXVAyckz8lDLRpNATkFJTmZXpCQ,1885
 zonevu/Examples/Retrieval/ListProjects.py,sha256=IL5ajfueRetEvUuJhne1CIT-rviRLVoFSg_Y8m25ww4,1963
 zonevu/Examples/Retrieval/ListSeismic.py,sha256=FdQl570J9C7cu8XIXMjQIOikImGNnukWaUeopcv84SM,1868
 zonevu/Examples/Retrieval/ListStratColumns.py,sha256=oVVq2jejJS_XAsJ_LqTatKT1DoZujrKyOo3L7o9Zrd8,1588
@@ -113,24 +114,24 @@
 zonevu/Services/CompanyService.py,sha256=12JGA7xIJ1HDpMi4CvqcwFZbBIsMcyhLPIL8zoIaAnI,2388
 zonevu/Services/CompletionsService.py,sha256=XWoTpuakDr5P3F4bpGRbCkOr1J6gvGmQSp_Z5pFfFT4,4414
 zonevu/Services/CoordinatesService.py,sha256=EG12jgMET-2xe2j4SjHfIQkzDQs0crWBYwT6V63NiNw,7802
 zonevu/Services/DocumentService.py,sha256=6eyRtjHGhOQnNSMqxqvDK7pQWDkmwG847GmOGSG6NmA,5021
 zonevu/Services/EndPoint.py,sha256=5cKWm-JYW7wVNmvx65ejmcyBgIFq8QXg7DUbXq3X5XE,3301
 zonevu/Services/Error.py,sha256=zY22xcAd1DvRdKNyKVDzmOWK7YLaotdlR_7ulZwrkkk,1973
 zonevu/Services/GeomodelService.py,sha256=j8nrUJQqeZLrUiyo2PhJpyPXzZEB_zA7FfcYMMVxFI4,8353
-zonevu/Services/GeosteeringService.py,sha256=FgGNUj5Y65qY1kIoIzXKCH0zX-KrJizMnldRHm3q1ss,5161
+zonevu/Services/GeosteeringService.py,sha256=4dTfRWV0BxLGifgmMN7QGR83zAMUTT9dqohUiehjaZ8,5412
 zonevu/Services/MapService.py,sha256=dBpKmZBivyu1nMRClRnh6RnM2GOBWKcuChGPg2GVDSI,2893
 zonevu/Services/NoteService.py,sha256=tzkxp4b8f890FgO5xsiZLuO9jNn5F0CKRTuJEVFh294,2534
 zonevu/Services/ProjectService.py,sha256=tegSroeWkRsSi0os1YB43AQ782k34zXtbdRktQD-exo,7155
 zonevu/Services/SeismicService.py,sha256=XUIQxjIHjvU5pw-CYGKuRaLKQ5EOKZWtJA02kU3k6zE,5996
 zonevu/Services/Storage.py,sha256=D-hAX5K2PaP8j28Ctpm3FOfJnvRTv7nnkGKfIZ24gCk,11301
 zonevu/Services/StratService.py,sha256=Wu1xzOVc1PpOZOyCNVvRZBo-1B3NjXWrOOlnGsnZ8ac,2535
 zonevu/Services/SurveyService.py,sha256=vM9b7sbepUCxNvkBMdrlsShaPIW_okfz1UoItyUAa2g,3296
 zonevu/Services/Utils.py,sha256=jPhsM1qI5RAU0fXCOFYwU--WIadA8qnH4MU6TAQujCw,3959
 zonevu/Services/WellData.py,sha256=fcPbJNCUcsDrtATxohXtX3tZLtmPPzwPnqAC5guQ8vw,2736
-zonevu/Services/WelllogService.py,sha256=ZtKRvu5bew8lxHSkpPmrBR_iS5mXLrxw54jKf5rUYI4,4842
-zonevu/Services/WellService.py,sha256=AHVmYvWLLAQ5UI3ZaL3TSOFgxgbuqyBNP5o8fN-0kkg,15131
+zonevu/Services/WelllogService.py,sha256=elUFuw4j8sXa8wmrKYVuqRsgKigI5VCsZhhrCDdsOpo,5421
+zonevu/Services/WellService.py,sha256=qx--KedPXAyAFSnUtgJuZpjlNr4C6HR93pytasHIHIU,15173
 zonevu/Services/WelltopService.py,sha256=TeSLhL_9Ux6QcgUayzm9_C4bL0DqgVkSZgZmTIgIDkk,2947
 zonevu/Zonevu.py,sha256=fHizZdIf3QnmbNle1nBpmwb_Sz7oxs1-JK3kMT7l1_4,7308
-zonevu-1.1.27.dist-info/METADATA,sha256=JVMQuu14DiBjVfZsNilT1-jnglJ16qD14GmqW70ysbA,1146
-zonevu-1.1.27.dist-info/WHEEL,sha256=FMvqSimYX_P7y0a7UY-_Mc83r5zkBZsCYPm7Lr0Bsq4,88
-zonevu-1.1.27.dist-info/RECORD,,
+zonevu-1.1.28.dist-info/METADATA,sha256=XYTp4c3rkkCYlp-A2VK1UbVKZJ_nJtx39v-lck_wIgQ,1146
+zonevu-1.1.28.dist-info/WHEEL,sha256=FMvqSimYX_P7y0a7UY-_Mc83r5zkBZsCYPm7Lr0Bsq4,88
+zonevu-1.1.28.dist-info/RECORD,,
```

