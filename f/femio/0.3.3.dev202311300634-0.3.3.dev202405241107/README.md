# Comparing `tmp/femio-0.3.3.dev202311300634-py3-none-any.whl.zip` & `tmp/femio-0.3.3.dev202405241107-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 102656 bytes, number of entries: 40
+Zip file size: 102532 bytes, number of entries: 40
 -rw-r--r--  2.0 unx      397 b- defN 80-Jan-01 00:00 femio/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 femio/__main__/__init__.py
 -rw-r--r--  2.0 unx     1461 b- defN 80-Jan-01 00:00 femio/__main__/femconvert.py
 -rw-r--r--  2.0 unx     5291 b- defN 80-Jan-01 00:00 femio/config.py
 -rw-r--r--  2.0 unx    12020 b- defN 80-Jan-01 00:00 femio/fem_attribute.py
 -rw-r--r--  2.0 unx    16507 b- defN 80-Jan-01 00:00 femio/fem_attributes.py
--rw-r--r--  2.0 unx    45216 b- defN 80-Jan-01 00:00 femio/fem_data.py
+-rw-r--r--  2.0 unx    45259 b- defN 80-Jan-01 00:00 femio/fem_data.py
 -rw-r--r--  2.0 unx    19977 b- defN 80-Jan-01 00:00 femio/fem_elemental_attribute.py
 -rw-r--r--  2.0 unx     3242 b- defN 80-Jan-01 00:00 femio/fem_writer.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 femio/formats/__init__.py
 -rw-r--r--  2.0 unx     1223 b- defN 80-Jan-01 00:00 femio/formats/ensight/ensight.py
 -rw-r--r--  2.0 unx    30646 b- defN 80-Jan-01 00:00 femio/formats/fistr/fistr.py
 -rw-r--r--  2.0 unx    28970 b- defN 80-Jan-01 00:00 femio/formats/fistr/write_fistr.py
 -rw-r--r--  2.0 unx     2839 b- defN 80-Jan-01 00:00 femio/formats/obj/obj.py
 -rw-r--r--  2.0 unx     1442 b- defN 80-Jan-01 00:00 femio/formats/obj/write_obj.py
 -rw-r--r--  2.0 unx     1003 b- defN 80-Jan-01 00:00 femio/formats/polyvtk/polyvtk.py
--rw-r--r--  2.0 unx     2898 b- defN 80-Jan-01 00:00 femio/formats/polyvtk/write_polyvtk.py
+-rw-r--r--  2.0 unx     2654 b- defN 80-Jan-01 00:00 femio/formats/polyvtk/write_polyvtk.py
 -rw-r--r--  2.0 unx     2453 b- defN 80-Jan-01 00:00 femio/formats/stl/stl.py
 -rw-r--r--  2.0 unx     1497 b- defN 80-Jan-01 00:00 femio/formats/stl/write_stl.py
 -rw-r--r--  2.0 unx     6422 b- defN 80-Jan-01 00:00 femio/formats/ucd/ucd.py
 -rw-r--r--  2.0 unx     3862 b- defN 80-Jan-01 00:00 femio/formats/ucd/write_ucd.py
 -rw-r--r--  2.0 unx     3441 b- defN 80-Jan-01 00:00 femio/formats/vtp/vtp.py
 -rw-r--r--  2.0 unx     2514 b- defN 80-Jan-01 00:00 femio/formats/vtp/write_vtp.py
 -rw-r--r--  2.0 unx     7868 b- defN 80-Jan-01 00:00 femio/functions.py
 -rw-r--r--  2.0 unx    51775 b- defN 80-Jan-01 00:00 femio/geometry_processor.py
--rw-r--r--  2.0 unx    77234 b- defN 80-Jan-01 00:00 femio/graph_processor.py
+-rw-r--r--  2.0 unx    77266 b- defN 80-Jan-01 00:00 femio/graph_processor.py
 -rw-r--r--  2.0 unx     4742 b- defN 80-Jan-01 00:00 femio/io.py
 -rw-r--r--  2.0 unx    49061 b- defN 80-Jan-01 00:00 femio/mesh_compressor.py
 -rw-r--r--  2.0 unx      100 b- defN 80-Jan-01 00:00 femio/nodal_data.py
--rw-r--r--  2.0 unx    47855 b- defN 80-Jan-01 00:00 femio/signal_processor.py
+-rw-r--r--  2.0 unx    47863 b- defN 80-Jan-01 00:00 femio/signal_processor.py
 -rw-r--r--  2.0 unx     1325 b- defN 80-Jan-01 00:00 femio/time_series_dataframe.py
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 femio/util/__init__.py
 -rw-r--r--  2.0 unx     4636 b- defN 80-Jan-01 00:00 femio/util/brick_generator.py
 -rw-r--r--  2.0 unx     5614 b- defN 80-Jan-01 00:00 femio/util/random_generator.py
 -rw-r--r--  2.0 unx    16604 b- defN 80-Jan-01 00:00 femio/util/string_parser.py
-?rw-r--r--  2.0 unx       61 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202311300634.dist-info/entry_points.txt
--rw-r--r--  2.0 unx    11432 b- defN 80-Jan-01 00:00 femio-0.3.3.dev202311300634.dist-info/LICENSE
-?rw-r--r--  2.0 unx       83 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202311300634.dist-info/WHEEL
-?rw-r--r--  2.0 unx     1329 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202311300634.dist-info/METADATA
-?rw-r--r--  2.0 unx     3345 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202311300634.dist-info/RECORD
-40 files, 476385 bytes uncompressed, 97350 bytes compressed:  79.6%
+?rw-r--r--  2.0 unx       61 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202405241107.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx    11432 b- defN 80-Jan-01 00:00 femio-0.3.3.dev202405241107.dist-info/LICENSE
+?rw-r--r--  2.0 unx       83 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202405241107.dist-info/WHEEL
+?rw-r--r--  2.0 unx     1329 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202405241107.dist-info/METADATA
+?rw-r--r--  2.0 unx     3345 b- defN 16-Jan-01 00:00 femio-0.3.3.dev202405241107.dist-info/RECORD
+40 files, 476224 bytes uncompressed, 97226 bytes compressed:  79.6%
```

## zipnote {}

```diff
@@ -99,23 +99,23 @@
 
 Filename: femio/util/random_generator.py
 Comment: 
 
 Filename: femio/util/string_parser.py
 Comment: 
 
-Filename: femio-0.3.3.dev202311300634.dist-info/entry_points.txt
+Filename: femio-0.3.3.dev202405241107.dist-info/entry_points.txt
 Comment: 
 
-Filename: femio-0.3.3.dev202311300634.dist-info/LICENSE
+Filename: femio-0.3.3.dev202405241107.dist-info/LICENSE
 Comment: 
 
-Filename: femio-0.3.3.dev202311300634.dist-info/WHEEL
+Filename: femio-0.3.3.dev202405241107.dist-info/WHEEL
 Comment: 
 
-Filename: femio-0.3.3.dev202311300634.dist-info/METADATA
+Filename: femio-0.3.3.dev202405241107.dist-info/METADATA
 Comment: 
 
-Filename: femio-0.3.3.dev202311300634.dist-info/RECORD
+Filename: femio-0.3.3.dev202405241107.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## femio/fem_data.py

```diff
@@ -674,15 +674,17 @@
                 return np.concatenate(indices)
             else:
                 return np.ravel(indices)
 
         surface_indices, _ = self.extract_surface()
         if isinstance(surface_indices, dict):
             unique_indices = np.unique(np.concatenate([
-                flatten(v, k) for k, v in surface_indices.items()]))
+                flatten(v, k) for k, v in surface_indices.items()
+                if len(v) > 0
+            ]))
             surface_ids = {
                 t: self.nodes.ids[ids] for t, ids in surface_indices.items()
                 if t != 'polygon'}
             if 'polygon' in surface_indices \
                     and len(surface_indices['polygon']) > 0:
                 polygon_data = np.empty(
                     len(surface_indices['polygon']), object)
```

## femio/formats/polyvtk/write_polyvtk.py

```diff
@@ -1,10 +1,8 @@
 
-import fileinput
-
 import numpy as np
 from tvtk.api import tvtk
 
 from ... import fem_writer
 from ... import config
 
 
@@ -58,18 +56,14 @@
             unstructured_grid.point_data.get_array(array_id).name = k
 
         writer = tvtk.XMLUnstructuredGridWriter(file_name=str(file_name))
         writer.data_mode = 'ascii'
         writer.set_input_data(unstructured_grid)
         writer.write()
 
-        # Replace int64 with int32 because tvtk has trouble to read it
-        with fileinput.input(file_name, inplace=True) as file:
-            for line in file:
-                print(line.replace('Int64', 'Int32'), end='')
         return file_name
 
     def _reorder_cell_data(self, data):
         return np.concatenate(
             [data[self.fem_data.elements.types == 'polyhedron']] + [
                 data[self.fem_data.elements.types == t]
                 for t, _ in self.fem_data.elements.items()
```

## femio/graph_processor.py

```diff
@@ -496,15 +496,15 @@
         degrees = adj.sum(axis=1) - 1
         self.elemental_data.update_data(
             self.elements.ids, {'degree': degrees}, allow_overwrite=True)
         return degrees
 
     @functools.lru_cache(maxsize=2)
     def calculate_adjacency_matrix(
-            self, *, mode='elemental', order1_only=True):
+            self, *, mode='elemental', order1_only=False):
         """Calculate graph adjacency matrix.
 
         Parameters
         ----------
         mode: str, optional (['elemental'], 'nodal')
             If 'elemental', generate (n_element, n_element) shaped
             adjacency matrix where edges are defined by node shearing.
@@ -524,32 +524,32 @@
         elif mode == 'nodal':
             adj = self.calculate_adjacency_matrix_node(order1_only=order1_only)
         else:
             raise ValueError(f"Unexpected mode: {mode}")
         return adj
 
     @functools.lru_cache(maxsize=1)
-    def calculate_adjacency_matrix_element(self):
+    def calculate_adjacency_matrix_element(self, order1_only=False):
         """Calculate graph adjacency matrix regarding elements sharing the same
         node as connected.
 
         Returns
         -------
         adj: scipy.sparse.csr_matrix
             Adjacency matrix in CSR expression.
         """
         print('Calculating incidence matrix')
         print(dt.datetime.now())
         # raise ValueError(node_ids, element_data, )
         incidence_matrix = self.calculate_incidence_matrix(
-            order1_only=True)
+            order1_only=order1_only)
         return incidence_matrix.T.dot(incidence_matrix).tocsr()
 
     @functools.lru_cache(maxsize=1)
-    def calculate_adjacency_matrix_node(self, order1_only=True):
+    def calculate_adjacency_matrix_node(self, order1_only=False):
         """Calculate graph adjacency matrix regarding nodes connected with
         edges. Edges are defined by element shearing.
 
         Parameters
         ----------
         order1_only: bool, optional [True]
             If True, consider only order 1 nodes.
@@ -563,15 +563,15 @@
         print(dt.datetime.now())
         # raise ValueError(node_ids, element_data, )
         incidence_matrix = self.calculate_incidence_matrix(
             order1_only=order1_only)
         return incidence_matrix.dot(incidence_matrix.T)
 
     @functools.lru_cache(maxsize=1)
-    def calculate_incidence_matrix(self, order1_only=True):
+    def calculate_incidence_matrix(self, order1_only=False):
         """Calculate graph incidence matrix, which is
         (n_node, n_element)-shaped matrix with bool.
 
         Parameters
         ----------
         order1_only: bool, optional
             If True, generate incidence matrix based on only order-one nodes.
@@ -613,15 +613,15 @@
             (
                 [True] * len(element_indices),
                 (flattened_node_indices, element_indices)),
             shape=(len(nodes), len(elements)))
         return incidence_matrix
 
     @functools.lru_cache(maxsize=2)
-    def calculate_laplacian_matrix(self, mode='nodal', order1_only=True):
+    def calculate_laplacian_matrix(self, mode='nodal', order1_only=False):
         """Calculate edge-based graph incidence matrix, which is
         (n_edge, n_node)-shaped matrix with bool.
 
         Parameters
         ----------
         mode: str, optional, ['nodal', 'elemental']
         order1_only: bool, optional
@@ -641,15 +641,15 @@
         else:
             raise ValueError(f"Unexpected mode: {mode}")
         adj_wo_loop = adj.astype(int) - sp.eye(*adj.shape, dtype=int)
         degree = sp.diags(np.ravel(adj_wo_loop.sum(axis=1)), dtype=int)
         return adj_wo_loop - degree
 
     @functools.lru_cache(maxsize=1)
-    def calculate_edge_gradient_matrix(self, mode='nodal', order1_only=True):
+    def calculate_edge_gradient_matrix(self, mode='nodal', order1_only=False):
         """Calculate edge-based graph gradient matrix, which is
         (n_edge, n_vertex)-shaped matrix with bool. n_vertex can be either
         n_node or n_element, depending on the `mode` option.
 
         Parameters
         ----------
         mode: str, optional, ['nodal', 'elemental']
@@ -678,15 +678,15 @@
             (data, (row, col)), shape=(int(len(col) / 2), adj.shape[0]),
             dtype=int)
         return gradient_matrix
 
     @functools.lru_cache(maxsize=15)
     def calculate_n_hop_adj(
             self, mode='elemental', n_hop=1, include_self_loop=True,
-            order1_only=True):
+            order1_only=False):
         if mode == 'elemental':
             adj = self.calculate_adjacency_matrix_element()
 
         elif mode == 'nodal':
             adj = self.calculate_adjacency_matrix_node(
                 order1_only=order1_only)
```

## femio/signal_processor.py

```diff
@@ -44,15 +44,15 @@
             else:
                 return np.mean(elemental_data, axis=1)
         if ravel:
             return np.array([np.ravel(r) for r in elemental_data])
         return elemental_data
 
     def convert_elemental2nodal(
-            self, elemental_data, mode='mean', order1_only=True,
+            self, elemental_data, mode='mean', order1_only=False,
             raise_negative_volume=True, weight=None, incidence=None):
         """Convert elemental data to nodal data.
 
         Args:
             elemental_data: numpy.ndarray
                 Elemental data to be converted.
             mode: str, optional
@@ -279,15 +279,15 @@
         averaged_data = elemental_data
         for _ in range(hops):
             averaged_data = normalizers * (
                 averaged_data + weight * adj_wo_loop.dot(averaged_data))
         return averaged_data
 
     def calculate_moving_average_nodal_data(
-            self, nodal_data, *, hops=1, weight=.1, order1_only=True):
+            self, nodal_data, *, hops=1, weight=.1, order1_only=False):
         """Perform moving average according with adjacency of the mesh.
 
         Args:
             nordal_data: numpy.ndarray
                 Nodal data to be moiving-averaged.
             hops: int, optional [1]
                 The number of hops to make moving averaging.
@@ -320,15 +320,15 @@
         averaged_data = nodal_data
         for _ in range(hops):
             averaged_data = normalizers * (
                 averaged_data + weight * adj_wo_loop.dot(averaged_data))
         return averaged_data
 
     def calculate_median_filter(
-            self, data, *, mode='elemental', hops=1, order1_only=True):
+            self, data, *, mode='elemental', hops=1, order1_only=False):
         """Perform median filter according with adjacency of the mesh.
 
         Args:
             data: numpy.ndarray
                 Data to be filtered.
             hops: int, optional [1]
                 The number of hops to make filtering.
@@ -354,15 +354,15 @@
             for i_row, adjacents in enumerate(list_adj):
                 temp_data[i_row, :] = np.median(
                     filtered_data[adjacents], axis=0)
             filtered_data = temp_data
         return filtered_data
 
     def calculate_frame_expansion_adjs(
-            self, data, mode='nodal', n_hop=1, order1_only=True, **kwargs):
+            self, data, mode='nodal', n_hop=1, order1_only=False, **kwargs):
         """Calculate frame expansion adjacency matrices.
 
         Parameters
         ----------
         data: numpy.ndarray
             (n_node, dimension, dimension, ...) shaped array to be expanded.
                      ^^^^^^^^^^^^^^^^^^^^^^^^^
@@ -398,15 +398,15 @@
 
         frame_expansion_adjs = self._dot_ndarray_sparse(
             data, frame_tensor_adjs)
         return frame_expansion_adjs
 
     @functools.lru_cache(maxsize=10)
     def calculate_frame_tensor_adjs(
-            self, mode='elemental', n_hop=1, order1_only=True, tensor_rank=1):
+            self, mode='elemental', n_hop=1, order1_only=False, tensor_rank=1):
         """Calculate frame adjacency matrices F s.t. phi = F phi,
         based on frame which are set of relative vectors coming from mesh
         topology.
 
         Parameters
         ----------
         mode: ['nodal', 'elemental'], optional
@@ -650,15 +650,15 @@
         grad_adjs = self.calculate_spatial_gradient_adjacency_matrices(
             mode='elemental', n_hop=n_hop, kernel=kernel, normals=normals,
             **kwargs)
         return np.stack([
             grad_adj.dot(elemental_data) for grad_adj in grad_adjs], axis=1)
 
     def calculate_nodal_spatial_gradients(
-            self, nodal_data, n_hop=1, kernel=None, order1_only=True,
+            self, nodal_data, n_hop=1, kernel=None, order1_only=False,
             normals=None, **kwargs):
         """Calculate spatial gradient (not graph gradient) w.r.t nodal
         data.
 
         Parameters
         ----------
         nodal_data: numpy.ndarray
@@ -689,15 +689,15 @@
         else:
             filter_ = np.ones(len(self.nodes.ids), dtype=bool)
         return np.stack([
             grad_adj.dot(nodal_data[filter_])
             for grad_adj in grad_adjs], axis=1)
 
     def calculate_spatial_gradient_adjacency_matrices(
-            self, mode='elemental', n_hop=1, kernel=None, order1_only=True,
+            self, mode='elemental', n_hop=1, kernel=None, order1_only=False,
             use_effective_volume=True, moment_matrix=False,
             consider_volume=True, normals=None, normal_weight=1.,
             normal_weight_factor=None, adj=None,
             **kwargs):
         """Calculate spatial gradient (not graph gradient) matrix.
 
         Parameters
@@ -893,15 +893,15 @@
             sp.coo_matrix(
                 grad_adj_wo_self - sp.eye(*grad_adj_wo_self.shape).multiply(
                     grad_adj_wo_self.sum(axis=1)))
             for grad_adj_wo_self in grad_adj_wo_selfs]
         return grad_adjs
 
     def calculate_spatial_gradient_incidence_matrix(
-            self, mode='nodal', order1_only=True,
+            self, mode='nodal', order1_only=False,
             moment_matrix=True, normals=None, normal_weight=1., **kwargs):
         """Calculate spatial gradient (not graph gradient) incidence matrix.
 
         Parameters
         ----------
         mode: str, optional ['nodal', 'elemental']
         order1_only: bool, optional [True]
```

## Comparing `femio-0.3.3.dev202311300634.dist-info/LICENSE` & `femio-0.3.3.dev202405241107.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `femio-0.3.3.dev202311300634.dist-info/METADATA` & `femio-0.3.3.dev202405241107.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,31 +1,31 @@
 Metadata-Version: 2.1
 Name: femio
-Version: 0.3.3.dev202311300634
+Version: 0.3.3.dev202405241107
 Summary: FEM I/O Tool
 Home-page: https://github.com/ricosjp/femio
 Author: RICOS Co. Ltd.
 Requires-Python: >=3.8,<3.10
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Provides-Extra: PyQt5
 Requires-Dist: PyQt5 (>=5.14.0,<6.0.0); extra == "PyQt5"
 Requires-Dist: kiwisolver (==1.0.1)
 Requires-Dist: lxml (>=4.6.3,<5.0.0)
 Requires-Dist: matplotlib (>=3.1,<4.0)
-Requires-Dist: mayavi (>=4.7.3,<5.0.0)
+Requires-Dist: mayavi (>=4.8.1,<5.0.0)
 Requires-Dist: meshio (>=3.3,<4.0)
 Requires-Dist: networkx (>=2.4,<3.0)
 Requires-Dist: numba (>=0.53.1)
 Requires-Dist: numpy (>=1.20,<2.0)
 Requires-Dist: numpy-stl (>=2.13,<3.0)
 Requires-Dist: pandas (>=1.0,<2.0)
 Requires-Dist: scipy (>=1.7.0,<2.0.0)
-Requires-Dist: vtk (>=9.0.3,<10.0.0)
+Requires-Dist: vtk (>=9.2.6,<10.0.0)
 Project-URL: Documentation, https://ricosjp.github.io/femio/
 Project-URL: Repository, https://github.com/ricosjp/femio
 Description-Content-Type: text/markdown
 
 ![](sphinx/fig/femio_logo.svg)
 
 # FEMIO: FEM and mesh I/O tool
```

## Comparing `femio-0.3.3.dev202311300634.dist-info/RECORD` & `femio-0.3.3.dev202405241107.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,40 +1,40 @@
 femio/__init__.py,sha256=j6sgFjUR4WX3-xrklwO4YnGsL6lVuVRyN7ik3Mc2JHs,397
 femio/__main__/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 femio/__main__/femconvert.py,sha256=OgL6jqhjI5mYnKcXB8gRk8Jviu6SKaFbZRWJg2O3ilU,1461
 femio/config.py,sha256=5Ce3YNB0wKkrikIqzC84moaFNIZRXniur56HZ3fdUz4,5291
 femio/fem_attribute.py,sha256=OD_DuHDoCfw_MWbCBGeexwpfdb22NHHdv7wxbvScYKs,12020
 femio/fem_attributes.py,sha256=qJ8X-YTnVAY2i-PUz1JEQg0lHEwrhlENPXlkpqXPtJg,16507
-femio/fem_data.py,sha256=Du6X322ubUp6KQEIOrTpb34gSVV-OP9EaI9SChLOy6g,45216
+femio/fem_data.py,sha256=p05M5eUBumi5sH4AMm37JEJIkVszfBj87Q8LoeEZdvk,45259
 femio/fem_elemental_attribute.py,sha256=QTc_zFS2w7-mcUi_FRnuMdXdbAqcysuBTzSeeTw3SW0,19977
 femio/fem_writer.py,sha256=61kuUs6wa7nf4jHzSnFmA8vsRMmzGJBdGax8cu60Gyw,3242
 femio/formats/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 femio/formats/ensight/ensight.py,sha256=KfXUsZy3ONZRrdrOiMdrcGIKjRzXqJfKXWtha2sdigk,1223
 femio/formats/fistr/fistr.py,sha256=9GPAaTKUf0GeMwYqIiT8gXpVOF4qntivkvuVuklYCUI,30646
 femio/formats/fistr/write_fistr.py,sha256=XHv18bIPecWztm3tZ1-upMy177Cpw_Z_vAk6cJ_ZX7Q,28970
 femio/formats/obj/obj.py,sha256=wEhlR5HgYNey5WygOh2W0SeMKZmy7rUVhKNoDA-vdVY,2839
 femio/formats/obj/write_obj.py,sha256=Q8ceaB5p1RqUpdOPbD0EIZ4QLvaa3E32QhamRyGWnJo,1442
 femio/formats/polyvtk/polyvtk.py,sha256=qqE0mjd8-BKBttQqQskrlNsz4QeF2xRJZNnEI-EpesU,1003
-femio/formats/polyvtk/write_polyvtk.py,sha256=fIu2FxzJvtVRgdrUS4Q3G3MPiOgbBf9bvKZL4HhhSCo,2898
+femio/formats/polyvtk/write_polyvtk.py,sha256=sD5tNVmt-Yej26a0isD2Nw3GIyJLuELaIO4LXBmoJFo,2654
 femio/formats/stl/stl.py,sha256=aEw1QQ1YQV0iwfnTjp6rjc7D-bSbtoPoWc-zTD-uyGY,2453
 femio/formats/stl/write_stl.py,sha256=u7T7cEnRML59pahw7DfxVZLFjpUGHIqYUVPLtIaP-CY,1497
 femio/formats/ucd/ucd.py,sha256=4Ar90Ja4Lr6wH0Bx_xeRtj-D5pZLx0RQkTLrhumpXfo,6422
 femio/formats/ucd/write_ucd.py,sha256=aQkuXWmx5acJwb0Wf5oDoZgE-EIO9yLZ_ilSq_GSBi0,3862
 femio/formats/vtp/vtp.py,sha256=4xEhK0n9SZioMBY9hbBTdbE37cOPuL-gK9S2gj0fNUA,3441
 femio/formats/vtp/write_vtp.py,sha256=dQTSQxBoiMR2cCzMb6wmfETenrudNhGCtugA09lleFs,2514
 femio/functions.py,sha256=DBFy-J2V4clhe6pjPNzuYiHBdQQuvBLTJ78cnOBKms8,7868
 femio/geometry_processor.py,sha256=P4T5pRMQO_eSkoBNYMYYp_w9C3DwVTj0zFUp-Gv1CqU,51775
-femio/graph_processor.py,sha256=jqsINCPP9AOSFwcVjrlasAMB82HB9yWE23AJTC8kAo8,77234
+femio/graph_processor.py,sha256=hH853BJsF1K3yPaOKujoqtPj-2dSIxXMxY9daoh7TRc,77266
 femio/io.py,sha256=uihecMhzACqrgMYxPFz24xzXkKr4xB6qwHVXm68IJ3o,4742
 femio/mesh_compressor.py,sha256=2kAVf8acgNHHdeyRDD4eMhv2oi7iZIkOFdrIBCJvCGU,49061
 femio/nodal_data.py,sha256=O8pwRyey-QIU7rqCgAXa2FmdquzbOnJokYNa-LqdvQk,100
-femio/signal_processor.py,sha256=60gJ7tYjvkdTeKXkCnVsQNjTQywifqbEWXSK-JF0kDw,47855
+femio/signal_processor.py,sha256=PH7EfuPYmjAYa7JuIuurzn6jmB1NFcEWL-eSLG0z6R4,47863
 femio/time_series_dataframe.py,sha256=MG4Xzsklfq9gh9UCyqpN7O_BGl59hj-reZri8ZHfRn8,1325
 femio/util/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 femio/util/brick_generator.py,sha256=wAPZ_dXt4ue4w59w2a3OPEFFmuOy477eroPlzuHqdI0,4636
 femio/util/random_generator.py,sha256=c8v9v-2MJ0ElCUZhDGhVNIgyufLWoFIqfsH1y5WzQZc,5614
 femio/util/string_parser.py,sha256=uB9hjWkoGhUa9yubADIIUiEMZGUsZvv6L5egO2hbnms,16604
-femio-0.3.3.dev202311300634.dist-info/entry_points.txt,sha256=PniMmib7XMGbpjwBsZ2E-hgMu0hBmqN8DxRLuu5Elsc,61
-femio-0.3.3.dev202311300634.dist-info/LICENSE,sha256=ppSavx_EkRkglt93CoBaKm3O4XY_nfjVmKyPysewaHQ,11432
-femio-0.3.3.dev202311300634.dist-info/WHEEL,sha256=y3eDiaFVSNTPbgzfNn0nYn5tEn1cX6WrdetDlQM4xWw,83
-femio-0.3.3.dev202311300634.dist-info/METADATA,sha256=auAgdxJ2PCGVKyDAB_TVdg4-hwfu7tLwPs89ZGd6Xu8,1329
-femio-0.3.3.dev202311300634.dist-info/RECORD,,
+femio-0.3.3.dev202405241107.dist-info/entry_points.txt,sha256=PniMmib7XMGbpjwBsZ2E-hgMu0hBmqN8DxRLuu5Elsc,61
+femio-0.3.3.dev202405241107.dist-info/LICENSE,sha256=ppSavx_EkRkglt93CoBaKm3O4XY_nfjVmKyPysewaHQ,11432
+femio-0.3.3.dev202405241107.dist-info/WHEEL,sha256=y3eDiaFVSNTPbgzfNn0nYn5tEn1cX6WrdetDlQM4xWw,83
+femio-0.3.3.dev202405241107.dist-info/METADATA,sha256=Hhy7Jv6U4Rs_2JFRvYmFwSM0pbT0oyG04IF8N1DXxwE,1329
+femio-0.3.3.dev202405241107.dist-info/RECORD,,
```

