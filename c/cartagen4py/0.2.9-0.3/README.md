# Comparing `tmp/cartagen4py-0.2.9-py3-none-any.whl.zip` & `tmp/cartagen4py-0.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,70 +1,72 @@
-Zip file size: 102257 bytes, number of entries: 68
--rw-r--r--  2.0 unx      183 b- defN 23-May-16 13:17 cartagen4py/__init__.py
--rw-r--r--  2.0 unx      223 b- defN 24-Feb-27 14:30 cartagen4py/algorithms/__init__.py
--rw-r--r--  2.0 unx      244 b- defN 23-May-15 08:34 cartagen4py/algorithms/buildings/__init__.py
--rw-r--r--  2.0 unx     4579 b- defN 23-Jul-20 15:09 cartagen4py/algorithms/buildings/amalgamation.py
--rw-r--r--  2.0 unx     7791 b- defN 23-Jul-18 08:14 cartagen4py/algorithms/buildings/random_displacement.py
--rw-r--r--  2.0 unx     8144 b- defN 23-May-24 14:53 cartagen4py/algorithms/buildings/simplification.py
--rw-r--r--  2.0 unx    15705 b- defN 23-Jul-10 07:34 cartagen4py/algorithms/buildings/squaring.py
--rw-r--r--  2.0 unx       55 b- defN 23-May-12 12:21 cartagen4py/algorithms/general/__init__.py
--rw-r--r--  2.0 unx    50723 b- defN 24-Jan-08 13:18 cartagen4py/algorithms/general/constraint.py
--rw-r--r--  2.0 unx      170 b- defN 24-Feb-21 14:41 cartagen4py/algorithms/lines/__init__.py
--rw-r--r--  2.0 unx     7242 b- defN 24-Feb-21 14:03 cartagen4py/algorithms/lines/breaks.py
--rw-r--r--  2.0 unx     5307 b- defN 23-Jun-21 09:43 cartagen4py/algorithms/lines/line_simplification.py
--rw-r--r--  2.0 unx     3441 b- defN 24-Feb-27 14:27 cartagen4py/algorithms/lines/line_smoothing.py
--rw-r--r--  2.0 unx      240 b- defN 23-Nov-06 08:37 cartagen4py/algorithms/network/__init__.py
--rw-r--r--  2.0 unx    11054 b- defN 23-Oct-30 08:49 cartagen4py/algorithms/network/branching_crossroads.py
--rw-r--r--  2.0 unx     8821 b- defN 23-Nov-09 10:18 cartagen4py/algorithms/network/dead_ends.py
--rw-r--r--  2.0 unx    15760 b- defN 24-Feb-21 14:00 cartagen4py/algorithms/network/dual_carriageways.py
--rw-r--r--  2.0 unx     5423 b- defN 23-Aug-07 13:47 cartagen4py/algorithms/network/roundabouts.py
--rw-r--r--  2.0 unx      126 b- defN 24-Feb-27 14:33 cartagen4py/algorithms/points/__init__.py
--rw-r--r--  2.0 unx     5350 b- defN 23-Aug-21 16:02 cartagen4py/algorithms/points/point_set_quadtree.py
--rw-r--r--  2.0 unx     7494 b- defN 23-Oct-10 15:04 cartagen4py/algorithms/points/point_set_reduction.py
--rw-r--r--  2.0 unx      366 b- defN 24-Feb-21 14:42 cartagen4py/data_enrichment/__init__.py
--rw-r--r--  2.0 unx      278 b- defN 24-Feb-23 09:06 cartagen4py/data_enrichment/bends.py
--rw-r--r--  2.0 unx    11979 b- defN 23-Oct-10 15:04 cartagen4py/data_enrichment/building_measures.py
--rw-r--r--  2.0 unx     9795 b- defN 24-Feb-27 14:31 cartagen4py/data_enrichment/pastiness.py
--rw-r--r--  2.0 unx    14249 b- defN 23-Oct-30 07:57 cartagen4py/data_enrichment/stroke.py
--rw-r--r--  2.0 unx    13987 b- defN 23-Oct-30 07:57 cartagen4py/data_enrichment/strokeriver.py
--rw-r--r--  2.0 unx      958 b- defN 23-Oct-18 14:50 cartagen4py/data_enrichment/urban_areas.py
--rw-r--r--  2.0 unx      323 b- defN 23-Nov-09 08:06 cartagen4py/data_enrichment/network/__init__.py
--rw-r--r--  2.0 unx    10533 b- defN 23-Oct-31 14:11 cartagen4py/data_enrichment/network/branching_crossroads.py
--rw-r--r--  2.0 unx     7774 b- defN 23-Dec-15 09:40 cartagen4py/data_enrichment/network/dead_ends.py
--rw-r--r--  2.0 unx     3937 b- defN 23-Sep-13 15:43 cartagen4py/data_enrichment/network/dual_carriageways.py
--rw-r--r--  2.0 unx     2038 b- defN 23-Aug-09 09:58 cartagen4py/data_enrichment/network/roundabouts.py
--rw-r--r--  2.0 unx     8547 b- defN 23-Dec-01 14:23 cartagen4py/data_enrichment/network/rural_areas.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-01 13:47 cartagen4py/evaluation/__init__.py
--rw-r--r--  2.0 unx      238 b- defN 23-Mar-01 13:47 cartagen4py/evaluation/constraint_satisfaction.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-01 13:47 cartagen4py/processes/__init__.py
--rw-r--r--  2.0 unx      331 b- defN 23-Nov-13 08:16 cartagen4py/utils/__init__.py
--rw-r--r--  2.0 unx     3766 b- defN 23-Jun-21 15:05 cartagen4py/utils/plot_utils.py
--rw-r--r--  2.0 unx       54 b- defN 23-Oct-18 13:52 cartagen4py/utils/attributes/__init__.py
--rw-r--r--  2.0 unx     1343 b- defN 23-Oct-18 14:35 cartagen4py/utils/attributes/propagation.py
--rw-r--r--  2.0 unx       49 b- defN 23-May-15 08:52 cartagen4py/utils/clustering/__init__.py
--rw-r--r--  2.0 unx        0 b- defN 23-Mar-30 13:41 cartagen4py/utils/clustering/dbscan.py
--rw-r--r--  2.0 unx      347 b- defN 23-Dec-15 09:19 cartagen4py/utils/geometry/__init__.py
--rw-r--r--  2.0 unx     2160 b- defN 23-Aug-28 17:40 cartagen4py/utils/geometry/angle.py
--rw-r--r--  2.0 unx    20148 b- defN 24-Feb-27 14:31 cartagen4py/utils/geometry/dilation.py
--rw-r--r--  2.0 unx      587 b- defN 23-Aug-18 15:53 cartagen4py/utils/geometry/distances.py
--rw-r--r--  2.0 unx     1327 b- defN 23-Mar-21 13:10 cartagen4py/utils/geometry/extent.py
--rw-r--r--  2.0 unx     7856 b- defN 24-Feb-01 17:03 cartagen4py/utils/geometry/line.py
--rw-r--r--  2.0 unx     3167 b- defN 23-May-12 11:54 cartagen4py/utils/geometry/segment.py
--rw-r--r--  2.0 unx    25511 b- defN 24-Feb-21 14:00 cartagen4py/utils/geometry/skeletonization.py
--rw-r--r--  2.0 unx       43 b- defN 23-Nov-13 08:17 cartagen4py/utils/graph/__init__.py
--rw-r--r--  2.0 unx     2281 b- defN 23-Nov-13 08:24 cartagen4py/utils/graph/roads.py
--rw-r--r--  2.0 unx       91 b- defN 23-May-15 08:51 cartagen4py/utils/math/__init__.py
--rw-r--r--  2.0 unx     4468 b- defN 23-Oct-18 14:50 cartagen4py/utils/math/morphology.py
--rw-r--r--  2.0 unx      474 b- defN 23-Jul-25 15:17 cartagen4py/utils/math/vector.py
--rw-r--r--  2.0 unx       91 b- defN 23-Aug-08 12:58 cartagen4py/utils/network/__init__.py
--rw-r--r--  2.0 unx     1441 b- defN 23-Aug-08 14:41 cartagen4py/utils/network/faces.py
--rw-r--r--  2.0 unx     6629 b- defN 24-Jan-17 15:12 cartagen4py/utils/network/roads.py
--rw-r--r--  2.0 unx      106 b- defN 23-May-15 08:50 cartagen4py/utils/partitioning/__init__.py
--rw-r--r--  2.0 unx     2301 b- defN 23-Jul-25 13:07 cartagen4py/utils/partitioning/network.py
--rw-r--r--  2.0 unx      334 b- defN 23-May-15 09:06 cartagen4py/utils/partitioning/quadtree.py
--rw-r--r--  2.0 unx       54 b- defN 23-May-16 08:51 cartagen4py/utils/tessellation/__init__.py
--rw-r--r--  2.0 unx     3721 b- defN 23-May-16 07:42 cartagen4py/utils/tessellation/hexagonal.py
--rw-r--r--  2.0 unx      931 b- defN 24-Feb-27 14:41 cartagen4py-0.2.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Feb-27 14:41 cartagen4py-0.2.9.dist-info/WHEEL
--rw-r--r--  2.0 unx       12 b- defN 24-Feb-27 14:41 cartagen4py-0.2.9.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     6586 b- defN 24-Feb-27 14:41 cartagen4py-0.2.9.dist-info/RECORD
-68 files, 339378 bytes uncompressed, 91469 bytes compressed:  73.0%
+Zip file size: 114020 bytes, number of entries: 70
+-rw-r--r--  2.0 unx      183 b- defN 24-May-24 07:07 cartagen4py/__init__.py
+-rw-r--r--  2.0 unx      223 b- defN 24-May-24 07:07 cartagen4py/algorithms/__init__.py
+-rw-r--r--  2.0 unx      244 b- defN 24-May-24 07:07 cartagen4py/algorithms/buildings/__init__.py
+-rw-r--r--  2.0 unx     4605 b- defN 24-May-24 07:07 cartagen4py/algorithms/buildings/amalgamation.py
+-rw-r--r--  2.0 unx     7791 b- defN 24-May-24 07:07 cartagen4py/algorithms/buildings/random_displacement.py
+-rw-r--r--  2.0 unx     8144 b- defN 24-May-24 07:07 cartagen4py/algorithms/buildings/simplification.py
+-rw-r--r--  2.0 unx    15705 b- defN 24-May-24 07:07 cartagen4py/algorithms/buildings/squaring.py
+-rw-r--r--  2.0 unx       55 b- defN 24-May-24 07:07 cartagen4py/algorithms/general/__init__.py
+-rw-r--r--  2.0 unx    50723 b- defN 24-May-24 07:07 cartagen4py/algorithms/general/constraint.py
+-rw-r--r--  2.0 unx       98 b- defN 24-May-24 07:07 cartagen4py/algorithms/lines/__init__.py
+-rw-r--r--  2.0 unx    15170 b- defN 24-May-24 07:07 cartagen4py/algorithms/lines/bends.py
+-rw-r--r--  2.0 unx     6423 b- defN 24-May-24 07:07 cartagen4py/algorithms/lines/breaks.py
+-rwxr-xr-x  2.0 unx     5307 b- defN 23-Jun-21 09:43 cartagen4py/algorithms/lines/line_simplification.py
+-rwxr-xr-x  2.0 unx     4443 b- defN 24-Mar-05 15:25 cartagen4py/algorithms/lines/line_smoothing.py
+-rw-r--r--  2.0 unx      240 b- defN 24-May-24 07:07 cartagen4py/algorithms/network/__init__.py
+-rw-r--r--  2.0 unx    11053 b- defN 24-May-24 09:03 cartagen4py/algorithms/network/branching_crossroads.py
+-rw-r--r--  2.0 unx     8821 b- defN 24-May-24 07:07 cartagen4py/algorithms/network/dead_ends.py
+-rw-r--r--  2.0 unx    16454 b- defN 24-May-24 09:14 cartagen4py/algorithms/network/dual_carriageways.py
+-rw-r--r--  2.0 unx     5667 b- defN 24-May-24 07:07 cartagen4py/algorithms/network/roundabouts.py
+-rw-r--r--  2.0 unx      126 b- defN 24-May-24 07:07 cartagen4py/algorithms/points/__init__.py
+-rw-r--r--  2.0 unx     5350 b- defN 24-May-24 07:07 cartagen4py/algorithms/points/point_set_quadtree.py
+-rw-r--r--  2.0 unx     7494 b- defN 24-May-24 07:07 cartagen4py/algorithms/points/point_set_reduction.py
+-rw-r--r--  2.0 unx      318 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/__init__.py
+-rwxr-xr-x  2.0 unx     1096 b- defN 24-Mar-05 15:21 cartagen4py/data_enrichment/bends.py
+-rw-r--r--  2.0 unx    11973 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/building_measures.py
+-rw-r--r--  2.0 unx     9795 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/pastiness.py
+-rw-r--r--  2.0 unx    14786 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/stroke.py
+-rw-r--r--  2.0 unx    13987 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/strokeriver.py
+-rw-r--r--  2.0 unx      958 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/urban_areas.py
+-rw-r--r--  2.0 unx      323 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/network/__init__.py
+-rw-r--r--  2.0 unx    10573 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/network/branching_crossroads.py
+-rw-r--r--  2.0 unx     8193 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/network/dead_ends.py
+-rw-r--r--  2.0 unx     5133 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/network/dual_carriageways.py
+-rw-r--r--  2.0 unx     2078 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/network/roundabouts.py
+-rw-r--r--  2.0 unx     8547 b- defN 24-May-24 07:07 cartagen4py/data_enrichment/network/rural_areas.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-24 07:07 cartagen4py/evaluation/__init__.py
+-rw-r--r--  2.0 unx      238 b- defN 24-May-24 07:07 cartagen4py/evaluation/constraint_satisfaction.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-24 07:07 cartagen4py/processes/__init__.py
+-rw-r--r--  2.0 unx      331 b- defN 24-May-24 07:07 cartagen4py/utils/__init__.py
+-rw-r--r--  2.0 unx     3766 b- defN 24-May-24 07:07 cartagen4py/utils/plot_utils.py
+-rw-r--r--  2.0 unx       54 b- defN 24-May-24 07:07 cartagen4py/utils/attributes/__init__.py
+-rw-r--r--  2.0 unx     1343 b- defN 24-May-24 07:07 cartagen4py/utils/attributes/propagation.py
+-rw-r--r--  2.0 unx       49 b- defN 24-May-24 07:07 cartagen4py/utils/clustering/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-May-24 07:07 cartagen4py/utils/clustering/dbscan.py
+-rw-r--r--  2.0 unx      394 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/__init__.py
+-rw-r--r--  2.0 unx     2399 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/angle.py
+-rw-r--r--  2.0 unx     5844 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/bends.py
+-rw-r--r--  2.0 unx    20148 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/dilation.py
+-rw-r--r--  2.0 unx      587 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/distances.py
+-rw-r--r--  2.0 unx     1327 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/extent.py
+-rw-r--r--  2.0 unx    22287 b- defN 24-May-24 08:47 cartagen4py/utils/geometry/line.py
+-rw-r--r--  2.0 unx     3167 b- defN 24-May-24 07:07 cartagen4py/utils/geometry/segment.py
+-rw-r--r--  2.0 unx    26190 b- defN 24-May-24 08:33 cartagen4py/utils/geometry/skeletonization.py
+-rw-r--r--  2.0 unx       43 b- defN 24-May-24 07:07 cartagen4py/utils/graph/__init__.py
+-rw-r--r--  2.0 unx     2281 b- defN 24-May-24 07:07 cartagen4py/utils/graph/roads.py
+-rw-r--r--  2.0 unx       91 b- defN 24-May-24 07:07 cartagen4py/utils/math/__init__.py
+-rw-r--r--  2.0 unx     4468 b- defN 24-May-24 07:07 cartagen4py/utils/math/morphology.py
+-rw-r--r--  2.0 unx     2947 b- defN 24-May-24 07:07 cartagen4py/utils/math/vector.py
+-rw-r--r--  2.0 unx       91 b- defN 24-May-24 07:07 cartagen4py/utils/network/__init__.py
+-rw-r--r--  2.0 unx     1441 b- defN 24-May-24 07:07 cartagen4py/utils/network/faces.py
+-rw-r--r--  2.0 unx     6629 b- defN 24-May-24 07:07 cartagen4py/utils/network/roads.py
+-rw-r--r--  2.0 unx      106 b- defN 24-May-24 07:07 cartagen4py/utils/partitioning/__init__.py
+-rw-r--r--  2.0 unx     2301 b- defN 24-May-24 07:07 cartagen4py/utils/partitioning/network.py
+-rw-r--r--  2.0 unx      334 b- defN 24-May-24 07:07 cartagen4py/utils/partitioning/quadtree.py
+-rw-r--r--  2.0 unx       54 b- defN 24-May-24 07:07 cartagen4py/utils/tessellation/__init__.py
+-rw-r--r--  2.0 unx     3721 b- defN 24-May-24 07:07 cartagen4py/utils/tessellation/hexagonal.py
+-rw-r--r--  2.0 unx      932 b- defN 24-May-24 09:20 cartagen4py-0.3.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-24 09:20 cartagen4py-0.3.dist-info/WHEEL
+-rw-r--r--  2.0 unx       12 b- defN 24-May-24 09:20 cartagen4py-0.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6767 b- defN 24-May-24 09:20 cartagen4py-0.3.dist-info/RECORD
+70 files, 382513 bytes uncompressed, 102952 bytes compressed:  73.1%
```

## zipnote {}

```diff
@@ -24,14 +24,17 @@
 
 Filename: cartagen4py/algorithms/general/constraint.py
 Comment: 
 
 Filename: cartagen4py/algorithms/lines/__init__.py
 Comment: 
 
+Filename: cartagen4py/algorithms/lines/bends.py
+Comment: 
+
 Filename: cartagen4py/algorithms/lines/breaks.py
 Comment: 
 
 Filename: cartagen4py/algorithms/lines/line_simplification.py
 Comment: 
 
 Filename: cartagen4py/algorithms/lines/line_smoothing.py
@@ -129,14 +132,17 @@
 
 Filename: cartagen4py/utils/geometry/__init__.py
 Comment: 
 
 Filename: cartagen4py/utils/geometry/angle.py
 Comment: 
 
+Filename: cartagen4py/utils/geometry/bends.py
+Comment: 
+
 Filename: cartagen4py/utils/geometry/dilation.py
 Comment: 
 
 Filename: cartagen4py/utils/geometry/distances.py
 Comment: 
 
 Filename: cartagen4py/utils/geometry/extent.py
@@ -186,20 +192,20 @@
 
 Filename: cartagen4py/utils/tessellation/__init__.py
 Comment: 
 
 Filename: cartagen4py/utils/tessellation/hexagonal.py
 Comment: 
 
-Filename: cartagen4py-0.2.9.dist-info/METADATA
+Filename: cartagen4py-0.3.dist-info/METADATA
 Comment: 
 
-Filename: cartagen4py-0.2.9.dist-info/WHEEL
+Filename: cartagen4py-0.3.dist-info/WHEEL
 Comment: 
 
-Filename: cartagen4py-0.2.9.dist-info/top_level.txt
+Filename: cartagen4py-0.3.dist-info/top_level.txt
 Comment: 
 
-Filename: cartagen4py-0.2.9.dist-info/RECORD
+Filename: cartagen4py-0.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## cartagen4py/algorithms/buildings/amalgamation.py

```diff
@@ -59,15 +59,15 @@
             nextEdge = segment_list[i+1]
         
         # we compute the angle between previousEdge and nextEdge
         angle = abs(previousEdge.orientation() - nextEdge.orientation())
         if(angle < math.pi/4):
             # offset case
             # create a vector from the edge
-            vector = Vector2D(nextEdge)
+            vector = Vector2D.from_segment(nextEdge)
             # keep last vertex of final_coords in memory
             last_vertex = final_coords[len(final_coords)-1]
             # remove the last two vertices
             l_element = len(final_coords)-2
             final_coords = final_coords[:l_element]
             # get the antepenultimate vertex of final_coords (which is now the last)
             antepenultimate = final_coords[len(final_coords)-1]
@@ -87,15 +87,15 @@
             final_coords = final_coords[:l_element]
             # add intersection and then lastVertex to the list of vertices
             final_coords.append(intersection.coords[0])
             final_coords.append(last_vertex)
         else:
             # intrusion or protrusion case
             # create a vector from the edge
-            vector = Vector2D(nextEdge)
+            vector = Vector2D.from_segment(nextEdge)
             # remove the last two vertices
             l_element = len(final_coords)-2
             final_coords = final_coords[:l_element]
             # get the antepenultimate vertex of final_coords (which is now the last)
             antepenultimate = final_coords[len(final_coords)-1]
             # translate this vertex with the vector
             translated = vector.translate(Point(antepenultimate))
```

## cartagen4py/algorithms/lines/__init__.py

```diff
@@ -1,3 +1,2 @@
-from cartagen4py.algorithms.lines.breaks import *
-from cartagen4py.algorithms.lines.line_simplification import *
-from cartagen4py.algorithms.lines.line_smoothing import *
+from cartagen4py.algorithms.lines.bends import *
+from cartagen4py.algorithms.lines.breaks import *
```

## cartagen4py/algorithms/lines/breaks.py

```diff
@@ -1,52 +1,28 @@
 import geopandas as gpd
 import shapely, numpy, networkx
 
-from cartagen4py.algorithms.lines.line_smoothing import *
 from cartagen4py.utils.geometry.angle import *
 from cartagen4py.utils.geometry.dilation import *
 from cartagen4py.utils.geometry.line import *
 from cartagen4py.utils.geometry.skeletonization import *
 
 def max_break(line, offset, exaggeration=1.0):
     """
     Apply the max break algorithm (Mustière, 2001) to a shapely LineString.
     It first finds the side of the road bend and dilates the line accordingly.
     Returns the dilated shapely LineString.
     The exagerration is a multiplication factor that amplifies the dilatation.
     """
 
-    # Get the bend side
-    def __get_bend_side(coords):
-        # The total angle of the bend
-        total = 0
-
-        # Get the start point of the bend
-        start = shapely.Point(coords[0])
-
-        # Loop through the nodes of the linestring, starting on the seconde node
-        for i in range(1, len(coords) - 1):
-            # Get the current and the next node coordinates
-            c1 = coords[i]
-            c2 = coords[i + 1]
-
-            # Add to the total the angle between the starting point and those two nodes
-            total += angle_3_pts(start, shapely.Point(c2), shapely.Point(c1))
-
-        # If the total is above 0, the bend is left sided, otherwise it right sided
-        if total > 0:
-            return 'left'
-        else:
-            return 'right'
-
     # Get the side of the bend
-    side = __get_bend_side(list(line.coords))
+    side = get_bend_side(line)
 
     # Change the offset in case of left sided bend
-    if side == 'left':
+    if side == 'right':
         offset = - offset
 
     # Dilate the bend
     dilated = offset_curve(line, offset*exaggeration, cap_style='flat', quad_segs=8)
     
     return shapely.LineString(dilated[0])
 
@@ -72,17 +48,18 @@
         groups = merge_connected_parts(parts)
 
         return groups
 
     # Get the nodes of the linestring
     coordinates = list(line.coords)
     start, end = coordinates[0], coordinates[-1]
+    base = shapely.LineString([start, end])
 
     # Add the center of the line formed by the last and first node of the list
-    entry = shapely.LineString([start, end]).centroid
+    entry = base.interpolate(base.length / 2)
     middle = entry.coords[0]
 
     coordinates.append(middle)
 
     # Create the polygon from the linestring nodes
     polygon = shapely.Polygon(coordinates)
```

## cartagen4py/algorithms/lines/line_smoothing.py

```diff
@@ -1,96 +1,115 @@
 # This file contains line smoothing algorithms
 
 from shapely.geometry import LineString, Point
 from math import pi, sqrt, exp
 from cartagen4py.utils.geometry.line import densify_geometry, to_2d, get_index_of_nearest_vertex
 
-def gaussian_smoothing(line, sigma, threshold):
+def gaussian_smoothing(line, sigma, sample, densify=True):
     """
     Compute the gaussian smoothing of a set of a LineString.
     Parameters
     ----------
     line : shapely LineString
         The line to smooth.
     sigma : float
         Gaussian filter strength.
-    threshold : int
-        Amount of nodes to add during the subsampling phase.
+    sample : int
+        The length in meter between each nodes after resampling the line.
+    densify : boolean optional
+        Whether the resulting line should keep the new node density. Default to True.
     """
+    # First resample the line, making sure there is a maximum distance between two consecutive vertices
+    resampled = densify_geometry(line, sample)
 
-    # first resample the line, making sure there is a maximum distance between two consecutive vertices
-    resampled = densify_geometry(line, threshold)
-
-    interval = round(4 * sigma / threshold)
-    # if the interval is longer than the input line, we change the interval
-    if(interval >= len(resampled.coords)):
+    # Calculate the interval (number of vertex to take into consideration when smoothing)
+    interval = round(4 * sigma / sample)
+    # If the interval is longer than the input line, we change the interval and recalculate the sigma
+    if interval >= len(resampled.coords):
         interval = len(resampled.coords) - 1
-        sigma = interval * threshold / 4
+        sigma = interval * sample / 4
     
-    # compute gaussian coefficients
+    # Compute gaussian coefficients
     c2 = -1.0 / (2.0 * sigma * sigma)
     c1 = 1.0 / (sigma * sqrt(2.0 * pi))
-    # compute gassian weights and their sum
+
+    # Compute the gaussian weights and their sum
     weights = []
     total = 0
-    for k in range (0,interval+1):
-        weight = c1 * exp(c2*k*k)
+    for k in range (0, interval + 1):
+        weight = c1 * exp(c2 * k * k)
         weights.append(weight)
         total += weight
-        if k>0:
+        if k > 0:
             total += weight
     
-    # extend the line at its first and last points with central inversion
-    extended = __extend(resampled,interval)
+    # Extend the line at its first and last points with central inversion
+    extended = __extend(resampled, interval)
 
     smoothed_coords = []
-    for i in range(0,len(resampled.coords)):
-        x = 0
-        y = 0
-        for k in range(-interval,interval+1):
-            p1 = extended.coords[i-k+interval]
-            x += weights[abs(k)]*p1[0] / total
-            y += weights[abs(k)]*p1[1] / total
+    for i in range(0, len(resampled.coords)):
+        x, y = 0, 0
+        for k in range(-interval , interval + 1):
+            p1 = extended.coords[i - k + interval]
+            x += weights[abs(k)] * p1[0] / total
+            y += weights[abs(k)] * p1[1] / total
         smoothed_coords.append((x,y))
-    
-    # only return the points matching the input points in the resulting filtered line
-    final_coords = []
-    for point in line.coords:
-        # get the index of point in resampled
-        index = get_index_of_nearest_vertex(resampled, Point(to_2d(point[0], point[1], 0)))
-        # check the distance to the line
-        dist = line.distance(Point(smoothed_coords[index]))
-        if index < 6 and dist > (threshold * 3):
-            final_coords.append(point)
-        else:
-            final_coords.append(smoothed_coords[index])
-            resampled = LineString(list(resampled.coords).pop(index))
-    
-    return LineString(final_coords)
+
+    if densify:
+        return LineString(smoothed_coords)
+    else:
+        # Only return the points matching the input points in the resulting filtered line
+        final_coords = []
+        # Stores for index of already treated vertices
+        done = []
+        # Loop through initial vertices
+        for point in list(line.coords):
+            # Set the distance to infinite
+            distance = float("inf")
+            nearest = None
+            # Loop through smoothed coordinates
+            for i in range(len(smoothed_coords)):
+                # Check that the index has not been already added
+                if i not in done:
+                    # Calculate distance from the point
+                    d = Point(smoothed_coords[i]).distance(Point(point))
+                    if d < distance:
+                        # Update distance and nearest index if below existing
+                        distance, nearest = d, i
+
+            # If a nearest point has been found, add it to the new line
+            if nearest is not None:
+                final_coords.append(smoothed_coords[nearest])
+                # Add the index as treated already
+                done.append(nearest)
+            else:
+                final_coords.append(point)
+
+        return LineString(final_coords)
 
 # Extend the given set of points at its first and last points of k points using central inversion.
 def __extend(line, interval):
-    nb_vert = len(line.coords)
-    first = line.coords[0]
-    last = line.coords[nb_vert-1]
-    new_coords = []
-    for i in range(0,nb_vert+2*interval):
-        position = i - interval
-        if(i < interval):
-            p = line.coords[position]
-            new_coords.append(__central_inversion(first,p))
-        else:
-            if(position >= nb_vert):
-                beyond = position - nb_vert +1
-                p = line.coords[nb_vert-1-beyond]
-                new_coords.append(__central_inversion(last,p))
-            else:
-                p = line.coords[position]
-                new_coords.append(p)
+    # Get the coordinates of the vertices
+    coords = list(line.coords)
+    # Get the first and last vertex
+    first, last = coords[0], coords[-1]
+
+    # Get the index of the penultimate vertex
+    # -2 is to avoid taking the last vertex
+    pen = len(coords) - 2
+
+    # Set the start of the line as the central inversion of n first vertices (n = interval)
+    result = [__central_inversion(first, coords[i]) for i in range(interval, 0, -1)]
+
+    # Add the full line as the middle part of the line
+    result.extend(coords)
+
+    # Add the end of the line as the central inversion of n last vertices (n = interval)
+    result.extend([__central_inversion(last, coords[i]) for i in range(pen, pen - interval, -1)])
 
-    return LineString(new_coords)
+    return LineString(result)
 
 # Compute the central inversion of a position. origin is the center of symmetry and p is the point to inverse.
 def __central_inversion(origin, p):
     x = 2 * origin[0] - p[0]
     y = 2 * origin[1] - p[1]
     return (x,y)
```

## cartagen4py/algorithms/network/branching_crossroads.py

```diff
@@ -1,30 +1,30 @@
 import geopandas as gpd
 import shapely
 from shapely.ops import unary_union, linemerge
 
 from cartagen4py.utils.network import *
 from cartagen4py.utils.geometry.line import *
 
-def collapse_branching_crossroads(roads, crossroads, roundabouts=None, maximum_area=None,):
+def collapse_branching_crossroads(roads, crossroads, roundabouts=None, maximum_area=None):
     """
     Collapse detected branching crossroads below the provided area to a point and return the new network.
     Parameters
     ----------
     roads : geopandas GeoDataFrame of LineStrings.
         The road network where branching crossroads will be collapsed.
     crossroads : geopandas GeoDataFrame of Polygons.
         The polygons representing the faces of the network detected as branching crossroads.
-    maximum_area : float, optional.
-        The area, in square meter, below which branching crossroads are collapsed.
-        Default value is set to None. 
     roundabouts : geopandas GeoDataFrame of Polygons, optional.
         The polygons representing the faces of the network detected as roundabouts.
         Provide a better collapsing when provided.
         Default value is set to None.
+    maximum_area : float, optional.
+        The area, in square meter, below which branching crossroads are collapsed.
+        Default value is set to None. 
     """
 
     # Retrieve crs for output
     crs = roads.crs
 
     # Convert geodataframe to list of dicts
     roads = roads.to_dict('records')
```

## cartagen4py/algorithms/network/dual_carriageways.py

```diff
@@ -1,18 +1,29 @@
 import shapely, numpy
 import geopandas as gpd
 
 from cartagen4py.utils.attributes import *
 from cartagen4py.utils.geometry import *
 from cartagen4py.utils.network import *
 
-def collapse_dual_carriageways(roads, carriageways, distance_douglas_peucker=3, propagate_attributes=None):
+def collapse_dual_carriageways(roads, carriageways, sigma=None, propagate_attributes=None):
     """
-    Collapse dual carriageways using the polygon skeleton made from a Delaunay Triangulation
-    TODO: Handle carriageways connected by only one point.
+    Collapse dual carriageways using the polygon skeleton made from a Delaunay Triangulation.
+    Parameters
+    ----------
+    roads : geopandas GeoDataFrame of LineStrings.
+        The road network where dual carriageways will be collapsed.
+    carriageways : geopandas GeoDataFrame of Polygons.
+        The polygons representing the faces of the network detected as dual carriageways.
+    sigma : float, optional.
+        If not None, apply a gaussian smoothing to the collapsed dual carriageways to avoid jagged lines that can be created during the TIN skeleton creation.
+        Default value is set to None which doesn't apply any smoothing.
+    propagate_attributes : list of str, optional.
+        Propagate the provided list of column name to the resulting network. The propagated attribute is the one from the longest line.
+        Default value is set to None. 
     """
     # Retrieve crs for output
     crs = roads.crs
 
     # Convert geodataframe to list of dicts
     roads = roads.to_dict('records')
     carriageways = carriageways.to_dict('records')
@@ -153,20 +164,19 @@
                         incoming.append({ **attributes, **{"geometry": egeom} })
                     else:
                         incoming.append({ "geometry": egeom })
 
             # Calculate the skeleton
             skeleton = SkeletonTIN(polygon)
             skeleton.add_incoming_lines(incoming)
-            skeleton.create_network(distance=distance_douglas_peucker)
-            skeleton.blend(attributes)
-
+            skeleton.create_network()
+            skeleton.blend(attributes, sigma=sigma)
             skeletons.append(skeleton)
-
-            # # Storing the original geometries of the crossroad
+            
+            # Storing the original geometries of the crossroad
             originals.extend(crossroad.original)
 
         else:
             skeletons.append(None)
 
     # Here, carriageways connected by their short sides are treated
     # --------------------------------------------------------------
```

## cartagen4py/algorithms/network/roundabouts.py

```diff
@@ -5,18 +5,21 @@
 from cartagen4py.utils.network import *
 
 def collapse_roundabouts(roads, roundabouts, crossroads=None, maximum_diameter=None):
     """
     Collapse detected roundabouts below the provided diameter to a point and return the new network.
     Parameters
     ----------
-    network : geopandas GeoDataFrame of LineStrings.
+    network : geopandas GeoDataFrame of LineStrings
         The road network where roundabouts will be collapsed.
-    roundabouts : geopandas GeoDataFrame of Polygons.
+    roundabouts : geopandas GeoDataFrame of Polygons
         The polygons representing the faces of the network detected as roundabouts.
+    crossroads : geopandas GeoDataFrame of Polygons, optional
+        The polygons representing the faces of the network detected as branching crossroads. This
+        allows incoming branching crossroads on roundabouts to be collapsed as well. 
     maximum_diameter : float, optional.
         The diameter, in meter, below which roundabouts are collapsed.
         Default value is set to None. 
     """
 
     # Retrieve crs for output
     crs = roads.crs
```

## cartagen4py/data_enrichment/__init__.py

```diff
@@ -1,7 +1,6 @@
-from cartagen4py.data_enrichment.bends import *
 from cartagen4py.data_enrichment.building_measures import *
 from cartagen4py.data_enrichment.urban_areas import *
 from cartagen4py.data_enrichment.pastiness import *
 from cartagen4py.data_enrichment.stroke import *
 from cartagen4py.data_enrichment.strokeriver import *
 from cartagen4py.data_enrichment.network import *
```

## cartagen4py/data_enrichment/bends.py

```diff
@@ -1,13 +1,36 @@
 import geopandas as gpd
 import shapely
 
 from cartagen4py.algorithms.lines.line_smoothing import *
+from cartagen4py.utils.geometry.angle import *
+from cartagen4py.utils.geometry.line import *
+
+from test_functions import *
 
 def detect_bends(line, sigma, threshold):
     """
     Detect bends from a given LineString.
     """
 
-    smoothed = gaussian_smoothing(line, sigma, threshold)
+    # Create the gaussian smoothed line
+    smoothed = gaussian_smoothing(line, sigma, threshold, densify=False)
+
+    # Get inflexion points indexes
+    indexes = inflexion_points(smoothed)
+
+    vertices = list(line.coords)
+
+    current = []
+    lines = []
+    for i, vertex in enumerate(vertices):
+        current.append(vertex)
+        if i in indexes:
+            lines.append({'bend': get_bend_side(shapely.LineString(current)), 'geometry': shapely.LineString(current)})
+            current = [vertex]
+
+    lines.append({'bend': get_bend_side(shapely.LineString(current)), 'geometry': shapely.LineString(current)})
+    
+    make_gdf([{'geometry': shapely.Point(list(smoothed.coords)[x])} for x in indexes], 'inflexion')
+    make_gdf(lines, 'lines')
 
     return smoothed
```

## cartagen4py/data_enrichment/building_measures.py

```diff
@@ -1,10 +1,10 @@
 # This file contains measures on buildings that can be used in constraints or inside algorithms.
 from cartagen4py.utils.geometry.segment import *
-from cartagen4py.utils.geometry.line import to_2d, get_nearest_vertex, densify_geometry
+from cartagen4py.utils.geometry.line import to_2d, get_nearest_vertex, resample_line
 from cartagen4py.utils.geometry.angle import angle_3_pts, angle_to_zero_pi, angle_between_2lines
 from shapely.ops import nearest_points, transform, triangulate, substring, split
 from shapely.geometry import MultiPolygon, MultiPoint, Polygon
 from math import pi
 
 def building_min_width(building):
     min_width = building.length
@@ -236,15 +236,15 @@
         ante_pt = None
         prev_pt = None
         initial_pt = road.coords[0]
         nb_pts_itr = 0
         # simplify the line to get sharper angles
         simp_road = road.simplify(1.0)
         # densify the simplified road
-        dense_road = densify_geometry(simp_road, 10.0)
+        dense_road = resample_line(simp_road, 10.0)
         for pt in dense_road.coords:
             if nb_pts_itr > 3:
                 # add the angle between [0,Pi/2] to the cumulated angle
                 angle = angle_to_zero_pi(angle_3_pts(Point(ante_pt), Point(prev_pt), Point(pt)))
                 if angle > pi / 2:
                     angle = abs(angle - pi)
                 cumulated_angle += angle
```

## cartagen4py/data_enrichment/stroke.py

```diff
@@ -1,9 +1,9 @@
 import math
-
+from itertools import combinations
 import numpy as np
 from shapely.geometry import LineString, Point, MultiLineString
 from shapely import ops
 import geopandas as gpd
 import networkx as nx
 
 from cartagen4py.utils.geometry.angle import angle_3_pts
@@ -15,16 +15,16 @@
         self.root=root
         self.features = []
         self.features.append(root)
         self.id = Stroke.COUNTER
         Stroke.COUNTER += 1
     
     def is_good_continuity(temp_geom, geom_foll,deviatAngle, deviatSum):
-        angleThresh = deviatAngle / 180.0 * math.pi;
-        sumThresh = deviatAngle / 180.0 * math.pi;
+        angleThresh = deviatAngle / 180.0 * math.pi
+        sumThresh = deviatAngle / 180.0 * math.pi
     
         coord_ini1 = temp_geom["geom"].coords[0]
         coord_fin1 = temp_geom["geom"].coords[-1]
         coord_ini2 = geom_foll["geom"].coords[0]
         coord_fin2 = geom_foll["geom"].coords[-1]
         coord_inter = None
         
@@ -96,15 +96,15 @@
           if (angleDiff > math.pi) :
             angleTotalDiff = abs(angleDiff - 2 * math.pi)
           else:
             angleTotalDiff = angleDiff
           #il y a bonne continuité si l'angle est < 45° et la différence desangles < à 30°
           if (((inter_angle < (-angleThresh)) or (inter_angle > angleThresh)) and (angleTotalDiff < sumThresh)):
             return 2 * angleTotalDiff
-          return -1.0;
+          return -1.0
         #case where geomFoll has 2 vertices
         elif (v2g2 is None):
           angleTotalDiff = 0.0
           #on calcule angleGeom2
           angleGeom1 = angle_3_pts(v2g1, v1g1,  Point(coord_inter))
           #on calcule l'écart entre les angles
           angleDiff = max(angleGeom1, inter_angle)- min(angleGeom1, inter_angle)
@@ -150,126 +150,133 @@
                 for a in loopFoll:
                     # get the value of a for attribute
                     valueA = a[attribute]
                     if value != valueA:
                         # remove 'a' from the followers set
                         followers.remove(a)
 
-    def filterFollowers(self,arc, followers):
+    def filterFollowers(self, arc, followers):
         loopFoll = []
         #loop on the followers to filter them
         loopFoll+=followers
         for a in loopFoll:
             if (a==arc):
                 #remove it from the set
-                followers.remove(a);
-                continue;
+                followers.remove(a)
+                continue
              #check that a does not belong to another stroke
             if (a in self.network.groupedFeatures):
                   #remove it from the set
-                  followers.remove(a);
-                  continue;
+                  followers.remove(a)
+                  continue
                   #check if it belongs to this stroke
             if (a in self.features):
              #remove it from the set
-                 followers.remove(a);
-                 continue;
+                 followers.remove(a)
+                 continue
             #check if it belongs to the network
             if (not a in self.network.features) :
-            #// remove it from the set
-                followers.remove(a);
+            # remove it from the set
+                followers.remove(a)
       
                         
-    def chooseNextSegment(self,arc, followers, attributeNames,deviatAngle, deviatSum):
+    def chooseNextSegment(self,arc, followers, attributeNames, deviatAngle, deviatSum):
         #first, if it's a node of degree two
         if (len(followers) == 1) :
             follower = next(iter(followers))
             if (not follower in self.features):#COR
-                return follower;
+                return follower
             return None
-        #then, filter the followers
+        # then, filter the followers
         self.filterFollowers(arc, followers)
         if (len(followers) == 0) :
             return None
-        #then, filter the followers from the attributeNames
+        # then, filter the followers from the attributeNames
         Stroke.attribute_filter(arc, followers, attributeNames)
         if (len(followers) == 0) :
             return None
         continuity,bestSegment = True, None
-        #Loop on the followers to choose the best continuity
+        # Loop on the followers to choose the best continuity
         minDiff = math.pi
         for follower in followers:
-            #get the continuity difference with this follower
+            # get the continuity difference with this follower
             diffContinuity = Stroke.is_good_continuity(arc, follower, deviatAngle, deviatSum) 
             if (diffContinuity > -1.0) :
-                  continuity = True;
+                  continuity = True
                   if (diffContinuity < minDiff) :
-                      #this is the current best continuity update the difference
-                      minDiff = diffContinuity;
-                      #change the bestSegment
-                      bestSegment = follower;
+                      # this is the current best continuity update the difference
+                      minDiff = diffContinuity
+                      # change the bestSegment
+                      bestSegment = follower
+        
+        # final verification: if we found a continuous follower, check if there is a better continuity between the followers themselves
         if (((continuity) and not bestSegment in self.network.groupedFeatures) or (minDiff < deviatAngle)) :
-            return bestSegment;
+            for pair in combinations(followers, 2):
+                diffContinuity = Stroke.is_good_continuity(pair[0], pair[1], deviatAngle, deviatSum)
+                if (diffContinuity > -1.0 and diffContinuity < minDiff) :
+                    # there is a pair of followers with a better continuity so we stop the stroke here and return None
+                    return None
+            return bestSegment
         return None
 
   
-    def one_side_stroke(self, side, attributeNames,deviatAngle,deviatSum):
-        #get the following network segments of the root of this stroke
+    def one_side_stroke(self, side, attributeNames, deviatAngle, deviatSum):
+        # get the following network segments of the root of this stroke
         node =None        
         node = self.root["geom"].coords[side]
         if (node is None):
-            return;
+            return
         followers =[]
         followers+=self.network.dic_neighbours[self.root["geom"].coords[side]]
         if self.root in followers:
             followers.remove(self.root)
         next1 = self.root
         continuity = True
         self.network.groupedFeatures.append(next1)
         while (continuity) :
-                #get the best candidate among the followers (the one with best continuity)
+                # get the best candidate among the followers (the one with best continuity)
                 best = self.chooseNextSegment(next1, followers, attributeNames,deviatAngle, deviatSum)
                 if (best is None):
                     break
-                #      // add this to the 2 sets (the network one and the stroke one)
+                # add this to the 2 sets (the network one and the stroke one)
                 if not side:
                     self.features.insert(0, best)
                 else:
                     self.features.append(best)
                 self.network.groupedFeatures.append(best) 
-                #get the followers of 'best'
+                # get the followers of 'best'
                 followers=[]
-                nextNode = best["geom"].coords[0];
+                nextNode = best["geom"].coords[0]
                 
                 side2=0
                 if (node==nextNode):
-                    nextNode = best["geom"].coords[-1];
+                    nextNode = best["geom"].coords[-1]
                     side2=-1 
                     
                 followers+=self.network.dic_neighbours[best["geom"].coords[side2]]#AC
                 followers.remove(best)
-                #if there is no follower, break
+                # if there is no follower, break
                 if (len(followers)== 0):
-                    break;
-                #update the 'next' segment with 'best'
-                next1 = best;
+                    break
+                # update the 'next' segment with 'best'
+                next1 = best
                 node = nextNode;         
     def __str__(self):
         liste=""
         for elem in self.features: 
             liste+=str(elem["id"])
             liste+=","
         return liste
     
 class StrokeNetwork:
     def __init__(self,features):
             #Initialisation from a list of shapely geometry with the correct attributes
           self.features = features
           self.groupedFeatures = []
-          self.id = 0;
+          self.id = 0
           self.strokes = []
           
     def __init__(self, shapefile, attributeNames):
         #Initialisation from a geopanda dataframe and the liste of desired attribute name
         features=[]
         for idx in shapefile.index: 
             elem={}
@@ -278,15 +285,15 @@
 
             for attr in attributeNames:
                 elem[attr]=getattr(shapefile,attr)[idx]
                 #setattr(elem,attr,)
             features+=[elem]
         self.features = features
         self.groupedFeatures = []
-        self.id = 0;
+        self.id = 0
         self.strokes = []
         self.dic_neighbours=StrokeNetwork.compute_neighbours(features)
         
     def compute_neighbours(network):
         ntx=nx.DiGraph()
         dic_neighbours={}
         for edge in network:
@@ -309,19 +316,19 @@
         for obj in self.features :
                 #test if the feature has already been treated
                 if obj in self.groupedFeatures :
                     continue
                 #build a new stroke object
                 stroke = Stroke(self, obj)
                 #// build the stroke on the initial side
-                stroke.one_side_stroke(0, attributeNames, deviatAngle, deviatSum);
+                stroke.one_side_stroke(0, attributeNames, deviatAngle, deviatSum)
                 #// build the stroke on the final side
-                stroke.one_side_stroke(-1, attributeNames, deviatAngle, deviatSum);
+                stroke.one_side_stroke(-1, attributeNames, deviatAngle, deviatSum)
                 #// add the stroke to the strokes set
-                self.strokes.append(stroke);
+                self.strokes.append(stroke)
     
     def reconstruct_strokes(self):
         strokes=self.strokes
         array = []
         for i, stroke in enumerate(strokes):
             listline=[]
             section=""
```

## cartagen4py/data_enrichment/network/branching_crossroads.py

```diff
@@ -35,18 +35,19 @@
         Default value is set to 10.0.
     allow_single_4degree_node : boolean optional
         If set to True, allow one and only one node to have a degree of 4.
         Default value set to False.
     """
 
     crs = roads.crs
+    roads = roads.to_dict('records')
 
     network = []
-    for road in roads.geometry:
-        network.append(road)
+    for road in roads:
+        network.append(road['geometry'])
 
     faces = calculate_network_faces(network, convex_hull=False)
     tree = shapely.STRtree(network)
 
     crossroads = []
     index = 0
     for face in faces:
```

## cartagen4py/data_enrichment/network/dead_ends.py

```diff
@@ -1,15 +1,25 @@
 import shapely
 import geopandas as gpd
 from cartagen4py.utils.partitioning import *
 from cartagen4py.utils.network import *
 
 def detect_dead_ends(roads, outside_faces=True):
     """
-    This function detects dead ends inside a road network and returns their geometries.
+    This function detects dead ends inside a road network.
+    Returns the roads detected as dead-ends with attributes.
+    Return None if none were found.
+    Parameters
+    ----------
+    roads : geopandas GeoDataFrame of LineStrings
+        The road network to analyze.
+    importance : str optional.
+        The attribute name of the data on which road importance is based.
+        Default value is set to None which means every road is taken for the network face calculation.
+    value : int optional.
     """
 
     crs = roads.crs
     roads = roads.to_dict('records')
 
     network = []
     for road in roads:
```

## cartagen4py/data_enrichment/network/dual_carriageways.py

```diff
@@ -2,59 +2,77 @@
 import numpy as np
 import shapely
 
 from cartagen4py.utils.partitioning import *
 from cartagen4py.utils.network import *
 
 def detect_dual_carriageways(
-        network, importance=None, value=None,
+        roads, importance=None, value=None,
         concavity=0.85, elongation=6.0, compactness=0.12,
         area=60000.0, width=20.0, huber=16
     ):
     """
-    Detect dual carriageways and return road separators.
+    Detect dual carriageways and return road separators. Dual carriageways are derived from the network faces.
     Return None if none were found.
     Parameters
     ----------
-    network : geopandas GeoDataFrame of LineStrings
+    roads : geopandas GeoDataFrame of LineStrings
         The road network to analyze.
     importance : str optional.
         The attribute name of the data on which road importance is based.
         Default value is set to None which means every road is taken for the network face calculation.
     value : int optional.
-        The maximum value of the importance attribute. Roads with an importance higher than this value will not be taken.
+        Maximum value of the importance attribute. Roads with an importance higher than this value will not be taken.
         Default value is set to None.
+    concavity : float optional.
+        Minimum concavity above which the face is a dual carriageway. It represents the factor between the polygon surface and its convex hull surface.
+        Default value is set to 0.85.
+    elongation : float optional.
+        Minimum elongation above which the face is a dual carriageway. It represents the ratio between the length and the width of the minimum rotated rectangle containing the polygon.
+        Default value is set to 6.0.
+    compactness : float optional.
+        Maximum compactness below which the face is a dual carriageway. (4*pi*area/perimeter^2)
+        Default value is set to 0.12.
+    area : float optional.
+        Area factor to detect very long motorways. Do not change if you don't know what you are doing.
+        Default value is set to 60000.0.
+    width : float optional.
+        Minimum width above which the face is a dual carriageway. It represents the width of the minimum rotated rectangle containing the polygon.
+        Default value is set to 20.0.
+    huber : int optional.
+        Huber width for long motorways. Do not change.
+        Default value is set to 16.
     """
-    crs = network.crs
+    crs = roads.crs
 
-    network = network.to_dict('records')
+    roads = roads.to_dict('records')
 
     if (importance is not None and value is None) or (importance is None and value is not None):
         raise Exception("Provide both arguments (importance, value) or none.")
 
     attribute = False
     if importance is not None and value is not None:
         attribute = True
 
-    roads = []
-    for road in network:
+    network = []
+    for road in roads:
         if attribute:
             if int(road[importance]) <= value:
-                roads.append(road['geometry'])
+                network.append(road['geometry'])
         else:
-            roads.append(road['geometry'])
+            network.append(road['geometry'])
 
-    faces = calculate_network_faces(roads, convex_hull=False)
-    tree = shapely.STRtree(roads)
+    faces = calculate_network_faces(network, convex_hull=False)
+    tree = shapely.STRtree(network)
 
     separators = []
     index = 0
     for face in faces:
         add, infos = is_dual_carriageway(
-            face, roads, tree,
+            face, network, tree,
             concavity=concavity,
             elongation=elongation,
             compactness=compactness,
             area=area, width=width, huber=huber
         )
         if add:
             infos['cid'] = index
```

## cartagen4py/data_enrichment/network/roundabouts.py

```diff
@@ -1,35 +1,36 @@
 import shapely
 import geopandas as gpd
 import numpy as np
 from cartagen4py.utils.partitioning import *
 from cartagen4py.utils.network import *
 
-def detect_roundabouts(network, area_threshold=40000, miller_index=0.95):
+def detect_roundabouts(roads, area_threshold=40000, miller_index=0.95):
     """
     This function detects roundabouts inside a road network and returns polygons representing the roundabout extent.
     Returns None if no roundabouts where found.
     Parameters
     ----------
     network : geopandas GeoDataFrame of LineStrings
         The road network to analyze.
     area_threshold : int optional
         The area (in square meters) above which the object is not considered a roundabout.
         The default value is set to 40000.
     miller_index : float optional
         Index of compactess that determines if the shape is round or not.
         The default value is set to 0.97.
     """
-    crs = network.crs
+    crs = roads.crs
+    roads = roads.to_dict('records')
 
-    roads = []
-    for road in network.geometry:
-        roads.append(road)
+    network = []
+    for road in roads:
+        network.append(road['geometry'])
 
-    faces = calculate_network_faces(roads, convex_hull=False)
+    faces = calculate_network_faces(network, convex_hull=False)
 
     roundabouts = []
     index = 0
     for face in faces:
         add, infos = is_roundabout(face, area_threshold, miller_index)
         if add:
             infos['cid'] = index
```

## cartagen4py/utils/geometry/__init__.py

```diff
@@ -1,7 +1,8 @@
 from cartagen4py.utils.geometry.angle import *
+from cartagen4py.utils.geometry.bends import *
 from cartagen4py.utils.geometry.dilation import *
 from cartagen4py.utils.geometry.distances import *
 from cartagen4py.utils.geometry.extent import *
 from cartagen4py.utils.geometry.line import *
 from cartagen4py.utils.geometry.segment import *
 from cartagen4py.utils.geometry.skeletonization import *
```

## cartagen4py/utils/geometry/angle.py

```diff
@@ -82,7 +82,14 @@
             following = coords2[1]
         else:
             following = coords2[-2]
 
     angle = angle_3_pts(Point(previous), Point(current), Point(following))
 
     return angle
+
+def get_curvature(p1, p2, p3):
+    """
+    Return the curvature, i.e, the inverse of the radius of the circumcircle
+    passing by the three given points.
+    """
+    return 1 / abs(p2.distance(p3) / (2 * np.sin(angle_3_pts(p3, p2, p1))))
```

## cartagen4py/utils/geometry/line.py

```diff
@@ -1,11 +1,307 @@
 import numpy as np
 import shapely
-from shapely.ops import split, nearest_points, snap
-from shapely.geometry import Point, Polygon, LineString
+from shapely.ops import split, nearest_points, snap, transform
+from shapely.geometry import LineString, Point, Polygon, MultiPoint
+
+from cartagen4py.utils.geometry.angle import *
+from cartagen4py.utils.tessellation.hexagonal import *
+
+def visvalingam_whyatt(line, area_tolerance):
+    """
+    Visvalingam-Whyatt algorithm (1993)
+    """
+    def contains_another_point(line, pt, index):
+        first = line.coords[index-1]
+        last = line.coords[index+1]
+        triangle_coords = [first, pt, last, first]
+        triangle = Polygon(triangle_coords)
+        for vertex in line.coords:
+            if (vertex == first):
+                continue
+            if (vertex == pt):
+                continue
+            if (vertex == last):
+                continue
+            if (triangle.contains(Point(vertex))):
+                return True
+        return False
+    def compute_area_point(line, pt, index):
+        first = line.coords[index-1]
+        last = line.coords[index+1]
+        triangle = [first, pt, last, first]
+        polygon = Polygon(triangle)
+        return polygon.area
+
+    final_coords = list(line.coords)
+    while (True):
+        pt_area_min = None
+        area_min = line.envelope.area
+        current_line = LineString(tuple(final_coords))
+        for i in range(1,len(final_coords)-2):
+            pt = final_coords[i]
+            if(contains_another_point(current_line, pt, i)):
+                continue
+            area = compute_area_point(current_line, pt, i)
+            if (area < area_min):
+                area_min = area
+                if(area < area_tolerance):
+                    pt_area_min = pt
+        if(pt_area_min is None):
+            break
+        # remove pt from the line
+        final_coords.remove(pt_area_min)
+
+    return LineString(tuple(final_coords))
+
+def raposo_simplification(line, initial_scale, final_scale, centroid=True, tobler=False):
+    """
+    Raposo simplification algorithm (2010): uses an hexagonal tessallation, with a size related to the final scale, 
+    and the algorithm only retains one vertex per hexagonal cell. Be careful, it uses the scale as parameter. If the centroid parameter 
+    is True, the vertices inside an hexagon cell are replaced by the centroid of the cell; if it is False, they are replaced by the nearest
+    vertex to the centroid of the cell.
+    """
+    width = 0
+    if tobler:
+        width = final_scale * 5 / 4000 
+    else:
+        firstFactor = line.length / (len(line.coords)-1)
+        secondFactor = final_scale / initial_scale
+        width = firstFactor * secondFactor
+
+    # compute hexagon tessellation
+    tessellation = HexagonalTessellation(line.envelope, width)
+
+    current_index = 0
+    final_coords = []
+    # append the first point of the line, but without the z coordinate
+    twod_point = transform(lambda *args: args[:2], Point(line.coords[0]))
+    final_coords.append(twod_point.coords[0])
+    previous_cell = None
+    while (current_index < len(line.coords)-1):
+        current_cell = None
+        # now loop on the vertices from current index
+        # builds a point cloud as a multi-point geometry with all line vertices
+        # contained in the current cell.
+        point_cloud = []
+        for i in range(current_index,len(line.coords)):
+            # get the cells containing the point
+            point = line.coords[i]
+            containing_cells = tessellation.get_containing_cells(point)
+            if(current_cell is None):
+                if(previous_cell in containing_cells):
+                    containing_cells.remove(previous_cell)
+                current_cell = containing_cells[0]
+                point_cloud.append(point)
+                continue
+
+            if (current_cell in containing_cells):
+                point_cloud.append(point)
+                current_index = i+1
+            else:
+                current_index = i
+                previous_cell = current_cell
+                break
+        multipoint = MultiPoint(point_cloud)
+        if (centroid):
+            # replace the points by the centroid of the vertices in the cell
+            final_coords.append(multipoint.centroid.coords[0])
+        else:
+            # find the nearest vertex to the centroid
+            nearest = nearest_points(multipoint,multipoint.centroid)
+            final_coords.append(nearest[0].coords[0])
+        if (current_index == len(line.coords) - 1):
+            twod_final_point = transform(lambda *args: args[:2], Point(line.coords[current_index]))
+            final_coords.append(twod_final_point.coords[0])
+    # add the final point if it is not in the line
+    twod_final_point = transform(lambda *args: args[:2], Point(line.coords[len(line.coords) - 1]))
+    if(twod_final_point.coords[0] not in final_coords):
+        final_coords.append(twod_final_point.coords[0])
+    
+    # print(final_coords)
+    return LineString(final_coords)
+
+# Li-Openshaw simplification algorithm (1993). The simplification factor is the size of the regular grid applied on the line
+def __li_openshaw_simplification(line, cell_size):
+    # TODO: li openshaw line simplification
+    return line
+    
+
+def gaussian_smoothing(line, sigma=None, sample=None, densify=True, preserve_extremities=False):
+    """
+    Compute the gaussian smoothing of a set of a LineString.
+    Parameters
+    ----------
+    line : shapely LineString
+        The line to smooth.
+    sigma : float optional
+        Gaussian filter strength.
+        Default value to 30, which is a high value.
+    sample : float optional
+        The length in meter between each nodes after resampling the line.
+        If not provided, the sample is derived from the line and is the average distance between
+        each consecutive vertex.
+    densify : boolean optional
+        Whether the resulting line should keep the new node density. Default to True.
+    """
+    # Extend the given set of points at its first and last points of k points using central inversion.
+    def extend(line, interval):
+        # Compute the central inversion of a position. origin is the center of symmetry and p is the point to inverse.
+        def central_inversion(origin, p):
+            x = 2 * origin[0] - p[0]
+            y = 2 * origin[1] - p[1]
+            return (x,y)
+        
+        # Get the coordinates of the vertices
+        coords = list(line.coords)
+        # Get the first and last vertex
+        first, last = coords[0], coords[-1]
+
+        # Get the index of the penultimate vertex
+        # -2 is to avoid taking the last vertex
+        pen = len(coords) - 2
+
+        # Set the start of the line as the central inversion of n first vertices (n = interval)
+        result = [central_inversion(first, coords[i]) for i in range(interval, 0, -1)]
+
+        # Add the full line as the middle part of the line
+        result.extend(coords)
+
+        # Add the end of the line as the central inversion of n last vertices (n = interval)
+        result.extend([central_inversion(last, coords[i]) for i in range(pen, pen - interval, -1)])
+
+        return LineString(result)
+   
+    if sigma is None:
+        sigma = 30
+
+    if sample is None:
+        coords = list(line.coords)
+        distances = []
+        for i in range(0, len(coords) - 1):
+            v1, v2 = coords[i], coords[i + 1]
+            distances.append(shapely.Point(v1).distance(shapely.Point(v2)))
+        avg = (sum(distances) / len(distances))
+        sample = avg
+
+    # First resample the line, making sure there is a maximum distance between two consecutive vertices
+    resampled = resample_line(line, sample)
+
+    # Calculate the interval (number of vertex to take into consideration when smoothing)
+    interval = round(4 * sigma / sample)
+    # If the interval is longer than the input line, we change the interval and recalculate the sigma
+    if interval >= len(resampled.coords):
+        interval = len(resampled.coords) - 1
+        sigma = interval * sample / 4
+    
+    # Compute gaussian coefficients
+    c2 = -1.0 / (2.0 * sigma * sigma)
+    c1 = 1.0 / (sigma * np.sqrt(2.0 * pi))
+
+    # Compute the gaussian weights and their sum
+    weights = []
+    total = 0
+    for k in range (0, interval + 1):
+        weight = c1 * np.exp(c2 * k * k)
+        weights.append(weight)
+        total += weight
+        if k > 0:
+            total += weight
+    
+    # Extend the line at its first and last points with central inversion
+    extended = extend(resampled, interval)
+
+    smoothed_coords = []
+    for i in range(0, len(resampled.coords)):
+        x, y = 0, 0
+        for k in range(-interval , interval + 1):
+            p1 = extended.coords[i - k + interval]
+            x += weights[abs(k)] * p1[0] / total
+            y += weights[abs(k)] * p1[1] / total
+        smoothed_coords.append((x,y))
+
+    if densify:
+        final_coords = smoothed_coords
+    else:
+        # Only return the points matching the input points in the resulting filtered line
+        final_coords = []
+        # Stores for index of already treated vertices
+        done = []
+        # Loop through initial vertices
+        for point in list(line.coords):
+            # Set the distance to infinite
+            distance = float("inf")
+            nearest = None
+            # Loop through smoothed coordinates
+            for i in range(len(smoothed_coords)):
+                # Check that the index has not been already added
+                if i not in done:
+                    # Calculate distance from the point
+                    d = Point(smoothed_coords[i]).distance(Point(point))
+                    if d < distance:
+                        # Update distance and nearest index if below existing
+                        distance, nearest = d, i
+
+            # If a nearest point has been found, add it to the new line
+            if nearest is not None:
+                final_coords.append(smoothed_coords[nearest])
+                # Add the index as treated already
+                done.append(nearest)
+            else:
+                final_coords.append(point)
+        
+    if preserve_extremities:
+        final_coords[0] = Point(coords[0])
+        final_coords[-1] = Point(coords[-1])
+    
+    return LineString(final_coords)
+
+def get_bend_side(line):
+    """
+    Return the side of the interior of the bend regarding the line direction. (left or right)
+    Parameters
+    ----------
+    line : shapely LineString
+        The line to get the bend side from.
+    """
+    # Get the list of nodes
+    coords = list(line.coords)
+
+    # The total angle of the bend
+    total = 0
+
+    # Get the start point of the bend
+    start = shapely.Point(coords[0])
+
+    # Loop through the nodes of the linestring, starting on the seconde node
+    for i in range(1, len(coords) - 1):
+        # Get the current and the next node coordinates
+        c1 = coords[i]
+        c2 = coords[i + 1]
+
+        # Add to the total the angle between the starting point and those two nodes
+        angle = angle_3_pts(start, shapely.Point(c2), shapely.Point(c1))
+
+        # Set the angle to be between 0 and 2*pi
+        if angle % (2 * np.pi) >= 0:
+            angle = abs(angle % (2 * np.pi))
+        else:
+            angle = angle % (2 * np.pi) + 2 * np.pi
+
+        # Set the angle to be between -pi and pi
+        if angle > np.pi:
+            angle = angle - 2 * np.pi
+
+        total += angle
+
+    # If the total is above 0, the bend is left sided, otherwise it right sided
+    if total < 0:
+        return 'right'
+    else:
+        return 'left'
 
 def get_shortest_edge_length(geom: LineString):
     min_length = float('inf')
     segments = get_linestring_segments(geom)
     for segment in segments:
         print(segment)
         length = Point(segment[0]).distance(Point(segment[1]))
@@ -44,31 +340,43 @@
        # inner rings
        interiors = []
        for interior in polygon.interiors:
           interiors.append(array_to_2d(interior.coords))
        polygons_2d.append(Polygon(coords_2d,interiors))
     return polygons_2d
 
-# densifies a line with vertices every 'step' along the line
-def densify_geometry (line_geometry, step):
+def resample_line(line, step):
+    """
+    Densifies a line with vertices every 'step' along the line. Keep the start and end vertex.
+    Parameters
+    ----------
+    line : shapely LineString
+        The line to densify.
+    step : float
+        The step (in meters) to resample the geometry
+    """
 
-    # step: add a vertice every step in whatever unit your coordinate reference system use.
-    
-    length_m=line_geometry.length # get the length of the line
+    # Get the length of the line
+    length = line.length 
     
-    xy=[] # to store new tuples of coordinates
+    # Storage for final vertices, starting with the start of the line
+    xy = [(line.coords[0])]
     
-    for distance_along_old_line in np.arange(0,int(length_m),step): 
+    for distance in np.arange(step, int(length), step):
+        # Interpolate a point every step along the old line
+        point = line.interpolate(distance)
+        # Add the tuple of coordinates
+        xy.append((point.x, point.y))
     
-        point = line_geometry.interpolate(distance_along_old_line) # interpolate a point every step along the old line
-        xp,yp = point.x, point.y # extract the coordinates
+    # Add the last point of the line if it doesn't already exist
+    if xy[-1] != line.coords[-1]:
+        xy.append(line.coords[-1])
     
-        xy.append((xp,yp)) # and store them in xy list
-    
-    return LineString(xy) # Here, we finally create a new line with densified points.
+    # Here, we return a new line with densified points.
+    return LineString(xy)
 
 # returns the index of a vertex in a line. Returns -1 if the point given is not a vertex of the line
 def get_index_of_vertex(line, vertex, tolerance = 0.01):
     for i in range(0, len(line.coords)):
         point = Point(line.coords[i])
         if point.equals_exact(vertex, tolerance):
             return i
@@ -158,25 +466,29 @@
         new_line.append(__calculate_coords(vertex[0], vertex[1], length))
 
     new_line.extend(vertex)
 
     if position == 'both' or position == 'end':
         new_line.append(__calculate_coords(vertex[-1], vertex[-2], length))
 
-    return LineString(new_line)    
+    return LineString(new_line)
+
+def get_line_middle_point(line):
+    """
+    Return the point located along the line at half its length.
+    """
+    return line.interpolate(line.length / 2)
+
         
 def split_line_at_point(line, point):
     """
     Split a line at a given point along this line.
     Return the two new linestrings.
     Return None if the line and the point doesn't intersect.
     """
-    if line.distance(point) > 1e-8:
-        return None
-
     projected = nearest_points(point, line)[1]
     splitted = split(snap(line, projected, 0.0001), projected)
 
     lines = []
     for s in splitted.geoms:
         lines.append(s)
 
@@ -227,8 +539,80 @@
         return shapely.LineString(list(coords1) + list(coords2[1:]))
     # ...end and end
     elif end1 == end2:
         # Reverse the second line (drop the start) and add it to the first line
         return shapely.LineString(list(coords1) + list(coords2[::-1][1:]))
     # Here, linstrings are not connected
     else:
-        raise Exception("Provided LineStrings are not connected by their start or end vertex.")
+        raise Exception("Provided LineStrings are not connected by their start or end vertex.")
+
+def get_inflexion_points(line, min_dir=120.0):
+    """
+    This algorithm extract inflexion points from a LineString object and return a list of index of inflexion points.
+    Parameters
+    ----------
+    line : shapely LineString
+        The line to extract the inflexion points from.
+    min_dir : float
+        The minimum direction change (in degrees) between two consecutive inflexion points.
+        This parameter allows to remove micro inflexions from the results.
+    """
+
+    coords = list(line.coords)
+
+    # Storage for inflexion points
+    inflexion = []
+
+    # Storage for parts to check when micro inflexion points are detected
+    part = []
+
+    # Stores for the previous angle and the previous direction
+    prevangle = None
+    prevdir = None
+
+    # Loop through vertices
+    for i in range(1, len(coords) - 1):
+        # Get previous, current and next point
+        p1, p2, p3 = coords[i - 1], coords[i], coords[i + 1]
+
+        # Calculate angles formed by p1 and p2, and p1 and p3
+        a1 = np.arctan2(p2[1] - p1[1], p2[0] - p1[0])
+        a2 = np.arctan2(p3[1] - p1[1], p3[0] - p1[0])
+
+        # Calculate the direction of p1 p2
+        direction = np.degrees(a1) % 360
+        # Calculate the angle formed by the three points
+        alpha = a2 - a1
+
+        # Store if angle is positive or negative
+        angle = 1 if alpha > 0 else -1
+
+        # Check that previous angle has been calculated
+        if prevangle is not None:
+            # Check if the angle is not the same as the previous -> inflexion point
+            if angle != prevangle:
+                # Check that the previous direction has been calculated
+                if prevdir is not None:
+                    # If the absolute difference between the previous direction and the current one is above the direction threshold
+                    # It means that this is not a micro inflexion
+                    if abs(prevdir - direction) > min_dir:
+                        # Adding the middle of the part list, i.e. the middle of the micro inflexions
+                        inflexion.append(part[len(part) // 2])
+                        # Restart the part list with the current inflexion point
+                        part = [i]
+                    else:
+                        # Add the current point to the part list
+                        part.append(i)
+                # If not, append the point to the part
+                else:
+                    part.append(i)
+
+                # Set the previous angle as the direction of the current 
+                prevdir = direction
+        
+        # Set previous angle as current
+        prevangle = angle
+
+    # Append the last part's middle point
+    inflexion.append(part[len(part) // 2])
+
+    return inflexion
```

## cartagen4py/utils/geometry/skeletonization.py

```diff
@@ -45,15 +45,15 @@
         self.__skeletonize(polygon, threshold_range)
 
     def add_incoming_points(self, entries, connection='joint'):
         """
         Add new entry points that are not 'natural' skeleton entries.
         Connection can be 'joint', which forces the entry point to connect to the closest joint,
         or can be 'interior', which first look if there is an interior triangle inside the triangulation
-        and connect directly the entry point to the its skeleton joint. If no interior triangle is found,
+        and connect directly the entry point to its skeleton joint. If no interior triangle is found,
         apply 'joint' connection instead.
         """
         # Add the point
         def add_point(entry, connection):
             # If it doesn't exist, add it
             if entry not in self.joints:
                 closest = None
@@ -177,25 +177,26 @@
                 # Merge the two intersecting bones
                 merged = merge_linestrings(bones[0], bones[1])
                 
                 # Add the merged bone
                 self.bones.append(merged)
 
                 # Remove the interior node
-                self.interiors.pop(self.interiors.index(point))
+                if point in self.interiors:
+                    self.interiors.pop(self.interiors.index(point))
 
         # Start the recursion
         for e in entries:
             recursive_removal(e)
 
-    def create_network(self, distance=None):
+    def create_network(self, distance=None, smoothing=False):
         """
         Create the inside network from the skeleton bones.
-        The distance parameter is the distance used by the Douglas-Peucker algorithm. If not provided,
-        it doesn't apply any simplification.
+        The distance parameter is the distance used by the Douglas-Peucker algorithm. If not provided, it doesn't apply any simplification.
+        The smooth parameter specify whether a gaussian smoothing shoudl be applied.
         """
         bones = self.bones.copy()
         network = []
 
         def recursive_network_creation(point, polyline):
             # Add the current point to the polyline
             polyline.append(point)
@@ -248,18 +249,23 @@
             recursive_network_creation(coords, [])
 
             # Add the network as a property after having simplified it
             if distance is not None:
                 self.network = list(shapely.simplify(network, tolerance=distance))
             else:
                 self.network = network
-        
+            
+            # Apply a gaussian smoothing to the network if selected
+            if smoothing:
+                for i, n in enumerate(self.network):
+                    self.network[i] = gaussian_smoothing(n, preserve_extremities=True)
+
         return self.network
 
-    def blend(self, attributes):
+    def blend(self, attributes, sigma=None):
         """
         Blend the given network with the created skeleton. Relies on entry points.
         It works only if incoming lines where provided during the skeleton creation.
         """
 
         if self.incoming is None:
             raise Exception("Incoming lines were not provided during the skeletonization. Cannot blend with the network.")
@@ -320,14 +326,20 @@
                 geometries.append(b['geometry'])
             final['geometry'] = shapely.ops.linemerge(geometries)
             blended = [final]
         else:
             # Else, retrieve the blended network without contained lines
             blended = [b for i, b in enumerate(blended) if i not in remove]
 
+        # Apply a gaussian smoothing to the blended network if selected
+        if sigma is not None:
+            for i, n in enumerate(blended):
+                geom = n['geometry']
+                blended[i]['geometry'] = gaussian_smoothing(geom, sigma=sigma, preserve_extremities=True)
+
         self.blended = blended
         return blended
 
     def __skeletonize(self, polygon, threshold_range):
         """
         Recursively create the TIN skeleton.
         Populate joints property, i.e. all the vertex of the polylines of the skeleton
```

## cartagen4py/utils/math/vector.py

```diff
@@ -1,18 +1,113 @@
 import math
+import numpy as np
 from shapely.geometry import Point
 
 class Vector2D:
-    x=0.0
-    y=0.0
-
-    # constructor with shapely points
+    """
+    Create a 2D vector.
+    """
     def __init__(self, point1, point2):
         self.x = point2.x - point1.x
         self.y = point2.y - point1.y
 
-    def __init__(self, segment):
-        self.x = segment.point2[0] - segment.point1[0]
-        self.y = segment.point2[1] - segment.point1[1]
+    @classmethod
+    def from_point(cls, point):
+        """
+        Create a vector between 0 and the given point.
+        """
+        return cls(Point(0, 0), point)
+
+    @classmethod
+    def from_points(cls, point1, point2):
+        """
+        Create a vector between the two given points.
+        """
+        return cls(point1, point2)
+
+    @classmethod
+    def from_segment(cls, segment):
+        """
+        Create a vector from a segment.
+        """
+        return cls(segment.point1, segment.point2)
+
+    @classmethod
+    def from_angle(cls, angle, norm):
+        """
+        Create a vector from an angle and a norm.
+        """
+        return cls(Point(0, 0), Point(norm * np.cos(angle), norm * np.sin(angle)))
+
+    def copy(self):
+        """
+        Copy the vector.
+        """
+        return Vector2D.from_point(Point(self.x, self.y))
     
     def translate(self, point):
-        return Point(point.x + self.x, point.y + self.y)
+        """
+        Translate the given point with the vector.
+        """
+        return Point(point.x + self.x, point.y + self.y)
+
+    def get_norm(self):
+        """
+        Return the norm of the vector.
+        """
+        return np.sqrt(pow(self.x, 2) + pow(self.y, 2))
+
+    def normalize(self):
+        """
+        Normalize the vector.
+        """
+        n = self.get_norm()
+        self.x = self.x / n
+        self.y = self.y / n
+
+    def opposite(self):
+        """
+        Return the opposite of the vector.
+        """
+        return Vector2D.from_point(Point(-self.x, -self.y))
+
+    def change_norm(self, norm):
+        """
+        Return a new vector with a new norm.
+        """
+        vector = self.copy()
+        vector.normalize()
+        vector.scalar_multiplication(norm)
+        return vector
+
+    def scalar_product(self, v):
+        """
+        Return the scalar product with a vector.
+        """
+        return self.x * v.x + self.y * v.y
+
+    def scalar_multiplication(self, value):
+        """
+        Multiply the vector by a given value.
+        """
+        self.x = self.x * value
+        self.y = self.y * value
+
+    def product(self, vector):
+        """
+        Calculate the vector product between this vector and a given one.
+        """
+        return self.x * vector.y - self.y * vector.x
+
+    def project(self, direction):
+        """
+        Project the vector in a given direction.
+        """
+        if direction >= (np.pi * 2):
+            direction = direction - np.pi * 2
+        # if direction % (2 * np.pi) >= 0:
+        #     direction = abs(direction % (2 * np.pi))
+        # else:
+        #     direction = direction % (2 * np.pi) + 2 * np.pi
+        unit = Vector2D.from_angle(direction, 1)
+        norm = self.scalar_product(unit)
+        return unit.change_norm(norm)
```

## Comparing `cartagen4py-0.2.9.dist-info/METADATA` & `cartagen4py-0.3.dist-info/METADATA`

 * *Files 4% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 Metadata-Version: 2.1
 Name: cartagen4py
-Version: 0.2.9
+Version: 0.3
 Summary: Python package to generalise geographic objects for cartographic purposes
 Home-page: https://github.com/LostInZoom/cartagen4py
 Author: Guillaume Touya, Justin Berli, Azelle Courtial
 Author-email: guillaume.touya@ign.fr
-License: CeCILL-C
+License: EUPL v. 1.2
 Keywords: Generalization,Cartography,cartographic generalization
 Platform: Linux
 Platform: Mac OSX
 Platform: Windows
 Platform: Unix
 Classifier: Development Status :: 1 - Planning
 Classifier: Intended Audience :: Science/Research
```

## Comparing `cartagen4py-0.2.9.dist-info/RECORD` & `cartagen4py-0.3.dist-info/RECORD`

 * *Files 4% similar despite different names*

```diff
@@ -1,68 +1,70 @@
 cartagen4py/__init__.py,sha256=YdkVGqmL0XKX79SDwQU9sglqjKQ4fx3M-1BhguIYnJk,183
 cartagen4py/algorithms/__init__.py,sha256=QtZO_GLtCiCfRd7F4mh56gnf4Sj-wjy5Rry8GkAsDx0,223
 cartagen4py/algorithms/buildings/__init__.py,sha256=n8nINf2pCHNcBpEyg6Jrfh7pdEx5P4UoXEC7jjwzUf4,244
-cartagen4py/algorithms/buildings/amalgamation.py,sha256=P2KUMokwWsHC6GKoRuyeDtdXbwrRSOYjP_hzQR5gfp0,4579
+cartagen4py/algorithms/buildings/amalgamation.py,sha256=Z2Gmlvga_x9OnVfVpmOm6Wb4dcbmPriTHwrYnj7Hzmw,4605
 cartagen4py/algorithms/buildings/random_displacement.py,sha256=omaxGlgrDagHf0cyO_WuwG-x2QNesf_SMtPObrLr6AM,7791
 cartagen4py/algorithms/buildings/simplification.py,sha256=sO6-FOcas80fcn7Ty811NTh7494EmSIdEmCjAMhE0Hk,8144
 cartagen4py/algorithms/buildings/squaring.py,sha256=P_ZoN8BURGnZQaEJSWaeMjJaMBAHtKoaDTXmdSL9If8,15705
 cartagen4py/algorithms/general/__init__.py,sha256=LeXQ0-n_k-Q5lFs-2W_7ob71Im2ATryygJ2FnImjaIE,55
 cartagen4py/algorithms/general/constraint.py,sha256=FGHSGpFWCoL2Ht--XnHwvZqYf9JrQqacuZoogqpuss0,50723
-cartagen4py/algorithms/lines/__init__.py,sha256=omCjWpgLKsQCgedRZ-0Nmd0pTu02Ull3_L0PCwzWZMg,170
-cartagen4py/algorithms/lines/breaks.py,sha256=Ii7C_ZtPTnegeIB0SmiEwOIbSY9TL_gutTbiMLydTNU,7242
+cartagen4py/algorithms/lines/__init__.py,sha256=SQIS4bW-pzwUUmbQ-KNbstWXBfhfqtULjI8LikPjaa0,98
+cartagen4py/algorithms/lines/bends.py,sha256=G5isFxU4kjYcV16oetpL6A0kKaJ54eYB_FL9VZIXaPY,15170
+cartagen4py/algorithms/lines/breaks.py,sha256=82hf1TsMtj5nbUUgenZDNMXeH-nGZZ1lX5R2DFDBbbs,6423
 cartagen4py/algorithms/lines/line_simplification.py,sha256=BP509Vu_xHvFVd709oBO2B1aA-gmuySgcarYHRVMNCQ,5307
-cartagen4py/algorithms/lines/line_smoothing.py,sha256=Yz3UWLQeMFnjG96wTcvSIuwzyg503l0SWYK2EWOrs2k,3441
+cartagen4py/algorithms/lines/line_smoothing.py,sha256=AyRZ6sCmh6jq9cxLU39F-vHRcz62u2vJQ7QuLQSZ034,4443
 cartagen4py/algorithms/network/__init__.py,sha256=ESTUISmF1xLg5dFkilcG6f84NPuIcdHpYz768HG_V6E,240
-cartagen4py/algorithms/network/branching_crossroads.py,sha256=qhXsds2MxZLprY-dl4NwidX-8Z9WbuC9wSCiC8T-4z4,11054
+cartagen4py/algorithms/network/branching_crossroads.py,sha256=4b5XdpXdxRWJP5iI3vD_Nb6wgZ0NKcOt12AQHcm4NwY,11053
 cartagen4py/algorithms/network/dead_ends.py,sha256=RFJkUxlmsS-g1O6UHqBuswuUOi5rAQRx4go0360W670,8821
-cartagen4py/algorithms/network/dual_carriageways.py,sha256=xOFcNvhK2jeMY_P-9YMKmQxpIGDc9twnSl32AK4vp0E,15760
-cartagen4py/algorithms/network/roundabouts.py,sha256=evwWkAXxQVlvbEzaC7vRBZGflkHTN5DHbmrdXchO3oY,5423
+cartagen4py/algorithms/network/dual_carriageways.py,sha256=US5DqzwUvwKd6_QAW8c3CgXUCrUuHuwnhDgzEyQ8Fkg,16454
+cartagen4py/algorithms/network/roundabouts.py,sha256=DXZA6YMjWcpxaPFzohb0oVHQbqOFVexyM3Jhznygocw,5667
 cartagen4py/algorithms/points/__init__.py,sha256=hllEJBpuyOQUr7Q28MFrw7_IU6sKWfdUlXTNCGkTMOk,126
 cartagen4py/algorithms/points/point_set_quadtree.py,sha256=FLPHbZhDtKiIhywjJ7KS2ZivRAHDpvH07F7Vub9VW3g,5350
 cartagen4py/algorithms/points/point_set_reduction.py,sha256=eQ7KTvtNOl09WoynVDGjKtDpgPj6Wrrogg5egOJGCew,7494
-cartagen4py/data_enrichment/__init__.py,sha256=p1S4Sh_Pa9hvtYQM5278RQrTdALbZQBEA-cySC-OnRk,366
-cartagen4py/data_enrichment/bends.py,sha256=HXWKyjIBCrGhu8rNDemIdWi7E62WlpLuhW2x-Wvd6xc,278
-cartagen4py/data_enrichment/building_measures.py,sha256=snOCbXVx0TQo77MyZl8PU1ThqvLUxp0VRxGbnQJUgLk,11979
+cartagen4py/data_enrichment/__init__.py,sha256=ZlAj0q23UrGteIpo7auGfLaz8o_IkFwvdS60vlRbpwM,318
+cartagen4py/data_enrichment/bends.py,sha256=HuAojJLKG4F6Ei0vjn2fM9YBmSH7NddXgALqCjC9V6o,1096
+cartagen4py/data_enrichment/building_measures.py,sha256=9J_RZl4VvRH4wtXyI4SN9tKSSZ0bbx3TsyU-shj9xgA,11973
 cartagen4py/data_enrichment/pastiness.py,sha256=jBxfQXMIWJV7HLCk4Atdc6cBb-53JVBbirzsBmPuBRA,9795
-cartagen4py/data_enrichment/stroke.py,sha256=fgEh2Z0srhTyZiHUI_EU8FEAgTyYspW4GXdkRP3VpRs,14249
+cartagen4py/data_enrichment/stroke.py,sha256=45GLsKCBs-ErVH8QDexyZ9x9FSYQO8OOCJmcYSu-9oc,14786
 cartagen4py/data_enrichment/strokeriver.py,sha256=M3n4-aPSLvrM3Oh6cYRAYg2LlwkfISs3xH5-D2NbsLI,13987
 cartagen4py/data_enrichment/urban_areas.py,sha256=idg_MeeMs6NfDNAfUkKVkDC7_h777Ckq8BJe5VEeyQ4,958
 cartagen4py/data_enrichment/network/__init__.py,sha256=dkump8tDGZDpbjaublpWKxMx-gkd3yy16pOyPyFk49U,323
-cartagen4py/data_enrichment/network/branching_crossroads.py,sha256=W18-5AiDdFgU0FsTTmH5ddMGvnDEllX3oegQqF-Okd0,10533
-cartagen4py/data_enrichment/network/dead_ends.py,sha256=x7YvN-MtNIVpmx5GhSg2-Fu08PQSx4VvQoBr8R3ZKjw,7774
-cartagen4py/data_enrichment/network/dual_carriageways.py,sha256=QzJBQy9HniDPPiq3EqolTyVkirv2ITMgVLsJGoMqsao,3937
-cartagen4py/data_enrichment/network/roundabouts.py,sha256=xwXBwXKPN3L8p7UnuokfbsUUeC4zKYYRwSTPqIGJPnY,2038
+cartagen4py/data_enrichment/network/branching_crossroads.py,sha256=BT_b5-uJRVyJ3R8IqaHvBWcMSgshqDwhU9Nmvv-QjMw,10573
+cartagen4py/data_enrichment/network/dead_ends.py,sha256=9MpYnLGoHzcsGadru8pEq1D0FXO1_ioQMS35uFYWZBw,8193
+cartagen4py/data_enrichment/network/dual_carriageways.py,sha256=D0F3s9v8qwdUoBAkAr9EUPyskU-4cITaIZVG_tmFKGY,5133
+cartagen4py/data_enrichment/network/roundabouts.py,sha256=nOY78AFzuoqSLBx7QHD4LEtdIpUqTCpFTS4mMa8pqYU,2078
 cartagen4py/data_enrichment/network/rural_areas.py,sha256=AuzdKaPx0PeN7AI2tScaroSotXZHoznX1qmb3uHVdrs,8547
 cartagen4py/evaluation/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cartagen4py/evaluation/constraint_satisfaction.py,sha256=BRDgF_68MSO_U7RXhEAX2-kMnZTQTxDXm4KGzwAARx0,238
 cartagen4py/processes/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 cartagen4py/utils/__init__.py,sha256=C3eZMloP8o3EHFGDMXc9inLz2nA5jstbKjF8rGqIpj0,331
 cartagen4py/utils/plot_utils.py,sha256=T7zb2LtqB8JIRiK_twb1BfuCtgzskw1rEu8SBw-ZUgk,3766
 cartagen4py/utils/attributes/__init__.py,sha256=PvaapYZtYNBC88pxvXSaFvFhMhAWR5LdwR3awimiCro,54
 cartagen4py/utils/attributes/propagation.py,sha256=nW4INpoGYfjqMPAAQR2L58LhMciY5blr8uWedp0bDzs,1343
 cartagen4py/utils/clustering/__init__.py,sha256=BZLGf3J8MU2eWSeKsclmIH9T-BGZpVMXgNUyh-pbFrY,49
 cartagen4py/utils/clustering/dbscan.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-cartagen4py/utils/geometry/__init__.py,sha256=qGDw6tsTfKEWcPEkNOt3LqNywyf89SZld8gFI3efcPM,347
-cartagen4py/utils/geometry/angle.py,sha256=beyIlMcjBrpE42ePWCShSWDuuuvUrQp-lc6rM5Z-Zr0,2160
+cartagen4py/utils/geometry/__init__.py,sha256=opb8mi6GeL5NvY9FuNeyIrS-am-_woceDS-vcBEl1tw,394
+cartagen4py/utils/geometry/angle.py,sha256=rIDypVKj9cNOgdFxorvd_wxA3J-5s6ncsefbAWf6jVc,2399
+cartagen4py/utils/geometry/bends.py,sha256=oGpHTV-1CzA-9vZy1FT-1v5CYQgVHfntQWgfkcK4h5E,5844
 cartagen4py/utils/geometry/dilation.py,sha256=a3qwZ54wRhViwABnvHGuAN3sthC7vSMyxzKzvqlgC5I,20148
 cartagen4py/utils/geometry/distances.py,sha256=ghcHtH0drFcRoOPbGhtT0gHh_lFJvmQFCL_M8UjrKIk,587
 cartagen4py/utils/geometry/extent.py,sha256=2ksa3gjqvo2fEs5znnm_bmz_JLm88RTHsSrw5ixskP0,1327
-cartagen4py/utils/geometry/line.py,sha256=Dl2-idyciY_DC1pAxxsHKmgmfeOZmZ-px5FOMnZm5gU,7856
+cartagen4py/utils/geometry/line.py,sha256=dB_l_t7Y_xGt2uiV9MbDjXWb4vTQ351_TOjMAgF__k8,22287
 cartagen4py/utils/geometry/segment.py,sha256=GhWiTEXdQkEL4re3SDi6RhXxfRIW_k3Jpc56jAd94-s,3167
-cartagen4py/utils/geometry/skeletonization.py,sha256=RCbAJDmaHseCmd52m5-omazjsoBhAGQiT1Cd0FzkpxI,25511
+cartagen4py/utils/geometry/skeletonization.py,sha256=rJJ6OuIlVlKPKraXzCMv7kVlnTWBVwJlNJxjkPfSe4Q,26190
 cartagen4py/utils/graph/__init__.py,sha256=O64xECNGiIBWLInuUskFKuYyu4sBrAeuzBvT2cznImw,43
 cartagen4py/utils/graph/roads.py,sha256=DWZDJ2kvAiYpLqj57LIq7ypV4Y109GtufCiwBKbuZOU,2281
 cartagen4py/utils/math/__init__.py,sha256=37BaOqHMrEhL9LRyiexK93gk-HsMfn59vRbLXcA9lbc,91
 cartagen4py/utils/math/morphology.py,sha256=yTfvYgyleRsS7pzSHGxeoIOKAsH4LV1C1L5m77_71sQ,4468
-cartagen4py/utils/math/vector.py,sha256=P8XnNtifAUt36VqZNs27B5AYxOZtaq4B1kiDKQ91k6M,474
+cartagen4py/utils/math/vector.py,sha256=JX-O7m2ul48brT4D5a_lbZR_IZXHpUc3Y5aCs5YPG74,2947
 cartagen4py/utils/network/__init__.py,sha256=uY5cVcxd7pGviv9njdeZk7VbfZX1byo7huPj_WhBDGY,91
 cartagen4py/utils/network/faces.py,sha256=ZE639Nk0a2KPt30x5dfe0cPgq_66LELUEq9H9mIedrY,1441
 cartagen4py/utils/network/roads.py,sha256=5adUoavoDLQnHmr0XSI4T4cirteHi2JLGSlRs7K09rA,6629
 cartagen4py/utils/partitioning/__init__.py,sha256=wYY4dcoZwO1bGr6UJvSeWWuTX6freF82hpQLEEZIADE,106
 cartagen4py/utils/partitioning/network.py,sha256=_IUsA8if3YFq477hKot6mr3G86hdM86k6Bl2YELMvyg,2301
 cartagen4py/utils/partitioning/quadtree.py,sha256=8UFlbKGqJGMRPKq_XY65rQ7LZDCrAde8-34OM9wv6UA,334
 cartagen4py/utils/tessellation/__init__.py,sha256=2GwkglcYNQ017m3mI1w2Ge_pcfn280ucAm7fCDKeEjw,54
 cartagen4py/utils/tessellation/hexagonal.py,sha256=StiXgRQ2-mosM9g9Y2_o0hs5t8iai6zwcwDJFF3iEBo,3721
-cartagen4py-0.2.9.dist-info/METADATA,sha256=8YJEsu9tu52E9G-Q2RWusk--9y1crGGJKsF3ZTst5w0,931
-cartagen4py-0.2.9.dist-info/WHEEL,sha256=oiQVh_5PnQM0E3gPdiz09WCNmwiHDMaGer_elqB3coM,92
-cartagen4py-0.2.9.dist-info/top_level.txt,sha256=6aS8ZPdHwWPED3ELy_ijz8nBO9mSuD6vqCoaMn5ML3Q,12
-cartagen4py-0.2.9.dist-info/RECORD,,
+cartagen4py-0.3.dist-info/METADATA,sha256=Dn0bd-e4Bqf14PaG8X0o0uDhS6ep-5ReFOSKXi4RGyU,932
+cartagen4py-0.3.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+cartagen4py-0.3.dist-info/top_level.txt,sha256=6aS8ZPdHwWPED3ELy_ijz8nBO9mSuD6vqCoaMn5ML3Q,12
+cartagen4py-0.3.dist-info/RECORD,,
```

