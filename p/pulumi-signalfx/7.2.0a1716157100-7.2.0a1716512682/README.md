# Comparing `tmp/pulumi_signalfx-7.2.0a1716157100.tar.gz` & `tmp/pulumi_signalfx-7.2.0a1716512682.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pulumi_signalfx-7.2.0a1716157100.tar", last modified: Sun May 19 22:22:25 2024, max compression
+gzip compressed data, was "pulumi_signalfx-7.2.0a1716512682.tar", last modified: Fri May 24 01:09:41 2024, max compression
```

## Comparing `pulumi_signalfx-7.2.0a1716157100.tar` & `pulumi_signalfx-7.2.0a1716512682.tar`

### file list

```diff
@@ -1,83 +1,83 @@
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.744620 pulumi_signalfx-7.2.0a1716157100/
--rw-r--r--   0 runner    (1001) docker     (127)     3024 2024-05-19 22:22:25.744620 pulumi_signalfx-7.2.0a1716157100/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     2570 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/README.md
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.736620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/
--rw-r--r--   0 runner    (1001) docker     (127)     7521 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)   154935 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (127)     9248 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/_utilities.py
--rw-r--r--   0 runner    (1001) docker     (127)    19007 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/alert_muting_rule.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.736620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/
--rw-r--r--   0 runner    (1001) docker     (127)      410 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10415 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    10582 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/external_integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    82462 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)     9992 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/outputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    10114 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/token_integration.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.736620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/
--rw-r--r--   0 runner    (1001) docker     (127)      341 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     2086 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    56590 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)     2151 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/outputs.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/config/
--rw-r--r--   0 runner    (1001) docker     (127)      285 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/config/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1079 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/config/__init__.pyi
--rw-r--r--   0 runner    (1001) docker     (127)     1924 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/config/vars.py
--rw-r--r--   0 runner    (1001) docker     (127)    54932 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/dashboard.py
--rw-r--r--   0 runner    (1001) docker     (127)    33368 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/dashboard_group.py
--rw-r--r--   0 runner    (1001) docker     (127)    26221 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/data_link.py
--rw-r--r--   0 runner    (1001) docker     (127)    65421 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/detector.py
--rw-r--r--   0 runner    (1001) docker     (127)    18692 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/event_feed_chart.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/
--rw-r--r--   0 runner    (1001) docker     (127)      341 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1241 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    34998 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)     1609 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/outputs.py
--rw-r--r--   0 runner    (1001) docker     (127)     3209 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/get_dimension_values.py
--rw-r--r--   0 runner    (1001) docker     (127)    44252 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/heatmap_chart.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/jira/
--rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/jira/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    34217 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/jira/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    65676 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/list_chart.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/
--rw-r--r--   0 runner    (1001) docker     (127)      358 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     1914 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/_inputs.py
--rw-r--r--   0 runner    (1001) docker     (127)     1452 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/outputs.py
--rw-r--r--   0 runner    (1001) docker     (127)    21446 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/timeline.py
--rw-r--r--   0 runner    (1001) docker     (127)    26770 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/view.py
--rw-r--r--   0 runner    (1001) docker     (127)    21744 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/metric_ruleset.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/opsgenie/
--rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/opsgenie/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    12501 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/opsgenie/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    24829 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/org_token.py
--rw-r--r--   0 runner    (1001) docker     (127)   139713 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/outputs.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pagerduty/
--rw-r--r--   0 runner    (1001) docker     (127)      327 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pagerduty/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)     3712 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pagerduty/get_integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    10441 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pagerduty/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    11882 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/provider.py
--rw-r--r--   0 runner    (1001) docker     (127)       84 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pulumi-plugin.json
--rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/py.typed
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/servicenow/
--rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/servicenow/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    28846 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/servicenow/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    44927 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/single_value_chart.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/slack/
--rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/slack/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10698 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/slack/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    31432 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/slo.py
--rw-r--r--   0 runner    (1001) docker     (127)    32559 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/table_chart.py
--rw-r--r--   0 runner    (1001) docker     (127)    29851 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/team.py
--rw-r--r--   0 runner    (1001) docker     (127)    11236 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/text_chart.py
--rw-r--r--   0 runner    (1001) docker     (127)    85614 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/time_chart.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/victorops/
--rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/victorops/__init__.py
--rw-r--r--   0 runner    (1001) docker     (127)    10363 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/victorops/integration.py
--rw-r--r--   0 runner    (1001) docker     (127)    14929 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/webhook_integration.py
-drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-19 22:22:25.740620 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/
--rw-r--r--   0 runner    (1001) docker     (127)     3024 2024-05-19 22:22:25.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/PKG-INFO
--rw-r--r--   0 runner    (1001) docker     (127)     2230 2024-05-19 22:22:25.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/SOURCES.txt
--rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-19 22:22:25.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/dependency_links.txt
--rw-r--r--   0 runner    (1001) docker     (127)       49 2024-05-19 22:22:25.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/requires.txt
--rw-r--r--   0 runner    (1001) docker     (127)       16 2024-05-19 22:22:25.000000 pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/top_level.txt
--rw-r--r--   0 runner    (1001) docker     (127)      683 2024-05-19 22:22:19.000000 pulumi_signalfx-7.2.0a1716157100/pyproject.toml
--rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-19 22:22:25.744620 pulumi_signalfx-7.2.0a1716157100/setup.cfg
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/
+-rw-r--r--   0 runner    (1001) docker     (127)     3024 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2570 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/README.md
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.170842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/
+-rw-r--r--   0 runner    (1001) docker     (127)     7521 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)   169197 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9248 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/_utilities.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18519 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/alert_muting_rule.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/
+-rw-r--r--   0 runner    (1001) docker     (127)      410 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10599 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9691 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/external_integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    78469 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    10176 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/outputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9479 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/token_integration.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/
+-rw-r--r--   0 runner    (1001) docker     (127)      341 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3062 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    51988 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3113 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/outputs.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/config/
+-rw-r--r--   0 runner    (1001) docker     (127)      285 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/config/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1079 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/config/__init__.pyi
+-rw-r--r--   0 runner    (1001) docker     (127)     1924 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/config/vars.py
+-rw-r--r--   0 runner    (1001) docker     (127)    61667 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/dashboard.py
+-rw-r--r--   0 runner    (1001) docker     (127)    32113 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/dashboard_group.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20850 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/data_link.py
+-rw-r--r--   0 runner    (1001) docker     (127)    56014 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/detector.py
+-rw-r--r--   0 runner    (1001) docker     (127)    17564 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/event_feed_chart.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/
+-rw-r--r--   0 runner    (1001) docker     (127)      341 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1241 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    34395 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1609 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/outputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3209 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/get_dimension_values.py
+-rw-r--r--   0 runner    (1001) docker     (127)    40028 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/heatmap_chart.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/jira/
+-rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/jira/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    31138 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/jira/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    59930 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/list_chart.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/
+-rw-r--r--   0 runner    (1001) docker     (127)      358 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1920 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/_inputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)     1458 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/outputs.py
+-rw-r--r--   0 runner    (1001) docker     (127)    20439 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/timeline.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26019 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/view.py
+-rw-r--r--   0 runner    (1001) docker     (127)    18836 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/metric_ruleset.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.174842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/opsgenie/
+-rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/opsgenie/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    12007 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/opsgenie/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    21592 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/org_token.py
+-rw-r--r--   0 runner    (1001) docker     (127)   153891 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/outputs.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pagerduty/
+-rw-r--r--   0 runner    (1001) docker     (127)      327 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pagerduty/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     3503 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pagerduty/get_integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9709 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pagerduty/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    11882 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/provider.py
+-rw-r--r--   0 runner    (1001) docker     (127)       84 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pulumi-plugin.json
+-rw-r--r--   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/py.typed
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/servicenow/
+-rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/servicenow/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26431 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/servicenow/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    39002 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/single_value_chart.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/slack/
+-rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/slack/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9889 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/slack/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    16847 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/slo.py
+-rw-r--r--   0 runner    (1001) docker     (127)    30799 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/table_chart.py
+-rw-r--r--   0 runner    (1001) docker     (127)    26819 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/team.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9774 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/text_chart.py
+-rw-r--r--   0 runner    (1001) docker     (127)    77114 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/time_chart.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/victorops/
+-rw-r--r--   0 runner    (1001) docker     (127)      296 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/victorops/__init__.py
+-rw-r--r--   0 runner    (1001) docker     (127)     9572 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/victorops/integration.py
+-rw-r--r--   0 runner    (1001) docker     (127)    13739 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/webhook_integration.py
+drwxr-xr-x   0 runner    (1001) docker     (127)        0 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/
+-rw-r--r--   0 runner    (1001) docker     (127)     3024 2024-05-24 01:09:41.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/PKG-INFO
+-rw-r--r--   0 runner    (1001) docker     (127)     2230 2024-05-24 01:09:41.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/SOURCES.txt
+-rw-r--r--   0 runner    (1001) docker     (127)        1 2024-05-24 01:09:41.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/dependency_links.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       49 2024-05-24 01:09:41.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/requires.txt
+-rw-r--r--   0 runner    (1001) docker     (127)       16 2024-05-24 01:09:41.000000 pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/top_level.txt
+-rw-r--r--   0 runner    (1001) docker     (127)      683 2024-05-24 01:09:34.000000 pulumi_signalfx-7.2.0a1716512682/pyproject.toml
+-rw-r--r--   0 runner    (1001) docker     (127)       38 2024-05-24 01:09:41.178842 pulumi_signalfx-7.2.0a1716512682/setup.cfg
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/PKG-INFO` & `pulumi_signalfx-7.2.0a1716512682/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pulumi_signalfx
-Version: 7.2.0a1716157100
+Version: 7.2.0a1716512682
 Summary: A Pulumi package for creating and managing SignalFx resources.
 License: Apache-2.0
 Project-URL: Homepage, https://pulumi.io
 Project-URL: Repository, https://github.com/pulumi/pulumi-signalfx
 Keywords: pulumi,signalfx
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/README.md` & `pulumi_signalfx-7.2.0a1716512682/README.md`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/__init__.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/__init__.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/_inputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/_inputs.py`

 * *Files 12% similar despite different names*

```diff
@@ -67,52 +67,52 @@
 @pulumi.input_type
 class AlertMutingRuleFilterArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  property_value: pulumi.Input[str],
                  negated: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: the property to filter by
-        :param pulumi.Input[str] property_value: the value of the property to filter by
-        :param pulumi.Input[bool] negated: (false by default) whether this filter should be a "not" filter
+        :param pulumi.Input[str] property: The property to filter.
+        :param pulumi.Input[str] property_value: The property value to filter.
+        :param pulumi.Input[bool] negated: Determines if this is a "not" filter. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "property_value", property_value)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter(name="propertyValue")
     def property_value(self) -> pulumi.Input[str]:
         """
-        the value of the property to filter by
+        The property value to filter.
         """
         return pulumi.get(self, "property_value")
 
     @property_value.setter
     def property_value(self, value: pulumi.Input[str]):
         pulumi.set(self, "property_value", value)
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) whether this filter should be a "not" filter
+        Determines if this is a "not" filter. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @negated.setter
     def negated(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "negated", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        the property to filter by
+        The property to filter.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -122,19 +122,19 @@
     def __init__(__self__, *,
                  chart_id: pulumi.Input[str],
                  column: Optional[pulumi.Input[int]] = None,
                  height: Optional[pulumi.Input[int]] = None,
                  row: Optional[pulumi.Input[int]] = None,
                  width: Optional[pulumi.Input[int]] = None):
         """
-        :param pulumi.Input[str] chart_id: ID of the chart to display
-        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
-        :param pulumi.Input[int] height: How many rows the chart should take up. (greater than or equal to 1)
-        :param pulumi.Input[int] row: The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
-        :param pulumi.Input[int] width: How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
+        :param pulumi.Input[str] chart_id: ID of the chart to display.
+        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
+        :param pulumi.Input[int] height: How many rows the chart should take up (greater than or equal to `1`). `1` by default.
+        :param pulumi.Input[int] row: The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
+        :param pulumi.Input[int] width: How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
         """
         pulumi.set(__self__, "chart_id", chart_id)
         if column is not None:
             pulumi.set(__self__, "column", column)
         if height is not None:
             pulumi.set(__self__, "height", height)
         if row is not None:
@@ -142,63 +142,63 @@
         if width is not None:
             pulumi.set(__self__, "width", width)
 
     @property
     @pulumi.getter(name="chartId")
     def chart_id(self) -> pulumi.Input[str]:
         """
-        ID of the chart to display
+        ID of the chart to display.
         """
         return pulumi.get(self, "chart_id")
 
     @chart_id.setter
     def chart_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "chart_id", value)
 
     @property
     @pulumi.getter
     def column(self) -> Optional[pulumi.Input[int]]:
         """
-        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
+        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
         """
         return pulumi.get(self, "column")
 
     @column.setter
     def column(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "column", value)
 
     @property
     @pulumi.getter
     def height(self) -> Optional[pulumi.Input[int]]:
         """
-        How many rows the chart should take up. (greater than or equal to 1)
+        How many rows the chart should take up (greater than or equal to `1`). `1` by default.
         """
         return pulumi.get(self, "height")
 
     @height.setter
     def height(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "height", value)
 
     @property
     @pulumi.getter
     def row(self) -> Optional[pulumi.Input[int]]:
         """
-        The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
+        The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
         """
         return pulumi.get(self, "row")
 
     @row.setter
     def row(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "row", value)
 
     @property
     @pulumi.getter
     def width(self) -> Optional[pulumi.Input[int]]:
         """
-        How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
+        How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
         """
         return pulumi.get(self, "width")
 
     @width.setter
     def width(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "width", value)
 
@@ -207,68 +207,68 @@
 class DashboardColumnArgs:
     def __init__(__self__, *,
                  chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                  column: Optional[pulumi.Input[int]] = None,
                  height: Optional[pulumi.Input[int]] = None,
                  width: Optional[pulumi.Input[int]] = None):
         """
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: Charts to use for the column
-        :param pulumi.Input[int] column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
-        :param pulumi.Input[int] height: How many rows each chart should take up. (greater than or equal to 1)
-        :param pulumi.Input[int] width: Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: List of IDs of the charts to display.
+        :param pulumi.Input[int] column: Column number for the layout.
+        :param pulumi.Input[int] height: How many rows every chart should take up (greater than or equal to 1). 1 by default.
+        :param pulumi.Input[int] width: How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
         """
         pulumi.set(__self__, "chart_ids", chart_ids)
         if column is not None:
             pulumi.set(__self__, "column", column)
         if height is not None:
             pulumi.set(__self__, "height", height)
         if width is not None:
             pulumi.set(__self__, "width", width)
 
     @property
     @pulumi.getter(name="chartIds")
     def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        Charts to use for the column
+        List of IDs of the charts to display.
         """
         return pulumi.get(self, "chart_ids")
 
     @chart_ids.setter
     def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "chart_ids", value)
 
     @property
     @pulumi.getter
     def column(self) -> Optional[pulumi.Input[int]]:
         """
-        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
+        Column number for the layout.
         """
         return pulumi.get(self, "column")
 
     @column.setter
     def column(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "column", value)
 
     @property
     @pulumi.getter
     def height(self) -> Optional[pulumi.Input[int]]:
         """
-        How many rows each chart should take up. (greater than or equal to 1)
+        How many rows every chart should take up (greater than or equal to 1). 1 by default.
         """
         return pulumi.get(self, "height")
 
     @height.setter
     def height(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "height", value)
 
     @property
     @pulumi.getter
     def width(self) -> Optional[pulumi.Input[int]]:
         """
-        Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
+        How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
         """
         return pulumi.get(self, "width")
 
     @width.setter
     def width(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "width", value)
 
@@ -279,19 +279,20 @@
                  signal: pulumi.Input[str],
                  color: Optional[pulumi.Input[str]] = None,
                  label: Optional[pulumi.Input[str]] = None,
                  line: Optional[pulumi.Input[bool]] = None,
                  sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]] = None,
                  type: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] signal: Search term used to define events
-        :param pulumi.Input[str] color: Color to use
-        :param pulumi.Input[str] label: The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
-        :param pulumi.Input[bool] line: (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
-        :param pulumi.Input[str] type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        :param pulumi.Input[str] signal: Search term used to choose the events shown in the overlay.
+        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
+        :param pulumi.Input[str] label: Text shown in the dropdown when selecting this overlay from the menu.
+        :param pulumi.Input[bool] line: Show a vertical line for the event. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]] sources: Each element specifies a filter to use against the signal specified in the `signal`.
+        :param pulumi.Input[str] type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         pulumi.set(__self__, "signal", signal)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if label is not None:
             pulumi.set(__self__, "label", label)
         if line is not None:
@@ -301,72 +302,75 @@
         if type is not None:
             pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def signal(self) -> pulumi.Input[str]:
         """
-        Search term used to define events
+        Search term used to choose the events shown in the overlay.
         """
         return pulumi.get(self, "signal")
 
     @signal.setter
     def signal(self, value: pulumi.Input[str]):
         pulumi.set(self, "signal", value)
 
     @property
     @pulumi.getter
     def color(self) -> Optional[pulumi.Input[str]]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color", value)
 
     @property
     @pulumi.getter
     def label(self) -> Optional[pulumi.Input[str]]:
         """
-        The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
+        Text shown in the dropdown when selecting this overlay from the menu.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter
     def line(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
+        Show a vertical line for the event. `false` by default.
         """
         return pulumi.get(self, "line")
 
     @line.setter
     def line(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "line", value)
 
     @property
     @pulumi.getter
     def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]:
+        """
+        Each element specifies a filter to use against the signal specified in the `signal`.
+        """
         return pulumi.get(self, "sources")
 
     @sources.setter
     def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardEventOverlaySourceArgs']]]]):
         pulumi.set(self, "sources", value)
 
     @property
     @pulumi.getter
     def type(self) -> Optional[pulumi.Input[str]]:
         """
-        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "type", value)
 
@@ -374,52 +378,52 @@
 @pulumi.input_type
 class DashboardEventOverlaySourceArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  values: pulumi.Input[Sequence[pulumi.Input[str]]],
                  negated: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: A metric time series dimension or property name
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
-        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
+        :param pulumi.Input[str] property: The name of a dimension to filter against.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to be used with the `property`, they will be combined via `OR`.
+        :param pulumi.Input[bool] negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        A list of values to be used with the `property`, they will be combined via `OR`.
         """
         return pulumi.get(self, "values")
 
     @values.setter
     def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "values", value)
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @negated.setter
     def negated(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "negated", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        A metric time series dimension or property name
+        The name of a dimension to filter against.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -428,67 +432,67 @@
 class DashboardFilterArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  values: pulumi.Input[Sequence[pulumi.Input[str]]],
                  apply_if_exist: Optional[pulumi.Input[bool]] = None,
                  negated: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: A metric time series dimension or property name
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
-        :param pulumi.Input[bool] apply_if_exist: If true, this filter will also match data that does not have the specified property
-        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
+        :param pulumi.Input[str] property: A metric time series dimension or property name.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of of strings (which will be treated as an OR filter on the property).
+        :param pulumi.Input[bool] apply_if_exist: If true, this filter will also match data that doesn't have this property at all.
+        :param pulumi.Input[bool] negated: Whether this filter should be a not filter. `false` by default.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if apply_if_exist is not None:
             pulumi.set(__self__, "apply_if_exist", apply_if_exist)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        List of of strings (which will be treated as an OR filter on the property).
         """
         return pulumi.get(self, "values")
 
     @values.setter
     def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "values", value)
 
     @property
     @pulumi.getter(name="applyIfExist")
     def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
         """
-        If true, this filter will also match data that does not have the specified property
+        If true, this filter will also match data that doesn't have this property at all.
         """
         return pulumi.get(self, "apply_if_exist")
 
     @apply_if_exist.setter
     def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "apply_if_exist", value)
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        Whether this filter should be a not filter. `false` by default.
         """
         return pulumi.get(self, "negated")
 
     @negated.setter
     def negated(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "negated", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        A metric time series dimension or property name
+        A metric time series dimension or property name.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -496,53 +500,53 @@
 @pulumi.input_type
 class DashboardGridArgs:
     def __init__(__self__, *,
                  chart_ids: pulumi.Input[Sequence[pulumi.Input[str]]],
                  height: Optional[pulumi.Input[int]] = None,
                  width: Optional[pulumi.Input[int]] = None):
         """
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: Charts to use for the grid
-        :param pulumi.Input[int] height: How many rows each chart should take up. (greater than or equal to 1)
-        :param pulumi.Input[int] width: Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] chart_ids: List of IDs of the charts to display.
+        :param pulumi.Input[int] height: How many rows every chart should take up (greater than or equal to `1`). `1` by default.
+        :param pulumi.Input[int] width: How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
         """
         pulumi.set(__self__, "chart_ids", chart_ids)
         if height is not None:
             pulumi.set(__self__, "height", height)
         if width is not None:
             pulumi.set(__self__, "width", width)
 
     @property
     @pulumi.getter(name="chartIds")
     def chart_ids(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        Charts to use for the grid
+        List of IDs of the charts to display.
         """
         return pulumi.get(self, "chart_ids")
 
     @chart_ids.setter
     def chart_ids(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "chart_ids", value)
 
     @property
     @pulumi.getter
     def height(self) -> Optional[pulumi.Input[int]]:
         """
-        How many rows each chart should take up. (greater than or equal to 1)
+        How many rows every chart should take up (greater than or equal to `1`). `1` by default.
         """
         return pulumi.get(self, "height")
 
     @height.setter
     def height(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "height", value)
 
     @property
     @pulumi.getter
     def width(self) -> Optional[pulumi.Input[int]]:
         """
-        Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
+        How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
         """
         return pulumi.get(self, "width")
 
     @width.setter
     def width(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "width", value)
 
@@ -553,19 +557,19 @@
                  dashboard_id: pulumi.Input[str],
                  config_id: Optional[pulumi.Input[str]] = None,
                  description_override: Optional[pulumi.Input[str]] = None,
                  filter_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]] = None,
                  name_override: Optional[pulumi.Input[str]] = None,
                  variable_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]]] = None):
         """
-        :param pulumi.Input[str] dashboard_id: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param pulumi.Input[str] config_id: Unique identifier of an association between a dashboard group and a dashboard
-        :param pulumi.Input[str] description_override: String that provides a description override for a mirrored dashboard
-        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]] filter_overrides: Filter to apply to each chart in the dashboard
-        :param pulumi.Input[str] name_override: String that provides a name override for a mirrored dashboard
+        :param pulumi.Input[str] dashboard_id: The dashboard id to mirror
+        :param pulumi.Input[str] config_id: The ID of the association between the dashboard group and the dashboard
+        :param pulumi.Input[str] description_override: The description that will override the original dashboards's description.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]] filter_overrides: The description that will override the original dashboards's description.
+        :param pulumi.Input[str] name_override: The name that will override the original dashboards's name.
         :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardVariableOverrideArgs']]] variable_overrides: Dashboard variable to apply to each chart in the dashboard
         """
         pulumi.set(__self__, "dashboard_id", dashboard_id)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if description_override is not None:
             pulumi.set(__self__, "description_override", description_override)
@@ -576,63 +580,63 @@
         if variable_overrides is not None:
             pulumi.set(__self__, "variable_overrides", variable_overrides)
 
     @property
     @pulumi.getter(name="dashboardId")
     def dashboard_id(self) -> pulumi.Input[str]:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        The dashboard id to mirror
         """
         return pulumi.get(self, "dashboard_id")
 
     @dashboard_id.setter
     def dashboard_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "dashboard_id", value)
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Unique identifier of an association between a dashboard group and a dashboard
+        The ID of the association between the dashboard group and the dashboard
         """
         return pulumi.get(self, "config_id")
 
     @config_id.setter
     def config_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "config_id", value)
 
     @property
     @pulumi.getter(name="descriptionOverride")
     def description_override(self) -> Optional[pulumi.Input[str]]:
         """
-        String that provides a description override for a mirrored dashboard
+        The description that will override the original dashboards's description.
         """
         return pulumi.get(self, "description_override")
 
     @description_override.setter
     def description_override(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description_override", value)
 
     @property
     @pulumi.getter(name="filterOverrides")
     def filter_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]:
         """
-        Filter to apply to each chart in the dashboard
+        The description that will override the original dashboards's description.
         """
         return pulumi.get(self, "filter_overrides")
 
     @filter_overrides.setter
     def filter_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardFilterOverrideArgs']]]]):
         pulumi.set(self, "filter_overrides", value)
 
     @property
     @pulumi.getter(name="nameOverride")
     def name_override(self) -> Optional[pulumi.Input[str]]:
         """
-        String that provides a name override for a mirrored dashboard
+        The name that will override the original dashboards's name.
         """
         return pulumi.get(self, "name_override")
 
     @name_override.setter
     def name_override(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name_override", value)
 
@@ -652,52 +656,52 @@
 @pulumi.input_type
 class DashboardGroupDashboardFilterOverrideArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  values: pulumi.Input[Sequence[pulumi.Input[str]]],
                  negated: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: A metric time series dimension or property name
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
-        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
+        :param pulumi.Input[str] property: A metric time series dimension or property name.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: (Optional) List of of strings (which will be treated as an OR filter on the property).
+        :param pulumi.Input[bool] negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        (Optional) List of of strings (which will be treated as an OR filter on the property).
         """
         return pulumi.get(self, "values")
 
     @values.setter
     def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "values", value)
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @negated.setter
     def negated(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "negated", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        A metric time series dimension or property name
+        A metric time series dimension or property name.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -847,91 +851,91 @@
 @pulumi.input_type
 class DashboardGroupPermissionArgs:
     def __init__(__self__, *,
                  principal_id: pulumi.Input[str],
                  principal_type: pulumi.Input[str],
                  actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
-        :param pulumi.Input[str] principal_id: ID of the principal with access
-        :param pulumi.Input[str] principal_type: Type of principal, possible values: ORG, TEAM, USER
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Actions level, possible values: READ, WRITE
+        :param pulumi.Input[str] principal_id: ID of the user, team, or organization for which you're granting permissions.
+        :param pulumi.Input[str] principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
         """
         pulumi.set(__self__, "principal_id", principal_id)
         pulumi.set(__self__, "principal_type", principal_type)
         if actions is not None:
             pulumi.set(__self__, "actions", actions)
 
     @property
     @pulumi.getter(name="principalId")
     def principal_id(self) -> pulumi.Input[str]:
         """
-        ID of the principal with access
+        ID of the user, team, or organization for which you're granting permissions.
         """
         return pulumi.get(self, "principal_id")
 
     @principal_id.setter
     def principal_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "principal_id", value)
 
     @property
     @pulumi.getter(name="principalType")
     def principal_type(self) -> pulumi.Input[str]:
         """
-        Type of principal, possible values: ORG, TEAM, USER
+        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
         """
         return pulumi.get(self, "principal_type")
 
     @principal_type.setter
     def principal_type(self, value: pulumi.Input[str]):
         pulumi.set(self, "principal_type", value)
 
     @property
     @pulumi.getter
     def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Actions level, possible values: READ, WRITE
+        Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
         """
         return pulumi.get(self, "actions")
 
     @actions.setter
     def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "actions", value)
 
 
 @pulumi.input_type
 class DashboardPermissionsArgs:
     def __init__(__self__, *,
                  acls: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]] = None,
                  parent: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]] acls: The custom access control list for this dashboard
-        :param pulumi.Input[str] parent: The ID of the dashboard group that this dashboard inherits permissions from
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]] acls: List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
+        :param pulumi.Input[str] parent: ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
         """
         if acls is not None:
             pulumi.set(__self__, "acls", acls)
         if parent is not None:
             pulumi.set(__self__, "parent", parent)
 
     @property
     @pulumi.getter
     def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]:
         """
-        The custom access control list for this dashboard
+        List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
         """
         return pulumi.get(self, "acls")
 
     @acls.setter
     def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPermissionsAclArgs']]]]):
         pulumi.set(self, "acls", value)
 
     @property
     @pulumi.getter
     def parent(self) -> Optional[pulumi.Input[str]]:
         """
-        The ID of the dashboard group that this dashboard inherits permissions from
+        ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
         """
         return pulumi.get(self, "parent")
 
     @parent.setter
     def parent(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "parent", value)
 
@@ -939,52 +943,52 @@
 @pulumi.input_type
 class DashboardPermissionsAclArgs:
     def __init__(__self__, *,
                  principal_id: pulumi.Input[str],
                  principal_type: pulumi.Input[str],
                  actions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
-        :param pulumi.Input[str] principal_id: ID of the principal with access
-        :param pulumi.Input[str] principal_type: Type of principal, possible values: ORG, TEAM, USER
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Actions level, possible values: READ, WRITE
+        :param pulumi.Input[str] principal_id: ID of the user, team, or organization for which you're granting permissions.
+        :param pulumi.Input[str] principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] actions: Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
         """
         pulumi.set(__self__, "principal_id", principal_id)
         pulumi.set(__self__, "principal_type", principal_type)
         if actions is not None:
             pulumi.set(__self__, "actions", actions)
 
     @property
     @pulumi.getter(name="principalId")
     def principal_id(self) -> pulumi.Input[str]:
         """
-        ID of the principal with access
+        ID of the user, team, or organization for which you're granting permissions.
         """
         return pulumi.get(self, "principal_id")
 
     @principal_id.setter
     def principal_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "principal_id", value)
 
     @property
     @pulumi.getter(name="principalType")
     def principal_type(self) -> pulumi.Input[str]:
         """
-        Type of principal, possible values: ORG, TEAM, USER
+        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
         """
         return pulumi.get(self, "principal_type")
 
     @principal_type.setter
     def principal_type(self, value: pulumi.Input[str]):
         pulumi.set(self, "principal_type", value)
 
     @property
     @pulumi.getter
     def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Actions level, possible values: READ, WRITE
+        Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
         """
         return pulumi.get(self, "actions")
 
     @actions.setter
     def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "actions", value)
 
@@ -992,49 +996,53 @@
 @pulumi.input_type
 class DashboardSelectedEventOverlayArgs:
     def __init__(__self__, *,
                  signal: pulumi.Input[str],
                  sources: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]] = None,
                  type: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] signal: Search term used to define events
-        :param pulumi.Input[str] type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        :param pulumi.Input[str] signal: Search term used to choose the events shown in the overlay.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]] sources: Each element specifies a filter to use against the signal specified in the `signal`.
+        :param pulumi.Input[str] type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         pulumi.set(__self__, "signal", signal)
         if sources is not None:
             pulumi.set(__self__, "sources", sources)
         if type is not None:
             pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def signal(self) -> pulumi.Input[str]:
         """
-        Search term used to define events
+        Search term used to choose the events shown in the overlay.
         """
         return pulumi.get(self, "signal")
 
     @signal.setter
     def signal(self, value: pulumi.Input[str]):
         pulumi.set(self, "signal", value)
 
     @property
     @pulumi.getter
     def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]:
+        """
+        Each element specifies a filter to use against the signal specified in the `signal`.
+        """
         return pulumi.get(self, "sources")
 
     @sources.setter
     def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardSelectedEventOverlaySourceArgs']]]]):
         pulumi.set(self, "sources", value)
 
     @property
     @pulumi.getter
     def type(self) -> Optional[pulumi.Input[str]]:
         """
-        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "type", value)
 
@@ -1042,52 +1050,52 @@
 @pulumi.input_type
 class DashboardSelectedEventOverlaySourceArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  values: pulumi.Input[Sequence[pulumi.Input[str]]],
                  negated: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: A metric time series dimension or property name
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
-        :param pulumi.Input[bool] negated: (false by default) Whether this filter should be a "not" filter
+        :param pulumi.Input[str] property: The name of a dimension to filter against.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: A list of values to be used with the `property`, they will be combined via `OR`.
+        :param pulumi.Input[bool] negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        A list of values to be used with the `property`, they will be combined via `OR`.
         """
         return pulumi.get(self, "values")
 
     @values.setter
     def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "values", value)
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @negated.setter
     def negated(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "negated", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        A metric time series dimension or property name
+        The name of a dimension to filter against.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -1101,23 +1109,23 @@
                  description: Optional[pulumi.Input[str]] = None,
                  replace_only: Optional[pulumi.Input[bool]] = None,
                  restricted_suggestions: Optional[pulumi.Input[bool]] = None,
                  value_required: Optional[pulumi.Input[bool]] = None,
                  values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  values_suggesteds: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
-        :param pulumi.Input[str] alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
-        :param pulumi.Input[str] property: A metric time series dimension or property name
-        :param pulumi.Input[bool] apply_if_exist: If true, this variable will also match data that does not have the specified property
-        :param pulumi.Input[str] description: Variable description
-        :param pulumi.Input[bool] replace_only: If true, this variable will only apply to charts with a filter on the named property.
-        :param pulumi.Input[bool] restricted_suggestions: If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
-        :param pulumi.Input[bool] value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of strings (which will be treated as an OR filter on the property)
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
+        :param pulumi.Input[str] alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
+        :param pulumi.Input[str] property: A metric time series dimension or property name.
+        :param pulumi.Input[bool] apply_if_exist: If true, this variable will also match data that doesn't have this property at all.
+        :param pulumi.Input[str] description: Variable description.
+        :param pulumi.Input[bool] replace_only: If `true`, this variable will only apply to charts that have a filter for the property.
+        :param pulumi.Input[bool] restricted_suggestions: If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
+        :param pulumi.Input[bool] value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] values: List of of strings (which will be treated as an OR filter on the property).
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
         """
         pulumi.set(__self__, "alias", alias)
         pulumi.set(__self__, "property", property)
         if apply_if_exist is not None:
             pulumi.set(__self__, "apply_if_exist", apply_if_exist)
         if description is not None:
             pulumi.set(__self__, "description", description)
@@ -1132,111 +1140,111 @@
         if values_suggesteds is not None:
             pulumi.set(__self__, "values_suggesteds", values_suggesteds)
 
     @property
     @pulumi.getter
     def alias(self) -> pulumi.Input[str]:
         """
-        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
+        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
         """
         return pulumi.get(self, "alias")
 
     @alias.setter
     def alias(self, value: pulumi.Input[str]):
         pulumi.set(self, "alias", value)
 
     @property
     @pulumi.getter(name="applyIfExist")
     def apply_if_exist(self) -> Optional[pulumi.Input[bool]]:
         """
-        If true, this variable will also match data that does not have the specified property
+        If true, this variable will also match data that doesn't have this property at all.
         """
         return pulumi.get(self, "apply_if_exist")
 
     @apply_if_exist.setter
     def apply_if_exist(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "apply_if_exist", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Variable description
+        Variable description.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="replaceOnly")
     def replace_only(self) -> Optional[pulumi.Input[bool]]:
         """
-        If true, this variable will only apply to charts with a filter on the named property.
+        If `true`, this variable will only apply to charts that have a filter for the property.
         """
         return pulumi.get(self, "replace_only")
 
     @replace_only.setter
     def replace_only(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "replace_only", value)
 
     @property
     @pulumi.getter(name="restrictedSuggestions")
     def restricted_suggestions(self) -> Optional[pulumi.Input[bool]]:
         """
-        If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
+        If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
         """
         return pulumi.get(self, "restricted_suggestions")
 
     @restricted_suggestions.setter
     def restricted_suggestions(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "restricted_suggestions", value)
 
     @property
     @pulumi.getter(name="valueRequired")
     def value_required(self) -> Optional[pulumi.Input[bool]]:
         """
-        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
+        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
         """
         return pulumi.get(self, "value_required")
 
     @value_required.setter
     def value_required(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "value_required", value)
 
     @property
     @pulumi.getter
     def values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        List of of strings (which will be treated as an OR filter on the property).
         """
         return pulumi.get(self, "values")
 
     @values.setter
     def values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "values", value)
 
     @property
     @pulumi.getter(name="valuesSuggesteds")
     def values_suggesteds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
+        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
         """
         return pulumi.get(self, "values_suggesteds")
 
     @values_suggesteds.setter
     def values_suggesteds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "values_suggesteds", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        A metric time series dimension or property name
+        A metric time series dimension or property name.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -1247,18 +1255,18 @@
                  name: pulumi.Input[str],
                  url: pulumi.Input[str],
                  minimum_time_window: Optional[pulumi.Input[str]] = None,
                  property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                  time_format: Optional[pulumi.Input[str]] = None):
         """
         :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-        :param pulumi.Input[str] url: URL string for a Splunk instance or external system data link target.
-        :param pulumi.Input[str] minimum_time_window: The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
-        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
-        :param pulumi.Input[str] time_format: Designates the format of minimumTimeWindow in the same data link target object.
+        :param pulumi.Input[str] url: URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
+        :param pulumi.Input[str] minimum_time_window: The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
+        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
+        :param pulumi.Input[str] time_format: [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
         """
         pulumi.set(__self__, "name", name)
         pulumi.set(__self__, "url", url)
         if minimum_time_window is not None:
             pulumi.set(__self__, "minimum_time_window", minimum_time_window)
         if property_key_mapping is not None:
             pulumi.set(__self__, "property_key_mapping", property_key_mapping)
@@ -1277,51 +1285,51 @@
     def name(self, value: pulumi.Input[str]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Input[str]:
         """
-        URL string for a Splunk instance or external system data link target.
+        URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: pulumi.Input[str]):
         pulumi.set(self, "url", value)
 
     @property
     @pulumi.getter(name="minimumTimeWindow")
     def minimum_time_window(self) -> Optional[pulumi.Input[str]]:
         """
-        The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
+        The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
         """
         return pulumi.get(self, "minimum_time_window")
 
     @minimum_time_window.setter
     def minimum_time_window(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "minimum_time_window", value)
 
     @property
     @pulumi.getter(name="propertyKeyMapping")
     def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
         """
-        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
+        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
         """
         return pulumi.get(self, "property_key_mapping")
 
     @property_key_mapping.setter
     def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
         pulumi.set(self, "property_key_mapping", value)
 
     @property
     @pulumi.getter(name="timeFormat")
     def time_format(self) -> Optional[pulumi.Input[str]]:
         """
-        Designates the format of minimumTimeWindow in the same data link target object.
+        [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
         """
         return pulumi.get(self, "time_format")
 
     @time_format.setter
     def time_format(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "time_format", value)
 
@@ -1333,15 +1341,15 @@
                  dashboard_id: pulumi.Input[str],
                  name: pulumi.Input[str],
                  is_default: Optional[pulumi.Input[bool]] = None):
         """
         :param pulumi.Input[str] dashboard_group_id: SignalFx-assigned ID of the dashboard link target's dashboard group
         :param pulumi.Input[str] dashboard_id: SignalFx-assigned ID of the dashboard link target
         :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-        :param pulumi.Input[bool] is_default: Flag that designates a target as the default for a data link object.
+        :param pulumi.Input[bool] is_default: Flag that designates a target as the default for a data link object. `true` by default
         """
         pulumi.set(__self__, "dashboard_group_id", dashboard_group_id)
         pulumi.set(__self__, "dashboard_id", dashboard_id)
         pulumi.set(__self__, "name", name)
         if is_default is not None:
             pulumi.set(__self__, "is_default", is_default)
 
@@ -1381,15 +1389,15 @@
     def name(self, value: pulumi.Input[str]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="isDefault")
     def is_default(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that designates a target as the default for a data link object.
+        Flag that designates a target as the default for a data link object. `true` by default
         """
         return pulumi.get(self, "is_default")
 
     @is_default.setter
     def is_default(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "is_default", value)
 
@@ -1397,15 +1405,15 @@
 @pulumi.input_type
 class DataLinkTargetSplunkArgs:
     def __init__(__self__, *,
                  name: pulumi.Input[str],
                  property_key_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
         """
         :param pulumi.Input[str] name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
+        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
         """
         pulumi.set(__self__, "name", name)
         if property_key_mapping is not None:
             pulumi.set(__self__, "property_key_mapping", property_key_mapping)
 
     @property
     @pulumi.getter
@@ -1419,15 +1427,15 @@
     def name(self, value: pulumi.Input[str]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="propertyKeyMapping")
     def property_key_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
         """
-        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
+        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
         """
         return pulumi.get(self, "property_key_mapping")
 
     @property_key_mapping.setter
     def property_key_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
         pulumi.set(self, "property_key_mapping", value)
 
@@ -1441,23 +1449,23 @@
                  disabled: Optional[pulumi.Input[bool]] = None,
                  notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  parameterized_body: Optional[pulumi.Input[str]] = None,
                  parameterized_subject: Optional[pulumi.Input[str]] = None,
                  runbook_url: Optional[pulumi.Input[str]] = None,
                  tip: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] detect_label: A detect label which matches a detect label within the program text
-        :param pulumi.Input[str] severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
-        :param pulumi.Input[str] description: Description of the rule
-        :param pulumi.Input[bool] disabled: (default: false) When true, notifications and events will not be generated for the detect label
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
-        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
-        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
-        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered
-        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command to execute.
+        :param pulumi.Input[str] detect_label: A detect label which matches a detect label within `program_text`.
+        :param pulumi.Input[str] severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
+        :param pulumi.Input[str] description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
+        :param pulumi.Input[bool] disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
+        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
+        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
+        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
+        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         pulumi.set(__self__, "detect_label", detect_label)
         pulumi.set(__self__, "severity", severity)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if disabled is not None:
             pulumi.set(__self__, "disabled", disabled)
@@ -1472,111 +1480,111 @@
         if tip is not None:
             pulumi.set(__self__, "tip", tip)
 
     @property
     @pulumi.getter(name="detectLabel")
     def detect_label(self) -> pulumi.Input[str]:
         """
-        A detect label which matches a detect label within the program text
+        A detect label which matches a detect label within `program_text`.
         """
         return pulumi.get(self, "detect_label")
 
     @detect_label.setter
     def detect_label(self, value: pulumi.Input[str]):
         pulumi.set(self, "detect_label", value)
 
     @property
     @pulumi.getter
     def severity(self) -> pulumi.Input[str]:
         """
-        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
+        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
         """
         return pulumi.get(self, "severity")
 
     @severity.setter
     def severity(self, value: pulumi.Input[str]):
         pulumi.set(self, "severity", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the rule
+        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def disabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        (default: false) When true, notifications and events will not be generated for the detect label
+        When true, notifications and events will not be generated for the detect label. `false` by default.
         """
         return pulumi.get(self, "disabled")
 
     @disabled.setter
     def disabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disabled", value)
 
     @property
     @pulumi.getter
     def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
         """
         return pulumi.get(self, "notifications")
 
     @notifications.setter
     def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications", value)
 
     @property
     @pulumi.getter(name="parameterizedBody")
     def parameterized_body(self) -> Optional[pulumi.Input[str]]:
         """
-        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
         """
         return pulumi.get(self, "parameterized_body")
 
     @parameterized_body.setter
     def parameterized_body(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "parameterized_body", value)
 
     @property
     @pulumi.getter(name="parameterizedSubject")
     def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
         """
-        Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
         """
         return pulumi.get(self, "parameterized_subject")
 
     @parameterized_subject.setter
     def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "parameterized_subject", value)
 
     @property
     @pulumi.getter(name="runbookUrl")
     def runbook_url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of page to consult when an alert is triggered
+        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
         """
         return pulumi.get(self, "runbook_url")
 
     @runbook_url.setter
     def runbook_url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "runbook_url", value)
 
     @property
     @pulumi.getter
     def tip(self) -> Optional[pulumi.Input[str]]:
         """
-        Plain text suggested first course of action, such as a command to execute.
+        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         return pulumi.get(self, "tip")
 
     @tip.setter
     def tip(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "tip", value)
 
@@ -1587,20 +1595,24 @@
                  label: pulumi.Input[str],
                  color: Optional[pulumi.Input[str]] = None,
                  display_name: Optional[pulumi.Input[str]] = None,
                  value_prefix: Optional[pulumi.Input[str]] = None,
                  value_suffix: Optional[pulumi.Input[str]] = None,
                  value_unit: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param pulumi.Input[str] color: Color to use
+        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
+        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
+               
+               **Notes**
+               
+               Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
         :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
-        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
         if value_prefix is not None:
@@ -1610,27 +1622,27 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> pulumi.Input[str]:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: pulumi.Input[str]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter
     def color(self) -> Optional[pulumi.Input[str]]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color", value)
 
@@ -1646,15 +1658,19 @@
     def display_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "display_name", value)
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
+
+        **Notes**
+
+        Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
         """
         return pulumi.get(self, "value_prefix")
 
     @value_prefix.setter
     def value_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_prefix", value)
 
@@ -1670,15 +1686,15 @@
     def value_suffix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_suffix", value)
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[pulumi.Input[str]]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
     @value_unit.setter
     def value_unit(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_unit", value)
 
@@ -1687,16 +1703,16 @@
 class HeatmapChartColorRangeArgs:
     def __init__(__self__, *,
                  color: pulumi.Input[str],
                  max_value: Optional[pulumi.Input[float]] = None,
                  min_value: Optional[pulumi.Input[float]] = None):
         """
         :param pulumi.Input[str] color: The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
-        :param pulumi.Input[float] max_value: The maximum value within the coloring range
-        :param pulumi.Input[float] min_value: The minimum value within the coloring range
+        :param pulumi.Input[float] max_value: The maximum value within the coloring range.
+        :param pulumi.Input[float] min_value: The minimum value within the coloring range.
         """
         pulumi.set(__self__, "color", color)
         if max_value is not None:
             pulumi.set(__self__, "max_value", max_value)
         if min_value is not None:
             pulumi.set(__self__, "min_value", min_value)
 
@@ -1712,27 +1728,27 @@
     def color(self, value: pulumi.Input[str]):
         pulumi.set(self, "color", value)
 
     @property
     @pulumi.getter(name="maxValue")
     def max_value(self) -> Optional[pulumi.Input[float]]:
         """
-        The maximum value within the coloring range
+        The maximum value within the coloring range.
         """
         return pulumi.get(self, "max_value")
 
     @max_value.setter
     def max_value(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "max_value", value)
 
     @property
     @pulumi.getter(name="minValue")
     def min_value(self) -> Optional[pulumi.Input[float]]:
         """
-        The minimum value within the coloring range
+        The minimum value within the coloring range.
         """
         return pulumi.get(self, "min_value")
 
     @min_value.setter
     def min_value(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "min_value", value)
 
@@ -1742,19 +1758,19 @@
     def __init__(__self__, *,
                  color: pulumi.Input[str],
                  gt: Optional[pulumi.Input[float]] = None,
                  gte: Optional[pulumi.Input[float]] = None,
                  lt: Optional[pulumi.Input[float]] = None,
                  lte: Optional[pulumi.Input[float]] = None):
         """
-        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
-        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
-        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
-        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
+        :param pulumi.Input[str] color: The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
+        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range.
+        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range.
+        :param pulumi.Input[float] lt: Indicates the upper threshold non-inclusive value for this range.
+        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range.
         """
         pulumi.set(__self__, "color", color)
         if gt is not None:
             pulumi.set(__self__, "gt", gt)
         if gte is not None:
             pulumi.set(__self__, "gte", gte)
         if lt is not None:
@@ -1762,63 +1778,63 @@
         if lte is not None:
             pulumi.set(__self__, "lte", lte)
 
     @property
     @pulumi.getter
     def color(self) -> pulumi.Input[str]:
         """
-        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
+        The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: pulumi.Input[str]):
         pulumi.set(self, "color", value)
 
     @property
     @pulumi.getter
     def gt(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the lower threshold non-inclusive value for this range
+        Indicates the lower threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "gt")
 
     @gt.setter
     def gt(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "gt", value)
 
     @property
     @pulumi.getter
     def gte(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the lower threshold inclusive value for this range
+        Indicates the lower threshold inclusive value for this range.
         """
         return pulumi.get(self, "gte")
 
     @gte.setter
     def gte(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "gte", value)
 
     @property
     @pulumi.getter
     def lt(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the upper threshold non-inculsive value for this range
+        Indicates the upper threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "lt")
 
     @lt.setter
     def lt(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "lt", value)
 
     @property
     @pulumi.getter
     def lte(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the upper threshold inclusive value for this range
+        Indicates the upper threshold inclusive value for this range.
         """
         return pulumi.get(self, "lte")
 
     @lte.setter
     def lte(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "lte", value)
 
@@ -1829,18 +1845,18 @@
                  color: pulumi.Input[str],
                  gt: Optional[pulumi.Input[float]] = None,
                  gte: Optional[pulumi.Input[float]] = None,
                  lt: Optional[pulumi.Input[float]] = None,
                  lte: Optional[pulumi.Input[float]] = None):
         """
         :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
-        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
-        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
-        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
+        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range.
+        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range.
+        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range.
+        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range.
         """
         pulumi.set(__self__, "color", color)
         if gt is not None:
             pulumi.set(__self__, "gt", gt)
         if gte is not None:
             pulumi.set(__self__, "gte", gte)
         if lt is not None:
@@ -1860,89 +1876,89 @@
     def color(self, value: pulumi.Input[str]):
         pulumi.set(self, "color", value)
 
     @property
     @pulumi.getter
     def gt(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the lower threshold non-inclusive value for this range
+        Indicates the lower threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "gt")
 
     @gt.setter
     def gt(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "gt", value)
 
     @property
     @pulumi.getter
     def gte(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the lower threshold inclusive value for this range
+        Indicates the lower threshold inclusive value for this range.
         """
         return pulumi.get(self, "gte")
 
     @gte.setter
     def gte(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "gte", value)
 
     @property
     @pulumi.getter
     def lt(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the upper threshold non-inculsive value for this range
+        Indicates the upper threshold non-inculsive value for this range.
         """
         return pulumi.get(self, "lt")
 
     @lt.setter
     def lt(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "lt", value)
 
     @property
     @pulumi.getter
     def lte(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the upper threshold inclusive value for this range
+        Indicates the upper threshold inclusive value for this range.
         """
         return pulumi.get(self, "lte")
 
     @lte.setter
     def lte(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "lte", value)
 
 
 @pulumi.input_type
 class ListChartLegendOptionsFieldArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  enabled: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: The name of a property to hide or show in the data table.
-        :param pulumi.Input[bool] enabled: (true by default) Determines if this property is displayed in the data table.
+        :param pulumi.Input[str] property: The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
+        :param pulumi.Input[bool] enabled: True or False depending on if you want the property to be shown or hidden.
         """
         pulumi.set(__self__, "property", property)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        (true by default) Determines if this property is displayed in the data table.
+        True or False depending on if you want the property to be shown or hidden.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        The name of a property to hide or show in the data table.
+        The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -1953,20 +1969,20 @@
                  label: pulumi.Input[str],
                  color: Optional[pulumi.Input[str]] = None,
                  display_name: Optional[pulumi.Input[str]] = None,
                  value_prefix: Optional[pulumi.Input[str]] = None,
                  value_suffix: Optional[pulumi.Input[str]] = None,
                  value_unit: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param pulumi.Input[str] color: Color to use
+        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
+        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
-        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
         if value_prefix is not None:
@@ -1976,27 +1992,27 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> pulumi.Input[str]:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: pulumi.Input[str]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter
     def color(self) -> Optional[pulumi.Input[str]]:
         """
-        Color to use
+        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color", value)
 
@@ -2012,15 +2028,15 @@
     def display_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "display_name", value)
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         """
         return pulumi.get(self, "value_prefix")
 
     @value_prefix.setter
     def value_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_prefix", value)
 
@@ -2036,15 +2052,15 @@
     def value_suffix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_suffix", value)
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[pulumi.Input[str]]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
     @value_unit.setter
     def value_unit(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_unit", value)
 
@@ -2053,66 +2069,66 @@
 class MetricRulesetAggregationRuleArgs:
     def __init__(__self__, *,
                  aggregators: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]],
                  enabled: pulumi.Input[bool],
                  matchers: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]],
                  name: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]] aggregators: The aggregator for this rule
-        :param pulumi.Input[bool] enabled: Status of this aggregation rule
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]] matchers: The matcher for this rule
-        :param pulumi.Input[str] name: Name of this aggregation rule
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]] aggregators: Aggregator object
+        :param pulumi.Input[bool] enabled: When false, this rule will not generate aggregated MTSs
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]] matchers: Matcher object
+        :param pulumi.Input[str] name: name of the aggregation rule
         """
         pulumi.set(__self__, "aggregators", aggregators)
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "matchers", matchers)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def aggregators(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]:
         """
-        The aggregator for this rule
+        Aggregator object
         """
         return pulumi.get(self, "aggregators")
 
     @aggregators.setter
     def aggregators(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleAggregatorArgs']]]):
         pulumi.set(self, "aggregators", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Status of this aggregation rule
+        When false, this rule will not generate aggregated MTSs
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def matchers(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]:
         """
-        The matcher for this rule
+        Matcher object
         """
         return pulumi.get(self, "matchers")
 
     @matchers.setter
     def matchers(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherArgs']]]):
         pulumi.set(self, "matchers", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of this aggregation rule
+        name of the aggregation rule
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -2121,103 +2137,103 @@
 class MetricRulesetAggregationRuleAggregatorArgs:
     def __init__(__self__, *,
                  dimensions: pulumi.Input[Sequence[pulumi.Input[str]]],
                  drop_dimensions: pulumi.Input[bool],
                  output_name: pulumi.Input[str],
                  type: pulumi.Input[str]):
         """
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: List of dimensions to keep or drop in aggregated metric
-        :param pulumi.Input[bool] drop_dimensions: Flag specifying to keep or drop given dimensions
-        :param pulumi.Input[str] output_name: The aggregated metric name
-        :param pulumi.Input[str] type: The type of the aggregator
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] dimensions: List of dimensions to either be kept or dropped in the new aggregated MTSs
+        :param pulumi.Input[bool] drop_dimensions: when true, the specified dimensions will be dropped from the aggregated MTSs
+        :param pulumi.Input[str] output_name: name of the new aggregated metric
+        :param pulumi.Input[str] type: Type of aggregator. Must always be "rollup"
         """
         pulumi.set(__self__, "dimensions", dimensions)
         pulumi.set(__self__, "drop_dimensions", drop_dimensions)
         pulumi.set(__self__, "output_name", output_name)
         pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def dimensions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of dimensions to keep or drop in aggregated metric
+        List of dimensions to either be kept or dropped in the new aggregated MTSs
         """
         return pulumi.get(self, "dimensions")
 
     @dimensions.setter
     def dimensions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "dimensions", value)
 
     @property
     @pulumi.getter(name="dropDimensions")
     def drop_dimensions(self) -> pulumi.Input[bool]:
         """
-        Flag specifying to keep or drop given dimensions
+        when true, the specified dimensions will be dropped from the aggregated MTSs
         """
         return pulumi.get(self, "drop_dimensions")
 
     @drop_dimensions.setter
     def drop_dimensions(self, value: pulumi.Input[bool]):
         pulumi.set(self, "drop_dimensions", value)
 
     @property
     @pulumi.getter(name="outputName")
     def output_name(self) -> pulumi.Input[str]:
         """
-        The aggregated metric name
+        name of the new aggregated metric
         """
         return pulumi.get(self, "output_name")
 
     @output_name.setter
     def output_name(self, value: pulumi.Input[str]):
         pulumi.set(self, "output_name", value)
 
     @property
     @pulumi.getter
     def type(self) -> pulumi.Input[str]:
         """
-        The type of the aggregator
+        Type of aggregator. Must always be "rollup"
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: pulumi.Input[str]):
         pulumi.set(self, "type", value)
 
 
 @pulumi.input_type
 class MetricRulesetAggregationRuleMatcherArgs:
     def __init__(__self__, *,
                  type: pulumi.Input[str],
                  filters: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]] = None):
         """
-        :param pulumi.Input[str] type: The type of the matcher
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]] filters: List of filters to match on
+        :param pulumi.Input[str] type: Type of matcher. Must always be "dimension"
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]] filters: List of filters to filter the set of input MTSs
         """
         pulumi.set(__self__, "type", type)
         if filters is not None:
             pulumi.set(__self__, "filters", filters)
 
     @property
     @pulumi.getter
     def type(self) -> pulumi.Input[str]:
         """
-        The type of the matcher
+        Type of matcher. Must always be "dimension"
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: pulumi.Input[str]):
         pulumi.set(self, "type", value)
 
     @property
     @pulumi.getter
     def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]:
         """
-        List of filters to match on
+        List of filters to filter the set of input MTSs
         """
         return pulumi.get(self, "filters")
 
     @filters.setter
     def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleMatcherFilterArgs']]]]):
         pulumi.set(self, "filters", value)
 
@@ -2225,73 +2241,73 @@
 @pulumi.input_type
 class MetricRulesetAggregationRuleMatcherFilterArgs:
     def __init__(__self__, *,
                  not_: pulumi.Input[bool],
                  property: pulumi.Input[str],
                  property_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
         """
-        :param pulumi.Input[bool] not_: Flag specifying equals or not equals
-        :param pulumi.Input[str] property: Name of dimension to match
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_values: List of property values to match
+        :param pulumi.Input[bool] not_: When true, this filter will match all values not matching the property_values
+        :param pulumi.Input[str] property: Name of the dimension
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] property_values: Value of the dimension
         """
         pulumi.set(__self__, "not_", not_)
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "property_values", property_values)
 
     @property
     @pulumi.getter(name="not")
     def not_(self) -> pulumi.Input[bool]:
         """
-        Flag specifying equals or not equals
+        When true, this filter will match all values not matching the property_values
         """
         return pulumi.get(self, "not_")
 
     @not_.setter
     def not_(self, value: pulumi.Input[bool]):
         pulumi.set(self, "not_", value)
 
     @property
     @pulumi.getter(name="propertyValues")
     def property_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of property values to match
+        Value of the dimension
         """
         return pulumi.get(self, "property_values")
 
     @property_values.setter
     def property_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "property_values", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        Name of dimension to match
+        Name of the dimension
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
 
 @pulumi.input_type
 class MetricRulesetRoutingRuleArgs:
     def __init__(__self__, *,
                  destination: pulumi.Input[str]):
         """
-        :param pulumi.Input[str] destination: Destination to send the input metric
+        :param pulumi.Input[str] destination: end destination of the input metric. Must be `RealTime` or `Drop`
         """
         pulumi.set(__self__, "destination", destination)
 
     @property
     @pulumi.getter
     def destination(self) -> pulumi.Input[str]:
         """
-        Destination to send the input metric
+        end destination of the input metric. Must be `RealTime` or `Drop`
         """
         return pulumi.get(self, "destination")
 
     @destination.setter
     def destination(self, value: pulumi.Input[str]):
         pulumi.set(self, "destination", value)
 
@@ -2342,20 +2358,20 @@
                  custom_metrics_limit: Optional[pulumi.Input[int]] = None,
                  custom_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                  high_res_metrics_limit: Optional[pulumi.Input[int]] = None,
                  high_res_metrics_notification_threshold: Optional[pulumi.Input[int]] = None,
                  host_limit: Optional[pulumi.Input[int]] = None,
                  host_notification_threshold: Optional[pulumi.Input[int]] = None):
         """
-        :param pulumi.Input[int] container_limit: Max number of containers that can use this token
-        :param pulumi.Input[int] container_notification_threshold: Notification threshold for containers
+        :param pulumi.Input[int] container_limit: Max number of Docker containers that can use this token
+        :param pulumi.Input[int] container_notification_threshold: Notification threshold for Docker containers
         :param pulumi.Input[int] custom_metrics_limit: Max number of custom metrics that can be sent with this token
         :param pulumi.Input[int] custom_metrics_notification_threshold: Notification threshold for custom metrics
-        :param pulumi.Input[int] high_res_metrics_limit: Max number of high-res metrics that can be sent with this token
-        :param pulumi.Input[int] high_res_metrics_notification_threshold: Notification threshold for high-res metrics
+        :param pulumi.Input[int] high_res_metrics_limit: Max number of hi-res metrics that can be sent with this toke
+        :param pulumi.Input[int] high_res_metrics_notification_threshold: Notification threshold for hi-res metrics
         :param pulumi.Input[int] host_limit: Max number of hosts that can use this token
         :param pulumi.Input[int] host_notification_threshold: Notification threshold for hosts
         """
         if container_limit is not None:
             pulumi.set(__self__, "container_limit", container_limit)
         if container_notification_threshold is not None:
             pulumi.set(__self__, "container_notification_threshold", container_notification_threshold)
@@ -2372,27 +2388,27 @@
         if host_notification_threshold is not None:
             pulumi.set(__self__, "host_notification_threshold", host_notification_threshold)
 
     @property
     @pulumi.getter(name="containerLimit")
     def container_limit(self) -> Optional[pulumi.Input[int]]:
         """
-        Max number of containers that can use this token
+        Max number of Docker containers that can use this token
         """
         return pulumi.get(self, "container_limit")
 
     @container_limit.setter
     def container_limit(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "container_limit", value)
 
     @property
     @pulumi.getter(name="containerNotificationThreshold")
     def container_notification_threshold(self) -> Optional[pulumi.Input[int]]:
         """
-        Notification threshold for containers
+        Notification threshold for Docker containers
         """
         return pulumi.get(self, "container_notification_threshold")
 
     @container_notification_threshold.setter
     def container_notification_threshold(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "container_notification_threshold", value)
 
@@ -2420,27 +2436,27 @@
     def custom_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "custom_metrics_notification_threshold", value)
 
     @property
     @pulumi.getter(name="highResMetricsLimit")
     def high_res_metrics_limit(self) -> Optional[pulumi.Input[int]]:
         """
-        Max number of high-res metrics that can be sent with this token
+        Max number of hi-res metrics that can be sent with this toke
         """
         return pulumi.get(self, "high_res_metrics_limit")
 
     @high_res_metrics_limit.setter
     def high_res_metrics_limit(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "high_res_metrics_limit", value)
 
     @property
     @pulumi.getter(name="highResMetricsNotificationThreshold")
     def high_res_metrics_notification_threshold(self) -> Optional[pulumi.Input[int]]:
         """
-        Notification threshold for high-res metrics
+        Notification threshold for hi-res metrics
         """
         return pulumi.get(self, "high_res_metrics_notification_threshold")
 
     @high_res_metrics_notification_threshold.setter
     def high_res_metrics_notification_threshold(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "high_res_metrics_notification_threshold", value)
 
@@ -2475,18 +2491,18 @@
                  color: pulumi.Input[str],
                  gt: Optional[pulumi.Input[float]] = None,
                  gte: Optional[pulumi.Input[float]] = None,
                  lt: Optional[pulumi.Input[float]] = None,
                  lte: Optional[pulumi.Input[float]] = None):
         """
         :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range
-        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range
-        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range
-        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range
+        :param pulumi.Input[float] gt: Indicates the lower threshold non-inclusive value for this range.
+        :param pulumi.Input[float] gte: Indicates the lower threshold inclusive value for this range.
+        :param pulumi.Input[float] lt: Indicates the upper threshold non-inculsive value for this range.
+        :param pulumi.Input[float] lte: Indicates the upper threshold inclusive value for this range.
         """
         pulumi.set(__self__, "color", color)
         if gt is not None:
             pulumi.set(__self__, "gt", gt)
         if gte is not None:
             pulumi.set(__self__, "gte", gte)
         if lt is not None:
@@ -2506,51 +2522,51 @@
     def color(self, value: pulumi.Input[str]):
         pulumi.set(self, "color", value)
 
     @property
     @pulumi.getter
     def gt(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the lower threshold non-inclusive value for this range
+        Indicates the lower threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "gt")
 
     @gt.setter
     def gt(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "gt", value)
 
     @property
     @pulumi.getter
     def gte(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the lower threshold inclusive value for this range
+        Indicates the lower threshold inclusive value for this range.
         """
         return pulumi.get(self, "gte")
 
     @gte.setter
     def gte(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "gte", value)
 
     @property
     @pulumi.getter
     def lt(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the upper threshold non-inculsive value for this range
+        Indicates the upper threshold non-inculsive value for this range.
         """
         return pulumi.get(self, "lt")
 
     @lt.setter
     def lt(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "lt", value)
 
     @property
     @pulumi.getter
     def lte(self) -> Optional[pulumi.Input[float]]:
         """
-        Indicates the upper threshold inclusive value for this range
+        Indicates the upper threshold inclusive value for this range.
         """
         return pulumi.get(self, "lte")
 
     @lte.setter
     def lte(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "lte", value)
 
@@ -2561,20 +2577,20 @@
                  label: pulumi.Input[str],
                  color: Optional[pulumi.Input[str]] = None,
                  display_name: Optional[pulumi.Input[str]] = None,
                  value_prefix: Optional[pulumi.Input[str]] = None,
                  value_suffix: Optional[pulumi.Input[str]] = None,
                  value_unit: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param pulumi.Input[str] color: Color to use
+        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param pulumi.Input[str] color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
+        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
-        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
         if value_prefix is not None:
@@ -2584,27 +2600,27 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> pulumi.Input[str]:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: pulumi.Input[str]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter
     def color(self) -> Optional[pulumi.Input[str]]:
         """
-        Color to use
+        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color", value)
 
@@ -2620,15 +2636,15 @@
     def display_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "display_name", value)
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         """
         return pulumi.get(self, "value_prefix")
 
     @value_prefix.setter
     def value_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_prefix", value)
 
@@ -2644,15 +2660,15 @@
     def value_suffix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_suffix", value)
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[pulumi.Input[str]]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
     @value_unit.setter
     def value_unit(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_unit", value)
 
@@ -2660,53 +2676,53 @@
 @pulumi.input_type
 class SloInputArgs:
     def __init__(__self__, *,
                  program_text: pulumi.Input[str],
                  good_events_label: Optional[pulumi.Input[str]] = None,
                  total_events_label: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] program_text: Signalflow program text for the SLO. More info at "https://dev.splunk.com/observability/docs/signalflow". We require this Signalflow program text to contain at least 2 data blocks - one for the total stream and one for the good stream, whose labels are specified by goodEventsLabel and totalEventsLabel
-        :param pulumi.Input[str] good_events_label: Label used in `program_text` that refers to the data block which contains the stream of successful events
-        :param pulumi.Input[str] total_events_label: Label used in `program_text` that refers to the data block which contains the stream of total events
+        :param pulumi.Input[str] program_text: SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
+        :param pulumi.Input[str] good_events_label: Label used in `"program_text"` that refers to the data block which contains the stream of successful events
+        :param pulumi.Input[str] total_events_label: Label used in `"program_text"` that refers to the data block which contains the stream of total events
         """
         pulumi.set(__self__, "program_text", program_text)
         if good_events_label is not None:
             pulumi.set(__self__, "good_events_label", good_events_label)
         if total_events_label is not None:
             pulumi.set(__self__, "total_events_label", total_events_label)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the SLO. More info at "https://dev.splunk.com/observability/docs/signalflow". We require this Signalflow program text to contain at least 2 data blocks - one for the total stream and one for the good stream, whose labels are specified by goodEventsLabel and totalEventsLabel
+        SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="goodEventsLabel")
     def good_events_label(self) -> Optional[pulumi.Input[str]]:
         """
-        Label used in `program_text` that refers to the data block which contains the stream of successful events
+        Label used in `"program_text"` that refers to the data block which contains the stream of successful events
         """
         return pulumi.get(self, "good_events_label")
 
     @good_events_label.setter
     def good_events_label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "good_events_label", value)
 
     @property
     @pulumi.getter(name="totalEventsLabel")
     def total_events_label(self) -> Optional[pulumi.Input[str]]:
         """
-        Label used in `program_text` that refers to the data block which contains the stream of total events
+        Label used in `"program_text"` that refers to the data block which contains the stream of total events
         """
         return pulumi.get(self, "total_events_label")
 
     @total_events_label.setter
     def total_events_label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "total_events_label", value)
 
@@ -2717,20 +2733,20 @@
                  alert_rules: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]],
                  slo: pulumi.Input[float],
                  type: pulumi.Input[str],
                  compliance_period: Optional[pulumi.Input[str]] = None,
                  cycle_start: Optional[pulumi.Input[str]] = None,
                  cycle_type: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]] alert_rules: SLO alert rules
+        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]] alert_rules: List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
         :param pulumi.Input[float] slo: Target value in the form of a percentage
-        :param pulumi.Input[str] type: SLO target type can be the following type: `RollingWindow`
-        :param pulumi.Input[str] compliance_period: (Required for `RollingWindow` type) Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
-        :param pulumi.Input[str] cycle_start: (Optional for `CalendarWindow` type)  It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
-        :param pulumi.Input[str] cycle_type: (Required for `CalendarWindow` type) The cycle type of the calendar window, e.g. week, month.
+        :param pulumi.Input[str] type: SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
+        :param pulumi.Input[str] compliance_period: Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
+        :param pulumi.Input[str] cycle_start: It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
+        :param pulumi.Input[str] cycle_type: The cycle type of the calendar window, e.g. week, month.
         """
         pulumi.set(__self__, "alert_rules", alert_rules)
         pulumi.set(__self__, "slo", slo)
         pulumi.set(__self__, "type", type)
         if compliance_period is not None:
             pulumi.set(__self__, "compliance_period", compliance_period)
         if cycle_start is not None:
@@ -2738,15 +2754,15 @@
         if cycle_type is not None:
             pulumi.set(__self__, "cycle_type", cycle_type)
 
     @property
     @pulumi.getter(name="alertRules")
     def alert_rules(self) -> pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]]:
         """
-        SLO alert rules
+        List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
         """
         return pulumi.get(self, "alert_rules")
 
     @alert_rules.setter
     def alert_rules(self, value: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleArgs']]]):
         pulumi.set(self, "alert_rules", value)
 
@@ -2762,88 +2778,88 @@
     def slo(self, value: pulumi.Input[float]):
         pulumi.set(self, "slo", value)
 
     @property
     @pulumi.getter
     def type(self) -> pulumi.Input[str]:
         """
-        SLO target type can be the following type: `RollingWindow`
+        SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: pulumi.Input[str]):
         pulumi.set(self, "type", value)
 
     @property
     @pulumi.getter(name="compliancePeriod")
     def compliance_period(self) -> Optional[pulumi.Input[str]]:
         """
-        (Required for `RollingWindow` type) Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
+        Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
         """
         return pulumi.get(self, "compliance_period")
 
     @compliance_period.setter
     def compliance_period(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "compliance_period", value)
 
     @property
     @pulumi.getter(name="cycleStart")
     def cycle_start(self) -> Optional[pulumi.Input[str]]:
         """
-        (Optional for `CalendarWindow` type)  It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
+        It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
         """
         return pulumi.get(self, "cycle_start")
 
     @cycle_start.setter
     def cycle_start(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "cycle_start", value)
 
     @property
     @pulumi.getter(name="cycleType")
     def cycle_type(self) -> Optional[pulumi.Input[str]]:
         """
-        (Required for `CalendarWindow` type) The cycle type of the calendar window, e.g. week, month.
+        The cycle type of the calendar window, e.g. week, month.
         """
         return pulumi.get(self, "cycle_type")
 
     @cycle_type.setter
     def cycle_type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "cycle_type", value)
 
 
 @pulumi.input_type
 class SloTargetAlertRuleArgs:
     def __init__(__self__, *,
                  rules: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]],
                  type: pulumi.Input[str]):
         """
-        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]] rules: Set of rules used for alerting
-        :param pulumi.Input[str] type: SLO alert rule type
+        :param pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]] rules: Set of rules used for alerting.
+        :param pulumi.Input[str] type: SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alert_rule per type. For example, you can't specify two alert_rule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         pulumi.set(__self__, "rules", rules)
         pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def rules(self) -> pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]]:
         """
-        Set of rules used for alerting
+        Set of rules used for alerting.
         """
         return pulumi.get(self, "rules")
 
     @rules.setter
     def rules(self, value: pulumi.Input[Sequence[pulumi.Input['SloTargetAlertRuleRuleArgs']]]):
         pulumi.set(self, "rules", value)
 
     @property
     @pulumi.getter
     def type(self) -> pulumi.Input[str]:
         """
-        SLO alert rule type
+        SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alert_rule per type. For example, you can't specify two alert_rule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "type")
 
     @type.setter
     def type(self, value: pulumi.Input[str]):
         pulumi.set(self, "type", value)
 
@@ -2857,23 +2873,23 @@
                  notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  parameterized_body: Optional[pulumi.Input[str]] = None,
                  parameterized_subject: Optional[pulumi.Input[str]] = None,
                  parameters: Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']] = None,
                  runbook_url: Optional[pulumi.Input[str]] = None,
                  tip: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
-        :param pulumi.Input[str] description: Description of the rule
-        :param pulumi.Input[bool] disabled: (default: false) When true, notifications and events will not be generated for the detect label
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
-        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
-        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        :param pulumi.Input[str] severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
+        :param pulumi.Input[str] description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
+        :param pulumi.Input[bool] disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
+        :param pulumi.Input[str] parameterized_body: Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
+        :param pulumi.Input[str] parameterized_subject: Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
         :param pulumi.Input['SloTargetAlertRuleRuleParametersArgs'] parameters: Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
-        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered
-        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command to execute.
+        :param pulumi.Input[str] runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
+        :param pulumi.Input[str] tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         pulumi.set(__self__, "severity", severity)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if disabled is not None:
             pulumi.set(__self__, "disabled", disabled)
         if notifications is not None:
@@ -2889,75 +2905,75 @@
         if tip is not None:
             pulumi.set(__self__, "tip", tip)
 
     @property
     @pulumi.getter
     def severity(self) -> pulumi.Input[str]:
         """
-        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
+        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
         """
         return pulumi.get(self, "severity")
 
     @severity.setter
     def severity(self, value: pulumi.Input[str]):
         pulumi.set(self, "severity", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the rule
+        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def disabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        (default: false) When true, notifications and events will not be generated for the detect label
+        When true, notifications and events will not be generated for the detect label. `false` by default.
         """
         return pulumi.get(self, "disabled")
 
     @disabled.setter
     def disabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disabled", value)
 
     @property
     @pulumi.getter
     def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
         """
         return pulumi.get(self, "notifications")
 
     @notifications.setter
     def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications", value)
 
     @property
     @pulumi.getter(name="parameterizedBody")
     def parameterized_body(self) -> Optional[pulumi.Input[str]]:
         """
-        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
         """
         return pulumi.get(self, "parameterized_body")
 
     @parameterized_body.setter
     def parameterized_body(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "parameterized_body", value)
 
     @property
     @pulumi.getter(name="parameterizedSubject")
     def parameterized_subject(self) -> Optional[pulumi.Input[str]]:
         """
-        Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
         """
         return pulumi.get(self, "parameterized_subject")
 
     @parameterized_subject.setter
     def parameterized_subject(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "parameterized_subject", value)
 
@@ -2973,27 +2989,27 @@
     def parameters(self, value: Optional[pulumi.Input['SloTargetAlertRuleRuleParametersArgs']]):
         pulumi.set(self, "parameters", value)
 
     @property
     @pulumi.getter(name="runbookUrl")
     def runbook_url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of page to consult when an alert is triggered
+        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
         """
         return pulumi.get(self, "runbook_url")
 
     @runbook_url.setter
     def runbook_url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "runbook_url", value)
 
     @property
     @pulumi.getter
     def tip(self) -> Optional[pulumi.Input[str]]:
         """
-        Plain text suggested first course of action, such as a command to execute.
+        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         return pulumi.get(self, "tip")
 
     @tip.setter
     def tip(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "tip", value)
 
@@ -3007,23 +3023,23 @@
                  long_window1: Optional[pulumi.Input[str]] = None,
                  long_window2: Optional[pulumi.Input[str]] = None,
                  percent_error_budget_left: Optional[pulumi.Input[float]] = None,
                  percent_of_lasting: Optional[pulumi.Input[float]] = None,
                  short_window1: Optional[pulumi.Input[str]] = None,
                  short_window2: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[float] burn_rate_threshold1: Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_1 parameter.
-        :param pulumi.Input[float] burn_rate_threshold2: Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_2 parameter.
-        :param pulumi.Input[str] fire_lasting: Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the fire_lasting parameter
-        :param pulumi.Input[str] long_window1: Long window 1 used in burn rate alert calculation. This value must be longer than short_window_1` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_1 parameter.
-        :param pulumi.Input[str] long_window2: Long window 2 used in burn rate alert calculation. This value must be longer than short_window_2` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_2 parameter.
-        :param pulumi.Input[float] percent_error_budget_left: Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: ERROR_BUDGET_LEFT alert rules use the percent_error_budget_left parameter.
-        :param pulumi.Input[float] percent_of_lasting: Percentage of the fire_lasting duration that the alert condition is met before the alert is triggered. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the percent_of_lasting parameter
-        :param pulumi.Input[str] short_window1: Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_1. Note: BURN_RATE alert rules use the short_window_1 parameter.
-        :param pulumi.Input[str] short_window2: Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_2. Note: BURN_RATE alert rules use the short_window_2 parameter.
+        :param pulumi.Input[float] burn_rate_threshold1: Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param pulumi.Input[float] burn_rate_threshold2: Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param pulumi.Input[str] fire_lasting: Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
+        :param pulumi.Input[str] long_window1: Long window 1 used in burn rate alert calculation. This value must be longer than `"short_window_1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param pulumi.Input[str] long_window2: Long window 2 used in burn rate alert calculation. This value must be longer than `"short_window_2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param pulumi.Input[float] percent_error_budget_left: Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_error_budget_left"` parameter. Default: `100`
+        :param pulumi.Input[float] percent_of_lasting: Percentage of the `"fire_lasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_of_lasting"` parameter. Default: `100`
+        :param pulumi.Input[str] short_window1: Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_1"`. Note: `"BURN_RATE"` alert rules use the `"short_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param pulumi.Input[str] short_window2: Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_2"`. Note: `"BURN_RATE"` alert rules use the `"short_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         if burn_rate_threshold1 is not None:
             pulumi.set(__self__, "burn_rate_threshold1", burn_rate_threshold1)
         if burn_rate_threshold2 is not None:
             pulumi.set(__self__, "burn_rate_threshold2", burn_rate_threshold2)
         if fire_lasting is not None:
             pulumi.set(__self__, "fire_lasting", fire_lasting)
@@ -3040,111 +3056,111 @@
         if short_window2 is not None:
             pulumi.set(__self__, "short_window2", short_window2)
 
     @property
     @pulumi.getter(name="burnRateThreshold1")
     def burn_rate_threshold1(self) -> Optional[pulumi.Input[float]]:
         """
-        Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_1 parameter.
+        Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "burn_rate_threshold1")
 
     @burn_rate_threshold1.setter
     def burn_rate_threshold1(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "burn_rate_threshold1", value)
 
     @property
     @pulumi.getter(name="burnRateThreshold2")
     def burn_rate_threshold2(self) -> Optional[pulumi.Input[float]]:
         """
-        Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_2 parameter.
+        Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "burn_rate_threshold2")
 
     @burn_rate_threshold2.setter
     def burn_rate_threshold2(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "burn_rate_threshold2", value)
 
     @property
     @pulumi.getter(name="fireLasting")
     def fire_lasting(self) -> Optional[pulumi.Input[str]]:
         """
-        Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the fire_lasting parameter
+        Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
         """
         return pulumi.get(self, "fire_lasting")
 
     @fire_lasting.setter
     def fire_lasting(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "fire_lasting", value)
 
     @property
     @pulumi.getter(name="longWindow1")
     def long_window1(self) -> Optional[pulumi.Input[str]]:
         """
-        Long window 1 used in burn rate alert calculation. This value must be longer than short_window_1` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_1 parameter.
+        Long window 1 used in burn rate alert calculation. This value must be longer than `"short_window_1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "long_window1")
 
     @long_window1.setter
     def long_window1(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "long_window1", value)
 
     @property
     @pulumi.getter(name="longWindow2")
     def long_window2(self) -> Optional[pulumi.Input[str]]:
         """
-        Long window 2 used in burn rate alert calculation. This value must be longer than short_window_2` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_2 parameter.
+        Long window 2 used in burn rate alert calculation. This value must be longer than `"short_window_2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "long_window2")
 
     @long_window2.setter
     def long_window2(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "long_window2", value)
 
     @property
     @pulumi.getter(name="percentErrorBudgetLeft")
     def percent_error_budget_left(self) -> Optional[pulumi.Input[float]]:
         """
-        Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: ERROR_BUDGET_LEFT alert rules use the percent_error_budget_left parameter.
+        Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_error_budget_left"` parameter. Default: `100`
         """
         return pulumi.get(self, "percent_error_budget_left")
 
     @percent_error_budget_left.setter
     def percent_error_budget_left(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "percent_error_budget_left", value)
 
     @property
     @pulumi.getter(name="percentOfLasting")
     def percent_of_lasting(self) -> Optional[pulumi.Input[float]]:
         """
-        Percentage of the fire_lasting duration that the alert condition is met before the alert is triggered. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the percent_of_lasting parameter
+        Percentage of the `"fire_lasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_of_lasting"` parameter. Default: `100`
         """
         return pulumi.get(self, "percent_of_lasting")
 
     @percent_of_lasting.setter
     def percent_of_lasting(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "percent_of_lasting", value)
 
     @property
     @pulumi.getter(name="shortWindow1")
     def short_window1(self) -> Optional[pulumi.Input[str]]:
         """
-        Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_1. Note: BURN_RATE alert rules use the short_window_1 parameter.
+        Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_1"`. Note: `"BURN_RATE"` alert rules use the `"short_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "short_window1")
 
     @short_window1.setter
     def short_window1(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "short_window1", value)
 
     @property
     @pulumi.getter(name="shortWindow2")
     def short_window2(self) -> Optional[pulumi.Input[str]]:
         """
-        Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_2. Note: BURN_RATE alert rules use the short_window_2 parameter.
+        Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_2"`. Note: `"BURN_RATE"` alert rules use the `"short_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "short_window2")
 
     @short_window2.setter
     def short_window2(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "short_window2", value)
 
@@ -3259,21 +3275,21 @@
                  label: Optional[pulumi.Input[str]] = None,
                  low_watermark: Optional[pulumi.Input[float]] = None,
                  low_watermark_label: Optional[pulumi.Input[str]] = None,
                  max_value: Optional[pulumi.Input[float]] = None,
                  min_value: Optional[pulumi.Input[float]] = None,
                  watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisLeftWatermarkArgs']]]] = None):
         """
-        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark
-        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line
-        :param pulumi.Input[str] label: Label of the left axis
-        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark
-        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line
-        :param pulumi.Input[float] max_value: The maximum value for the left axis
-        :param pulumi.Input[float] min_value: The minimum value for the left axis
+        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark.
+        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line.
+        :param pulumi.Input[str] label: Label of the left axis.
+        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark.
+        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line.
+        :param pulumi.Input[float] max_value: The maximum value for the left axis.
+        :param pulumi.Input[float] min_value: The minimum value for the left axis.
         """
         if high_watermark is not None:
             pulumi.set(__self__, "high_watermark", high_watermark)
         if high_watermark_label is not None:
             pulumi.set(__self__, "high_watermark_label", high_watermark_label)
         if label is not None:
             pulumi.set(__self__, "label", label)
@@ -3288,87 +3304,87 @@
         if watermarks is not None:
             pulumi.set(__self__, "watermarks", watermarks)
 
     @property
     @pulumi.getter(name="highWatermark")
     def high_watermark(self) -> Optional[pulumi.Input[float]]:
         """
-        A line to draw as a high watermark
+        A line to draw as a high watermark.
         """
         return pulumi.get(self, "high_watermark")
 
     @high_watermark.setter
     def high_watermark(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "high_watermark", value)
 
     @property
     @pulumi.getter(name="highWatermarkLabel")
     def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
         """
-        A label to attach to the high watermark line
+        A label to attach to the high watermark line.
         """
         return pulumi.get(self, "high_watermark_label")
 
     @high_watermark_label.setter
     def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "high_watermark_label", value)
 
     @property
     @pulumi.getter
     def label(self) -> Optional[pulumi.Input[str]]:
         """
-        Label of the left axis
+        Label of the left axis.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter(name="lowWatermark")
     def low_watermark(self) -> Optional[pulumi.Input[float]]:
         """
-        A line to draw as a low watermark
+        A line to draw as a low watermark.
         """
         return pulumi.get(self, "low_watermark")
 
     @low_watermark.setter
     def low_watermark(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "low_watermark", value)
 
     @property
     @pulumi.getter(name="lowWatermarkLabel")
     def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
         """
-        A label to attach to the low watermark line
+        A label to attach to the low watermark line.
         """
         return pulumi.get(self, "low_watermark_label")
 
     @low_watermark_label.setter
     def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "low_watermark_label", value)
 
     @property
     @pulumi.getter(name="maxValue")
     def max_value(self) -> Optional[pulumi.Input[float]]:
         """
-        The maximum value for the left axis
+        The maximum value for the left axis.
         """
         return pulumi.get(self, "max_value")
 
     @max_value.setter
     def max_value(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "max_value", value)
 
     @property
     @pulumi.getter(name="minValue")
     def min_value(self) -> Optional[pulumi.Input[float]]:
         """
-        The minimum value for the left axis
+        The minimum value for the left axis.
         """
         return pulumi.get(self, "min_value")
 
     @min_value.setter
     def min_value(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "min_value", value)
 
@@ -3428,21 +3444,21 @@
                  label: Optional[pulumi.Input[str]] = None,
                  low_watermark: Optional[pulumi.Input[float]] = None,
                  low_watermark_label: Optional[pulumi.Input[str]] = None,
                  max_value: Optional[pulumi.Input[float]] = None,
                  min_value: Optional[pulumi.Input[float]] = None,
                  watermarks: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartAxisRightWatermarkArgs']]]] = None):
         """
-        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark
-        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line
-        :param pulumi.Input[str] label: Label of the right axis
-        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark
-        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line
-        :param pulumi.Input[float] max_value: The maximum value for the right axis
-        :param pulumi.Input[float] min_value: The minimum value for the right axis
+        :param pulumi.Input[float] high_watermark: A line to draw as a high watermark.
+        :param pulumi.Input[str] high_watermark_label: A label to attach to the high watermark line.
+        :param pulumi.Input[str] label: Label of the right axis.
+        :param pulumi.Input[float] low_watermark: A line to draw as a low watermark.
+        :param pulumi.Input[str] low_watermark_label: A label to attach to the low watermark line.
+        :param pulumi.Input[float] max_value: The maximum value for the right axis.
+        :param pulumi.Input[float] min_value: The minimum value for the right axis.
         """
         if high_watermark is not None:
             pulumi.set(__self__, "high_watermark", high_watermark)
         if high_watermark_label is not None:
             pulumi.set(__self__, "high_watermark_label", high_watermark_label)
         if label is not None:
             pulumi.set(__self__, "label", label)
@@ -3457,87 +3473,87 @@
         if watermarks is not None:
             pulumi.set(__self__, "watermarks", watermarks)
 
     @property
     @pulumi.getter(name="highWatermark")
     def high_watermark(self) -> Optional[pulumi.Input[float]]:
         """
-        A line to draw as a high watermark
+        A line to draw as a high watermark.
         """
         return pulumi.get(self, "high_watermark")
 
     @high_watermark.setter
     def high_watermark(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "high_watermark", value)
 
     @property
     @pulumi.getter(name="highWatermarkLabel")
     def high_watermark_label(self) -> Optional[pulumi.Input[str]]:
         """
-        A label to attach to the high watermark line
+        A label to attach to the high watermark line.
         """
         return pulumi.get(self, "high_watermark_label")
 
     @high_watermark_label.setter
     def high_watermark_label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "high_watermark_label", value)
 
     @property
     @pulumi.getter
     def label(self) -> Optional[pulumi.Input[str]]:
         """
-        Label of the right axis
+        Label of the right axis.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter(name="lowWatermark")
     def low_watermark(self) -> Optional[pulumi.Input[float]]:
         """
-        A line to draw as a low watermark
+        A line to draw as a low watermark.
         """
         return pulumi.get(self, "low_watermark")
 
     @low_watermark.setter
     def low_watermark(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "low_watermark", value)
 
     @property
     @pulumi.getter(name="lowWatermarkLabel")
     def low_watermark_label(self) -> Optional[pulumi.Input[str]]:
         """
-        A label to attach to the low watermark line
+        A label to attach to the low watermark line.
         """
         return pulumi.get(self, "low_watermark_label")
 
     @low_watermark_label.setter
     def low_watermark_label(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "low_watermark_label", value)
 
     @property
     @pulumi.getter(name="maxValue")
     def max_value(self) -> Optional[pulumi.Input[float]]:
         """
-        The maximum value for the right axis
+        The maximum value for the right axis.
         """
         return pulumi.get(self, "max_value")
 
     @max_value.setter
     def max_value(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "max_value", value)
 
     @property
     @pulumi.getter(name="minValue")
     def min_value(self) -> Optional[pulumi.Input[float]]:
         """
-        The minimum value for the right axis
+        The minimum value for the right axis.
         """
         return pulumi.get(self, "min_value")
 
     @min_value.setter
     def min_value(self, value: Optional[pulumi.Input[float]]):
         pulumi.set(self, "min_value", value)
 
@@ -3592,41 +3608,41 @@
 @pulumi.input_type
 class TimeChartEventOptionArgs:
     def __init__(__self__, *,
                  label: pulumi.Input[str],
                  color: Optional[pulumi.Input[str]] = None,
                  display_name: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] label: The label used in the publish statement that displays the events you want to customize
-        :param pulumi.Input[str] color: Color to use
+        :param pulumi.Input[str] label: Label used in the publish statement that displays the event query you want to customize.
+        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
 
     @property
     @pulumi.getter
     def label(self) -> pulumi.Input[str]:
         """
-        The label used in the publish statement that displays the events you want to customize
+        Label used in the publish statement that displays the event query you want to customize.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: pulumi.Input[str]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter
     def color(self) -> Optional[pulumi.Input[str]]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color", value)
 
@@ -3644,62 +3660,62 @@
 
 
 @pulumi.input_type
 class TimeChartHistogramOptionArgs:
     def __init__(__self__, *,
                  color_theme: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] color_theme: Base color theme to use for the graph.
+        :param pulumi.Input[str] color_theme: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
         """
         if color_theme is not None:
             pulumi.set(__self__, "color_theme", color_theme)
 
     @property
     @pulumi.getter(name="colorTheme")
     def color_theme(self) -> Optional[pulumi.Input[str]]:
         """
-        Base color theme to use for the graph.
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
         """
         return pulumi.get(self, "color_theme")
 
     @color_theme.setter
     def color_theme(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_theme", value)
 
 
 @pulumi.input_type
 class TimeChartLegendOptionsFieldArgs:
     def __init__(__self__, *,
                  property: pulumi.Input[str],
                  enabled: Optional[pulumi.Input[bool]] = None):
         """
-        :param pulumi.Input[str] property: The name of a property to hide or show in the data table.
-        :param pulumi.Input[bool] enabled: (true by default) Determines if this property is displayed in the data table.
+        :param pulumi.Input[str] property: The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
+        :param pulumi.Input[bool] enabled: True or False depending on if you want the property to be shown or hidden.
         """
         pulumi.set(__self__, "property", property)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        (true by default) Determines if this property is displayed in the data table.
+        True or False depending on if you want the property to be shown or hidden.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def property(self) -> pulumi.Input[str]:
         """
-        The name of a property to hide or show in the data table.
+        The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
         """
         return pulumi.get(self, "property")
 
     @property.setter
     def property(self, value: pulumi.Input[str]):
         pulumi.set(self, "property", value)
 
@@ -3712,22 +3728,22 @@
                  color: Optional[pulumi.Input[str]] = None,
                  display_name: Optional[pulumi.Input[str]] = None,
                  plot_type: Optional[pulumi.Input[str]] = None,
                  value_prefix: Optional[pulumi.Input[str]] = None,
                  value_suffix: Optional[pulumi.Input[str]] = None,
                  value_unit: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param pulumi.Input[str] axis: The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
-        :param pulumi.Input[str] color: Color to use
+        :param pulumi.Input[str] label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param pulumi.Input[str] axis: Y-axis associated with values for this plot. Must be either `right` or `left`.
+        :param pulumi.Input[str] color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         :param pulumi.Input[str] display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param pulumi.Input[str] plot_type: (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
-        :param pulumi.Input[str] value_prefix: An arbitrary prefix to display with the value of this plot
+        :param pulumi.Input[str] plot_type: The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
+        :param pulumi.Input[str] value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         :param pulumi.Input[str] value_suffix: An arbitrary suffix to display with the value of this plot
-        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param pulumi.Input[str] value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if axis is not None:
             pulumi.set(__self__, "axis", axis)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
@@ -3741,39 +3757,39 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> pulumi.Input[str]:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @label.setter
     def label(self, value: pulumi.Input[str]):
         pulumi.set(self, "label", value)
 
     @property
     @pulumi.getter
     def axis(self) -> Optional[pulumi.Input[str]]:
         """
-        The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
+        Y-axis associated with values for this plot. Must be either `right` or `left`.
         """
         return pulumi.get(self, "axis")
 
     @axis.setter
     def axis(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "axis", value)
 
     @property
     @pulumi.getter
     def color(self) -> Optional[pulumi.Input[str]]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @color.setter
     def color(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color", value)
 
@@ -3789,27 +3805,27 @@
     def display_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "display_name", value)
 
     @property
     @pulumi.getter(name="plotType")
     def plot_type(self) -> Optional[pulumi.Input[str]]:
         """
-        (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
+        The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
         """
         return pulumi.get(self, "plot_type")
 
     @plot_type.setter
     def plot_type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "plot_type", value)
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         """
         return pulumi.get(self, "value_prefix")
 
     @value_prefix.setter
     def value_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_prefix", value)
 
@@ -3825,43 +3841,53 @@
     def value_suffix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_suffix", value)
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[pulumi.Input[str]]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
     @value_unit.setter
     def value_unit(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "value_unit", value)
 
 
 @pulumi.input_type
 class WebhookIntegrationHeaderArgs:
     def __init__(__self__, *,
                  header_key: pulumi.Input[str],
                  header_value: pulumi.Input[str]):
+        """
+        :param pulumi.Input[str] header_key: The key of the header to send
+        :param pulumi.Input[str] header_value: The value of the header to send
+        """
         pulumi.set(__self__, "header_key", header_key)
         pulumi.set(__self__, "header_value", header_value)
 
     @property
     @pulumi.getter(name="headerKey")
     def header_key(self) -> pulumi.Input[str]:
+        """
+        The key of the header to send
+        """
         return pulumi.get(self, "header_key")
 
     @header_key.setter
     def header_key(self, value: pulumi.Input[str]):
         pulumi.set(self, "header_key", value)
 
     @property
     @pulumi.getter(name="headerValue")
     def header_value(self) -> pulumi.Input[str]:
+        """
+        The value of the header to send
+        """
         return pulumi.get(self, "header_value")
 
     @header_value.setter
     def header_value(self, value: pulumi.Input[str]):
         pulumi.set(self, "header_value", value)
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/_utilities.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/_utilities.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/alert_muting_rule.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/alert_muting_rule.py`

 * *Files 10% similar despite different names*

```diff
@@ -19,82 +19,82 @@
                  description: pulumi.Input[str],
                  start_time: pulumi.Input[int],
                  detectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  filters: Optional[pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]]] = None,
                  stop_time: Optional[pulumi.Input[int]] = None):
         """
         The set of arguments for constructing a AlertMutingRule resource.
-        :param pulumi.Input[str] description: description of the rule
-        :param pulumi.Input[int] start_time: starting time of an alert muting rule as a Unix timestamp, in seconds
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: detectors to which this muting rule applies
-        :param pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]] filters: list of alert muting filters for this rule
-        :param pulumi.Input[int] stop_time: stop time of an alert muting rule as a Unix timestamp, in seconds
+        :param pulumi.Input[str] description: The description for this muting rule
+        :param pulumi.Input[int] start_time: Starting time of an alert muting rule as a Unit time stamp in seconds.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
+        :param pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]] filters: Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
+        :param pulumi.Input[int] stop_time: Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         pulumi.set(__self__, "description", description)
         pulumi.set(__self__, "start_time", start_time)
         if detectors is not None:
             pulumi.set(__self__, "detectors", detectors)
         if filters is not None:
             pulumi.set(__self__, "filters", filters)
         if stop_time is not None:
             pulumi.set(__self__, "stop_time", stop_time)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Input[str]:
         """
-        description of the rule
+        The description for this muting rule
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: pulumi.Input[str]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Input[int]:
         """
-        starting time of an alert muting rule as a Unix timestamp, in seconds
+        Starting time of an alert muting rule as a Unit time stamp in seconds.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: pulumi.Input[int]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter
     def detectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        detectors to which this muting rule applies
+        A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
         """
         return pulumi.get(self, "detectors")
 
     @detectors.setter
     def detectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "detectors", value)
 
     @property
     @pulumi.getter
     def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]]]:
         """
-        list of alert muting filters for this rule
+        Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
         """
         return pulumi.get(self, "filters")
 
     @filters.setter
     def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]]]):
         pulumi.set(self, "filters", value)
 
     @property
     @pulumi.getter(name="stopTime")
     def stop_time(self) -> Optional[pulumi.Input[int]]:
         """
-        stop time of an alert muting rule as a Unix timestamp, in seconds
+        Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         return pulumi.get(self, "stop_time")
 
     @stop_time.setter
     def stop_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "stop_time", value)
 
@@ -106,19 +106,19 @@
                  detectors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  effective_start_time: Optional[pulumi.Input[int]] = None,
                  filters: Optional[pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]]] = None,
                  start_time: Optional[pulumi.Input[int]] = None,
                  stop_time: Optional[pulumi.Input[int]] = None):
         """
         Input properties used for looking up and filtering AlertMutingRule resources.
-        :param pulumi.Input[str] description: description of the rule
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: detectors to which this muting rule applies
-        :param pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]] filters: list of alert muting filters for this rule
-        :param pulumi.Input[int] start_time: starting time of an alert muting rule as a Unix timestamp, in seconds
-        :param pulumi.Input[int] stop_time: stop time of an alert muting rule as a Unix timestamp, in seconds
+        :param pulumi.Input[str] description: The description for this muting rule
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
+        :param pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]] filters: Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
+        :param pulumi.Input[int] start_time: Starting time of an alert muting rule as a Unit time stamp in seconds.
+        :param pulumi.Input[int] stop_time: Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         if description is not None:
             pulumi.set(__self__, "description", description)
         if detectors is not None:
             pulumi.set(__self__, "detectors", detectors)
         if effective_start_time is not None:
             pulumi.set(__self__, "effective_start_time", effective_start_time)
@@ -129,27 +129,27 @@
         if stop_time is not None:
             pulumi.set(__self__, "stop_time", stop_time)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        description of the rule
+        The description for this muting rule
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def detectors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        detectors to which this muting rule applies
+        A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
         """
         return pulumi.get(self, "detectors")
 
     @detectors.setter
     def detectors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "detectors", value)
 
@@ -162,39 +162,39 @@
     def effective_start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "effective_start_time", value)
 
     @property
     @pulumi.getter
     def filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]]]:
         """
-        list of alert muting filters for this rule
+        Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
         """
         return pulumi.get(self, "filters")
 
     @filters.setter
     def filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AlertMutingRuleFilterArgs']]]]):
         pulumi.set(self, "filters", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        starting time of an alert muting rule as a Unix timestamp, in seconds
+        Starting time of an alert muting rule as a Unit time stamp in seconds.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="stopTime")
     def stop_time(self) -> Optional[pulumi.Input[int]]:
         """
-        stop time of an alert muting rule as a Unix timestamp, in seconds
+        Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         return pulumi.get(self, "stop_time")
 
     @stop_time.setter
     def stop_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "stop_time", value)
 
@@ -215,39 +215,21 @@
 
         Splunk Observability Cloud currently allows linking an alert muting rule with only one detector ID. Specifying multiple detector IDs makes the muting rule obsolete.
 
         > **WARNING** Splunk Observability Cloud does not allow the start time of a **currently active** muting rule to be modified. Attempting to modify a currently active rule destroys the existing rule and creates a new rule. This might result in the emission of notifications.
 
         ## Example
 
-        ## Arguments
-
-        * `description` - (Required) The description for this muting rule
-        * `start_time` - (Required) Starting time of an alert muting rule as a Unit time stamp in seconds.
-        * `stop_time` - (Optional) Stop time of an alert muting rule as a Unix time stamp in seconds.
-        * `detectors` - (Optional) A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
-        * `filter` - (Optional) Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
-          * `property` - (Required) The property to filter.
-          * `property_value` - (Required) The property value to filter.
-          * `negated` - (Optional) Determines if this is a "not" filter. Defaults to `false`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the alert muting rule.
-        * `effective_start_time`
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: description of the rule
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: detectors to which this muting rule applies
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AlertMutingRuleFilterArgs']]]] filters: list of alert muting filters for this rule
-        :param pulumi.Input[int] start_time: starting time of an alert muting rule as a Unix timestamp, in seconds
-        :param pulumi.Input[int] stop_time: stop time of an alert muting rule as a Unix timestamp, in seconds
+        :param pulumi.Input[str] description: The description for this muting rule
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AlertMutingRuleFilterArgs']]]] filters: Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
+        :param pulumi.Input[int] start_time: Starting time of an alert muting rule as a Unit time stamp in seconds.
+        :param pulumi.Input[int] stop_time: Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: AlertMutingRuleArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -256,32 +238,14 @@
 
         Splunk Observability Cloud currently allows linking an alert muting rule with only one detector ID. Specifying multiple detector IDs makes the muting rule obsolete.
 
         > **WARNING** Splunk Observability Cloud does not allow the start time of a **currently active** muting rule to be modified. Attempting to modify a currently active rule destroys the existing rule and creates a new rule. This might result in the emission of notifications.
 
         ## Example
 
-        ## Arguments
-
-        * `description` - (Required) The description for this muting rule
-        * `start_time` - (Required) Starting time of an alert muting rule as a Unit time stamp in seconds.
-        * `stop_time` - (Optional) Stop time of an alert muting rule as a Unix time stamp in seconds.
-        * `detectors` - (Optional) A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
-        * `filter` - (Optional) Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
-          * `property` - (Required) The property to filter.
-          * `property_value` - (Required) The property value to filter.
-          * `negated` - (Optional) Determines if this is a "not" filter. Defaults to `false`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the alert muting rule.
-        * `effective_start_time`
-
         :param str resource_name: The name of the resource.
         :param AlertMutingRuleArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(AlertMutingRuleArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -336,19 +300,19 @@
         """
         Get an existing AlertMutingRule resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: description of the rule
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: detectors to which this muting rule applies
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AlertMutingRuleFilterArgs']]]] filters: list of alert muting filters for this rule
-        :param pulumi.Input[int] start_time: starting time of an alert muting rule as a Unix timestamp, in seconds
-        :param pulumi.Input[int] stop_time: stop time of an alert muting rule as a Unix timestamp, in seconds
+        :param pulumi.Input[str] description: The description for this muting rule
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] detectors: A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AlertMutingRuleFilterArgs']]]] filters: Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
+        :param pulumi.Input[int] start_time: Starting time of an alert muting rule as a Unit time stamp in seconds.
+        :param pulumi.Input[int] stop_time: Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _AlertMutingRuleState.__new__(_AlertMutingRuleState)
 
         __props__.__dict__["description"] = description
         __props__.__dict__["detectors"] = detectors
@@ -358,48 +322,48 @@
         __props__.__dict__["stop_time"] = stop_time
         return AlertMutingRule(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[str]:
         """
-        description of the rule
+        The description for this muting rule
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def detectors(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        detectors to which this muting rule applies
+        A convenience attribute that associated this muting rule with specific detector IDs. Currently, only one ID is supported.
         """
         return pulumi.get(self, "detectors")
 
     @property
     @pulumi.getter(name="effectiveStartTime")
     def effective_start_time(self) -> pulumi.Output[int]:
         return pulumi.get(self, "effective_start_time")
 
     @property
     @pulumi.getter
     def filters(self) -> pulumi.Output[Optional[Sequence['outputs.AlertMutingRuleFilter']]]:
         """
-        list of alert muting filters for this rule
+        Filters for this rule. See [Creating muting rules from scratch](https://docs.splunk.com/Observability/alerts-detectors-notifications/mute-notifications.html#rule-from-scratch) for more information.
         """
         return pulumi.get(self, "filters")
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Output[int]:
         """
-        starting time of an alert muting rule as a Unix timestamp, in seconds
+        Starting time of an alert muting rule as a Unit time stamp in seconds.
         """
         return pulumi.get(self, "start_time")
 
     @property
     @pulumi.getter(name="stopTime")
     def stop_time(self) -> pulumi.Output[Optional[int]]:
         """
-        stop time of an alert muting rule as a Unix timestamp, in seconds
+        Stop time of an alert muting rule as a Unix time stamp in seconds.
         """
         return pulumi.get(self, "stop_time")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/_inputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/_inputs.py`

 * *Files 5% similar despite different names*

```diff
@@ -19,68 +19,68 @@
 class IntegrationCustomNamespaceSyncRuleArgs:
     def __init__(__self__, *,
                  namespace: pulumi.Input[str],
                  default_action: Optional[pulumi.Input[str]] = None,
                  filter_action: Optional[pulumi.Input[str]] = None,
                  filter_source: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] namespace: An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
-        :param pulumi.Input[str] default_action: Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
-        :param pulumi.Input[str] filter_action: Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
-        :param pulumi.Input[str] filter_source: Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        :param pulumi.Input[str] namespace: An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
+        :param pulumi.Input[str] default_action: Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
+        :param pulumi.Input[str] filter_action: Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
+        :param pulumi.Input[str] filter_source: Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         pulumi.set(__self__, "namespace", namespace)
         if default_action is not None:
             pulumi.set(__self__, "default_action", default_action)
         if filter_action is not None:
             pulumi.set(__self__, "filter_action", filter_action)
         if filter_source is not None:
             pulumi.set(__self__, "filter_source", filter_source)
 
     @property
     @pulumi.getter
     def namespace(self) -> pulumi.Input[str]:
         """
-        An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
+        An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
         """
         return pulumi.get(self, "namespace")
 
     @namespace.setter
     def namespace(self, value: pulumi.Input[str]):
         pulumi.set(self, "namespace", value)
 
     @property
     @pulumi.getter(name="defaultAction")
     def default_action(self) -> Optional[pulumi.Input[str]]:
         """
-        Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
+        Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "default_action")
 
     @default_action.setter
     def default_action(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "default_action", value)
 
     @property
     @pulumi.getter(name="filterAction")
     def filter_action(self) -> Optional[pulumi.Input[str]]:
         """
-        Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
+        Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "filter_action")
 
     @filter_action.setter
     def filter_action(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "filter_action", value)
 
     @property
     @pulumi.getter(name="filterSource")
     def filter_source(self) -> Optional[pulumi.Input[str]]:
         """
-        Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         return pulumi.get(self, "filter_source")
 
     @filter_source.setter
     def filter_source(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "filter_source", value)
 
@@ -141,68 +141,68 @@
 class IntegrationNamespaceSyncRuleArgs:
     def __init__(__self__, *,
                  namespace: pulumi.Input[str],
                  default_action: Optional[pulumi.Input[str]] = None,
                  filter_action: Optional[pulumi.Input[str]] = None,
                  filter_source: Optional[pulumi.Input[str]] = None):
         """
-        :param pulumi.Input[str] namespace: An AWS namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
-        :param pulumi.Input[str] default_action: Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
-        :param pulumi.Input[str] filter_action: Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
-        :param pulumi.Input[str] filter_source: Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        :param pulumi.Input[str] namespace: An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
+        :param pulumi.Input[str] default_action: Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
+        :param pulumi.Input[str] filter_action: Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
+        :param pulumi.Input[str] filter_source: Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         pulumi.set(__self__, "namespace", namespace)
         if default_action is not None:
             pulumi.set(__self__, "default_action", default_action)
         if filter_action is not None:
             pulumi.set(__self__, "filter_action", filter_action)
         if filter_source is not None:
             pulumi.set(__self__, "filter_source", filter_source)
 
     @property
     @pulumi.getter
     def namespace(self) -> pulumi.Input[str]:
         """
-        An AWS namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
+        An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
         """
         return pulumi.get(self, "namespace")
 
     @namespace.setter
     def namespace(self, value: pulumi.Input[str]):
         pulumi.set(self, "namespace", value)
 
     @property
     @pulumi.getter(name="defaultAction")
     def default_action(self) -> Optional[pulumi.Input[str]]:
         """
-        Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
+        Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "default_action")
 
     @default_action.setter
     def default_action(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "default_action", value)
 
     @property
     @pulumi.getter(name="filterAction")
     def filter_action(self) -> Optional[pulumi.Input[str]]:
         """
-        Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
+        Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "filter_action")
 
     @filter_action.setter
     def filter_action(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "filter_action", value)
 
     @property
     @pulumi.getter(name="filterSource")
     def filter_source(self) -> Optional[pulumi.Input[str]]:
         """
-        Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         return pulumi.get(self, "filter_source")
 
     @filter_source.setter
     def filter_source(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "filter_source", value)
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/external_integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/external_integration.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,24 +13,24 @@
 
 @pulumi.input_type
 class ExternalIntegrationArgs:
     def __init__(__self__, *,
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a ExternalIntegration resource.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: The name of this integration
         """
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        The name of this integration
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -39,54 +39,54 @@
 class _ExternalIntegrationState:
     def __init__(__self__, *,
                  external_id: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  signalfx_aws_account: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering ExternalIntegration resources.
-        :param pulumi.Input[str] external_id: The AWS external ID generated by Splunk Observability to use with an AWS integration.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] signalfx_aws_account: The Splunk Observability AWS account ID to use with an AWS role.
+        :param pulumi.Input[str] external_id: The external ID to use with your IAM role and with `aws.Integration`.
+        :param pulumi.Input[str] name: The name of this integration
+        :param pulumi.Input[str] signalfx_aws_account: The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         """
         if external_id is not None:
             pulumi.set(__self__, "external_id", external_id)
         if name is not None:
             pulumi.set(__self__, "name", name)
         if signalfx_aws_account is not None:
             pulumi.set(__self__, "signalfx_aws_account", signalfx_aws_account)
 
     @property
     @pulumi.getter(name="externalId")
     def external_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The AWS external ID generated by Splunk Observability to use with an AWS integration.
+        The external ID to use with your IAM role and with `aws.Integration`.
         """
         return pulumi.get(self, "external_id")
 
     @external_id.setter
     def external_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "external_id", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        The name of this integration
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="signalfxAwsAccount")
     def signalfx_aws_account(self) -> Optional[pulumi.Input[str]]:
         """
-        The Splunk Observability AWS account ID to use with an AWS role.
+        The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         """
         return pulumi.get(self, "signalfx_aws_account")
 
     @signalfx_aws_account.setter
     def signalfx_aws_account(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "signalfx_aws_account", value)
 
@@ -103,29 +103,17 @@
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         > **WARNING** This resource implements part of a workflow. Use it with `aws.Integration`. Check with Splunk support for your realm's AWS account id.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) The name of this integration
-
-        ## Attributes
-
-        In addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of this integration, used with `aws.Integration`
-        * `external_id` - The external ID to use with your IAM role and with `aws.Integration`.
-        * `signalfx_aws_account` - The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: The name of this integration
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: Optional[ExternalIntegrationArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -134,26 +122,14 @@
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         > **WARNING** This resource implements part of a workflow. Use it with `aws.Integration`. Check with Splunk support for your realm's AWS account id.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) The name of this integration
-
-        ## Attributes
-
-        In addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of this integration, used with `aws.Integration`
-        * `external_id` - The external ID to use with your IAM role and with `aws.Integration`.
-        * `signalfx_aws_account` - The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
-
         :param str resource_name: The name of the resource.
         :param ExternalIntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(ExternalIntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -196,44 +172,44 @@
         """
         Get an existing ExternalIntegration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] external_id: The AWS external ID generated by Splunk Observability to use with an AWS integration.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] signalfx_aws_account: The Splunk Observability AWS account ID to use with an AWS role.
+        :param pulumi.Input[str] external_id: The external ID to use with your IAM role and with `aws.Integration`.
+        :param pulumi.Input[str] name: The name of this integration
+        :param pulumi.Input[str] signalfx_aws_account: The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _ExternalIntegrationState.__new__(_ExternalIntegrationState)
 
         __props__.__dict__["external_id"] = external_id
         __props__.__dict__["name"] = name
         __props__.__dict__["signalfx_aws_account"] = signalfx_aws_account
         return ExternalIntegration(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="externalId")
     def external_id(self) -> pulumi.Output[str]:
         """
-        The AWS external ID generated by Splunk Observability to use with an AWS integration.
+        The external ID to use with your IAM role and with `aws.Integration`.
         """
         return pulumi.get(self, "external_id")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        The name of this integration
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="signalfxAwsAccount")
     def signalfx_aws_account(self) -> pulumi.Output[str]:
         """
-        The Splunk Observability AWS account ID to use with an AWS role.
+        The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         """
         return pulumi.get(self, "signalfx_aws_account")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/integration.py`

 * *Files 13% similar despite different names*

```diff
@@ -34,46 +34,36 @@
                  role_arn: Optional[pulumi.Input[str]] = None,
                  services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  sync_custom_namespaces_only: Optional[pulumi.Input[bool]] = None,
                  token: Optional[pulumi.Input[str]] = None,
                  use_metric_streams_sync: Optional[pulumi.Input[bool]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] integration_id: The ID of this integration
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability should monitor.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-               Splunk Observability imports the metrics so you can monitor them.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-               property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
-        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-               Splunk Observability imports the metrics.
-        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-               Observability monitors the amount of data coming in from the integration.
-        :param pulumi.Input[bool] enable_logs_sync: Enables AWS logs synchronization.
-        :param pulumi.Input[str] external_id: Used with `aws.ExternalIntegration`. Use this property to specify the external id.
-        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-               Watch metrics from AWS.
-        :param pulumi.Input[str] key: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-               that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-               specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-               statistics.
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-               Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-               in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-               syncs all data in all AWS namespaces.
-        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[str] role_arn: Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
-        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-               `custom_namespace_sync_rule` field for details). Defaults to `false`.
-        :param pulumi.Input[str] token: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[bool] use_metric_streams_sync: Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] integration_id: The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
+        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
+        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
+        :param pulumi.Input[bool] enable_logs_sync: Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
+        :param pulumi.Input[str] external_id: The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
+        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
+        :param pulumi.Input[str] key: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
+        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[str] role_arn: Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
+        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
+        :param pulumi.Input[str] token: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
+        :param pulumi.Input[bool] use_metric_streams_sync: Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+               Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+               Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "integration_id", integration_id)
         pulumi.set(__self__, "regions", regions)
         if custom_cloudwatch_namespaces is not None:
             pulumi.set(__self__, "custom_cloudwatch_namespaces", custom_cloudwatch_namespaces)
         if custom_namespace_sync_rules is not None:
@@ -109,255 +99,245 @@
         if use_metric_streams_sync is not None:
             pulumi.set(__self__, "use_metric_streams_sync", use_metric_streams_sync)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="integrationId")
     def integration_id(self) -> pulumi.Input[str]:
         """
-        The ID of this integration
+        The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
         """
         return pulumi.get(self, "integration_id")
 
     @integration_id.setter
     def integration_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "integration_id", value)
 
     @property
     @pulumi.getter
     def regions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of AWS regions that Splunk Observability should monitor.
+        List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
         """
         return pulumi.get(self, "regions")
 
     @regions.setter
     def regions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "regions", value)
 
     @property
     @pulumi.getter(name="customCloudwatchNamespaces")
     def custom_cloudwatch_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-        Splunk Observability imports the metrics so you can monitor them.
+        List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
         """
         return pulumi.get(self, "custom_cloudwatch_namespaces")
 
     @custom_cloudwatch_namespaces.setter
     def custom_cloudwatch_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "custom_cloudwatch_namespaces", value)
 
     @property
     @pulumi.getter(name="customNamespaceSyncRules")
     def custom_namespace_sync_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]]]:
         """
-        Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-        property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
+        Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
         """
         return pulumi.get(self, "custom_namespace_sync_rules")
 
     @custom_namespace_sync_rules.setter
     def custom_namespace_sync_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]]]):
         pulumi.set(self, "custom_namespace_sync_rules", value)
 
     @property
     @pulumi.getter(name="enableAwsUsage")
     def enable_aws_usage(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-        Splunk Observability imports the metrics.
+        Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
         """
         return pulumi.get(self, "enable_aws_usage")
 
     @enable_aws_usage.setter
     def enable_aws_usage(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_aws_usage", value)
 
     @property
     @pulumi.getter(name="enableCheckLargeVolume")
     def enable_check_large_volume(self) -> Optional[pulumi.Input[bool]]:
         """
-        Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-        Observability monitors the amount of data coming in from the integration.
+        Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
         """
         return pulumi.get(self, "enable_check_large_volume")
 
     @enable_check_large_volume.setter
     def enable_check_large_volume(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_check_large_volume", value)
 
     @property
     @pulumi.getter(name="enableLogsSync")
     def enable_logs_sync(self) -> Optional[pulumi.Input[bool]]:
         """
-        Enables AWS logs synchronization.
+        Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
         """
         return pulumi.get(self, "enable_logs_sync")
 
     @enable_logs_sync.setter
     def enable_logs_sync(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_logs_sync", value)
 
     @property
     @pulumi.getter(name="externalId")
     def external_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.ExternalIntegration`. Use this property to specify the external id.
+        The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
         """
         return pulumi.get(self, "external_id")
 
     @external_id.setter
     def external_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "external_id", value)
 
     @property
     @pulumi.getter(name="importCloudWatch")
     def import_cloud_watch(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-        Watch metrics from AWS.
+        Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
         """
         return pulumi.get(self, "import_cloud_watch")
 
     @import_cloud_watch.setter
     def import_cloud_watch(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "import_cloud_watch", value)
 
     @property
     @pulumi.getter
     def key(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.TokenIntegration`. Use this property to specify the token.
+        If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
         """
         return pulumi.get(self, "key")
 
     @key.setter
     def key(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "key", value)
 
     @property
     @pulumi.getter(name="metricStatsToSyncs")
     def metric_stats_to_syncs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]]]:
         """
-        Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-        that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-        specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-        statistics.
+        Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
         """
         return pulumi.get(self, "metric_stats_to_syncs")
 
     @metric_stats_to_syncs.setter
     def metric_stats_to_syncs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]]]):
         pulumi.set(self, "metric_stats_to_syncs", value)
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> Optional[pulumi.Input[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @named_token.setter
     def named_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "named_token", value)
 
     @property
     @pulumi.getter(name="namespaceSyncRules")
     def namespace_sync_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]]]:
         """
-        Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-        Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-        in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-        syncs all data in all AWS namespaces.
+        Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
         """
         return pulumi.get(self, "namespace_sync_rules")
 
     @namespace_sync_rules.setter
     def namespace_sync_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]]]):
         pulumi.set(self, "namespace_sync_rules", value)
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        AWS poll rate (in seconds). Between `60` and `600`.
+        AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @poll_rate.setter
     def poll_rate(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "poll_rate", value)
 
     @property
     @pulumi.getter(name="roleArn")
     def role_arn(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
+        Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
         """
         return pulumi.get(self, "role_arn")
 
     @role_arn.setter
     def role_arn(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "role_arn", value)
 
     @property
     @pulumi.getter
     def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
+        List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @services.setter
     def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "services", value)
 
     @property
     @pulumi.getter(name="syncCustomNamespacesOnly")
     def sync_custom_namespaces_only(self) -> Optional[pulumi.Input[bool]]:
         """
-        Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-        `custom_namespace_sync_rule` field for details). Defaults to `false`.
+        Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
         """
         return pulumi.get(self, "sync_custom_namespaces_only")
 
     @sync_custom_namespaces_only.setter
     def sync_custom_namespaces_only(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "sync_custom_namespaces_only", value)
 
     @property
     @pulumi.getter
     def token(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.TokenIntegration`. Use this property to specify the token.
+        If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
         """
         return pulumi.get(self, "token")
 
     @token.setter
     def token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "token", value)
 
     @property
     @pulumi.getter(name="useMetricStreamsSync")
     def use_metric_streams_sync(self) -> Optional[pulumi.Input[bool]]:
         """
-        Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+        Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+        Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         return pulumi.get(self, "use_metric_streams_sync")
 
     @use_metric_streams_sync.setter
     def use_metric_streams_sync(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "use_metric_streams_sync", value)
 
@@ -387,47 +367,37 @@
                  sync_custom_namespaces_only: Optional[pulumi.Input[bool]] = None,
                  token: Optional[pulumi.Input[str]] = None,
                  use_metric_streams_sync: Optional[pulumi.Input[bool]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
         :param pulumi.Input[str] auth_method: The mechanism used to authenticate with AWS. Use one of `aws.ExternalIntegration` or `aws.TokenIntegration` to define
                this
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-               Splunk Observability imports the metrics so you can monitor them.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-               property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
-        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-               Splunk Observability imports the metrics.
-        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-               Observability monitors the amount of data coming in from the integration.
-        :param pulumi.Input[bool] enable_logs_sync: Enables AWS logs synchronization.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] external_id: Used with `aws.ExternalIntegration`. Use this property to specify the external id.
-        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-               Watch metrics from AWS.
-        :param pulumi.Input[str] integration_id: The ID of this integration
-        :param pulumi.Input[str] key: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-               that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-               specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-               statistics.
-        :param pulumi.Input[str] name: Name of the integration. Please specify the name in `aws.ExternalIntegration` or `signalfx_aws_integration_token`
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-               Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-               in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-               syncs all data in all AWS namespaces.
-        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability should monitor.
-        :param pulumi.Input[str] role_arn: Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
-        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-               `custom_namespace_sync_rule` field for details). Defaults to `false`.
-        :param pulumi.Input[str] token: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[bool] use_metric_streams_sync: Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
+        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
+        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
+        :param pulumi.Input[bool] enable_logs_sync: Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] external_id: The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
+        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
+        :param pulumi.Input[str] integration_id: The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
+        :param pulumi.Input[str] key: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
+        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
+        :param pulumi.Input[str] role_arn: Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
+        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
+        :param pulumi.Input[str] token: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
+        :param pulumi.Input[bool] use_metric_streams_sync: Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+               Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+               Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         if auth_method is not None:
             pulumi.set(__self__, "auth_method", auth_method)
         if custom_cloudwatch_namespaces is not None:
             pulumi.set(__self__, "custom_cloudwatch_namespaces", custom_cloudwatch_namespaces)
         if custom_namespace_sync_rules is not None:
             pulumi.set(__self__, "custom_namespace_sync_rules", custom_namespace_sync_rules)
@@ -483,267 +453,257 @@
     def auth_method(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "auth_method", value)
 
     @property
     @pulumi.getter(name="customCloudwatchNamespaces")
     def custom_cloudwatch_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-        Splunk Observability imports the metrics so you can monitor them.
+        List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
         """
         return pulumi.get(self, "custom_cloudwatch_namespaces")
 
     @custom_cloudwatch_namespaces.setter
     def custom_cloudwatch_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "custom_cloudwatch_namespaces", value)
 
     @property
     @pulumi.getter(name="customNamespaceSyncRules")
     def custom_namespace_sync_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]]]:
         """
-        Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-        property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
+        Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
         """
         return pulumi.get(self, "custom_namespace_sync_rules")
 
     @custom_namespace_sync_rules.setter
     def custom_namespace_sync_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespaceSyncRuleArgs']]]]):
         pulumi.set(self, "custom_namespace_sync_rules", value)
 
     @property
     @pulumi.getter(name="enableAwsUsage")
     def enable_aws_usage(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-        Splunk Observability imports the metrics.
+        Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
         """
         return pulumi.get(self, "enable_aws_usage")
 
     @enable_aws_usage.setter
     def enable_aws_usage(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_aws_usage", value)
 
     @property
     @pulumi.getter(name="enableCheckLargeVolume")
     def enable_check_large_volume(self) -> Optional[pulumi.Input[bool]]:
         """
-        Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-        Observability monitors the amount of data coming in from the integration.
+        Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
         """
         return pulumi.get(self, "enable_check_large_volume")
 
     @enable_check_large_volume.setter
     def enable_check_large_volume(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_check_large_volume", value)
 
     @property
     @pulumi.getter(name="enableLogsSync")
     def enable_logs_sync(self) -> Optional[pulumi.Input[bool]]:
         """
-        Enables AWS logs synchronization.
+        Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
         """
         return pulumi.get(self, "enable_logs_sync")
 
     @enable_logs_sync.setter
     def enable_logs_sync(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enable_logs_sync", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="externalId")
     def external_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.ExternalIntegration`. Use this property to specify the external id.
+        The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
         """
         return pulumi.get(self, "external_id")
 
     @external_id.setter
     def external_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "external_id", value)
 
     @property
     @pulumi.getter(name="importCloudWatch")
     def import_cloud_watch(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-        Watch metrics from AWS.
+        Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
         """
         return pulumi.get(self, "import_cloud_watch")
 
     @import_cloud_watch.setter
     def import_cloud_watch(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "import_cloud_watch", value)
 
     @property
     @pulumi.getter(name="integrationId")
     def integration_id(self) -> Optional[pulumi.Input[str]]:
         """
-        The ID of this integration
+        The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
         """
         return pulumi.get(self, "integration_id")
 
     @integration_id.setter
     def integration_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "integration_id", value)
 
     @property
     @pulumi.getter
     def key(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.TokenIntegration`. Use this property to specify the token.
+        If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
         """
         return pulumi.get(self, "key")
 
     @key.setter
     def key(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "key", value)
 
     @property
     @pulumi.getter(name="metricStatsToSyncs")
     def metric_stats_to_syncs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]]]:
         """
-        Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-        that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-        specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-        statistics.
+        Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
         """
         return pulumi.get(self, "metric_stats_to_syncs")
 
     @metric_stats_to_syncs.setter
     def metric_stats_to_syncs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationMetricStatsToSyncArgs']]]]):
         pulumi.set(self, "metric_stats_to_syncs", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration. Please specify the name in `aws.ExternalIntegration` or `signalfx_aws_integration_token`
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> Optional[pulumi.Input[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @named_token.setter
     def named_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "named_token", value)
 
     @property
     @pulumi.getter(name="namespaceSyncRules")
     def namespace_sync_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]]]:
         """
-        Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-        Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-        in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-        syncs all data in all AWS namespaces.
+        Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
         """
         return pulumi.get(self, "namespace_sync_rules")
 
     @namespace_sync_rules.setter
     def namespace_sync_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationNamespaceSyncRuleArgs']]]]):
         pulumi.set(self, "namespace_sync_rules", value)
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        AWS poll rate (in seconds). Between `60` and `600`.
+        AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @poll_rate.setter
     def poll_rate(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "poll_rate", value)
 
     @property
     @pulumi.getter
     def regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of AWS regions that Splunk Observability should monitor.
+        List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
         """
         return pulumi.get(self, "regions")
 
     @regions.setter
     def regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "regions", value)
 
     @property
     @pulumi.getter(name="roleArn")
     def role_arn(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
+        Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
         """
         return pulumi.get(self, "role_arn")
 
     @role_arn.setter
     def role_arn(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "role_arn", value)
 
     @property
     @pulumi.getter
     def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
+        List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @services.setter
     def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "services", value)
 
     @property
     @pulumi.getter(name="syncCustomNamespacesOnly")
     def sync_custom_namespaces_only(self) -> Optional[pulumi.Input[bool]]:
         """
-        Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-        `custom_namespace_sync_rule` field for details). Defaults to `false`.
+        Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
         """
         return pulumi.get(self, "sync_custom_namespaces_only")
 
     @sync_custom_namespaces_only.setter
     def sync_custom_namespaces_only(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "sync_custom_namespaces_only", value)
 
     @property
     @pulumi.getter
     def token(self) -> Optional[pulumi.Input[str]]:
         """
-        Used with `aws.TokenIntegration`. Use this property to specify the token.
+        If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
         """
         return pulumi.get(self, "token")
 
     @token.setter
     def token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "token", value)
 
     @property
     @pulumi.getter(name="useMetricStreamsSync")
     def use_metric_streams_sync(self) -> Optional[pulumi.Input[bool]]:
         """
-        Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+        Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+        Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         return pulumi.get(self, "use_metric_streams_sync")
 
     @use_metric_streams_sync.setter
     def use_metric_streams_sync(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "use_metric_streams_sync", value)
 
@@ -779,85 +739,38 @@
 
         This resource implements a part of a workflow. Use it with one of either `aws.ExternalIntegration` or `aws.TokenIntegration`.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         ## Example
 
-        ## Arguments
-
-        * `enable_aws_usage` - (Optional) Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
-        * `enable_check_large_volume` - (Optional) Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
-        * `enable_logs_sync` - (Optional) Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `external_id` - (Required) The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
-        * `custom_cloudwatch_namespaces` - (Optional) List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
-        * `custom_namespace_sync_rule` - (Optional) Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
-          * `default_action` - (Optional) Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_action` - (Optional) Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_source` - (Optional) Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
-          * `namespace` - (Required) An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
-        * `import_cloud_watch` - (Optional) Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
-        * `integration_id` - (Required) The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
-        * `key` - (Optional) If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
-        * `metric_stats_to_sync` - (Optional) Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
-          * `metric` - (Required) AWS metric that you want to pick statistics for
-          * `namespace` - (Required) An AWS namespace having AWS metric that you want to pick statistics for
-          * `stats` - (Required) AWS statistics you want to collect
-        * `name` - (Required) Name of the integration.
-        * `named_token` - (Optional) Name of the org token to be used for data ingestion. If not specified then default access token is used.
-        * `namespace_sync_rule` - (Optional) Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
-          * `default_action` - (Optional) Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_action` - (Optional) Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_source` - (Optional) Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
-          * `namespace` - (Required) An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
-        * `poll_rate` - (Optional) AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
-        * `regions` - (Required) List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
-        * `role_arn` - (Optional) Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
-        * `services` - (Optional) List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
-        * `sync_custom_namespaces_only` - (Optional) Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
-        * `token` - (Optional) If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
-        * `use_metric_streams_sync` - (Optional) Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
-          Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
-          Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-               Splunk Observability imports the metrics so you can monitor them.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespaceSyncRuleArgs']]]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-               property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
-        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-               Splunk Observability imports the metrics.
-        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-               Observability monitors the amount of data coming in from the integration.
-        :param pulumi.Input[bool] enable_logs_sync: Enables AWS logs synchronization.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] external_id: Used with `aws.ExternalIntegration`. Use this property to specify the external id.
-        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-               Watch metrics from AWS.
-        :param pulumi.Input[str] integration_id: The ID of this integration
-        :param pulumi.Input[str] key: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationMetricStatsToSyncArgs']]]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-               that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-               specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-               statistics.
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationNamespaceSyncRuleArgs']]]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-               Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-               in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-               syncs all data in all AWS namespaces.
-        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability should monitor.
-        :param pulumi.Input[str] role_arn: Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
-        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-               `custom_namespace_sync_rule` field for details). Defaults to `false`.
-        :param pulumi.Input[str] token: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[bool] use_metric_streams_sync: Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespaceSyncRuleArgs']]]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
+        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
+        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
+        :param pulumi.Input[bool] enable_logs_sync: Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] external_id: The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
+        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
+        :param pulumi.Input[str] integration_id: The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
+        :param pulumi.Input[str] key: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationMetricStatsToSyncArgs']]]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationNamespaceSyncRuleArgs']]]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
+        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
+        :param pulumi.Input[str] role_arn: Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
+        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
+        :param pulumi.Input[str] token: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
+        :param pulumi.Input[bool] use_metric_streams_sync: Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+               Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+               Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -866,51 +779,14 @@
 
         This resource implements a part of a workflow. Use it with one of either `aws.ExternalIntegration` or `aws.TokenIntegration`.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         ## Example
 
-        ## Arguments
-
-        * `enable_aws_usage` - (Optional) Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
-        * `enable_check_large_volume` - (Optional) Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
-        * `enable_logs_sync` - (Optional) Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `external_id` - (Required) The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
-        * `custom_cloudwatch_namespaces` - (Optional) List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
-        * `custom_namespace_sync_rule` - (Optional) Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
-          * `default_action` - (Optional) Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_action` - (Optional) Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_source` - (Optional) Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
-          * `namespace` - (Required) An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
-        * `import_cloud_watch` - (Optional) Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
-        * `integration_id` - (Required) The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
-        * `key` - (Optional) If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
-        * `metric_stats_to_sync` - (Optional) Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
-          * `metric` - (Required) AWS metric that you want to pick statistics for
-          * `namespace` - (Required) An AWS namespace having AWS metric that you want to pick statistics for
-          * `stats` - (Required) AWS statistics you want to collect
-        * `name` - (Required) Name of the integration.
-        * `named_token` - (Optional) Name of the org token to be used for data ingestion. If not specified then default access token is used.
-        * `namespace_sync_rule` - (Optional) Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
-          * `default_action` - (Optional) Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_action` - (Optional) Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
-          * `filter_source` - (Optional) Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
-          * `namespace` - (Required) An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
-        * `poll_rate` - (Optional) AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
-        * `regions` - (Required) List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
-        * `role_arn` - (Optional) Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
-        * `services` - (Optional) List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
-        * `sync_custom_namespaces_only` - (Optional) Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
-        * `token` - (Optional) If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
-        * `use_metric_streams_sync` - (Optional) Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
-          Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
-          Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -1018,47 +894,37 @@
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[str] auth_method: The mechanism used to authenticate with AWS. Use one of `aws.ExternalIntegration` or `aws.TokenIntegration` to define
                this
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-               Splunk Observability imports the metrics so you can monitor them.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespaceSyncRuleArgs']]]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-               property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
-        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-               Splunk Observability imports the metrics.
-        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-               Observability monitors the amount of data coming in from the integration.
-        :param pulumi.Input[bool] enable_logs_sync: Enables AWS logs synchronization.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] external_id: Used with `aws.ExternalIntegration`. Use this property to specify the external id.
-        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-               Watch metrics from AWS.
-        :param pulumi.Input[str] integration_id: The ID of this integration
-        :param pulumi.Input[str] key: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationMetricStatsToSyncArgs']]]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-               that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-               specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-               statistics.
-        :param pulumi.Input[str] name: Name of the integration. Please specify the name in `aws.ExternalIntegration` or `signalfx_aws_integration_token`
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationNamespaceSyncRuleArgs']]]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-               Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-               in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-               syncs all data in all AWS namespaces.
-        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability should monitor.
-        :param pulumi.Input[str] role_arn: Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
-        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-               `custom_namespace_sync_rule` field for details). Defaults to `false`.
-        :param pulumi.Input[str] token: Used with `aws.TokenIntegration`. Use this property to specify the token.
-        :param pulumi.Input[bool] use_metric_streams_sync: Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_cloudwatch_namespaces: List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespaceSyncRuleArgs']]]] custom_namespace_sync_rules: Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
+        :param pulumi.Input[bool] enable_aws_usage: Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
+        :param pulumi.Input[bool] enable_check_large_volume: Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
+        :param pulumi.Input[bool] enable_logs_sync: Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] external_id: The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
+        :param pulumi.Input[bool] import_cloud_watch: Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
+        :param pulumi.Input[str] integration_id: The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
+        :param pulumi.Input[str] key: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationMetricStatsToSyncArgs']]]] metric_stats_to_syncs: Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationNamespaceSyncRuleArgs']]]] namespace_sync_rules: Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
+        :param pulumi.Input[int] poll_rate: AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] regions: List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
+        :param pulumi.Input[str] role_arn: Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
+        :param pulumi.Input[bool] sync_custom_namespaces_only: Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
+        :param pulumi.Input[str] token: If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
+        :param pulumi.Input[bool] use_metric_streams_sync: Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+               Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+               Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
         __props__.__dict__["auth_method"] = auth_method
         __props__.__dict__["custom_cloudwatch_namespaces"] = custom_cloudwatch_namespaces
@@ -1093,183 +959,173 @@
         """
         return pulumi.get(self, "auth_method")
 
     @property
     @pulumi.getter(name="customCloudwatchNamespaces")
     def custom_cloudwatch_namespaces(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS;
-        Splunk Observability imports the metrics so you can monitor them.
+        List of custom AWS CloudWatch namespaces to monitor. Custom namespaces contain custom metrics that you define in AWS; Splunk Observability Cloud imports the metrics so you can monitor them.
         """
         return pulumi.get(self, "custom_cloudwatch_namespaces")
 
     @property
     @pulumi.getter(name="customNamespaceSyncRules")
     def custom_namespace_sync_rules(self) -> pulumi.Output[Optional[Sequence['outputs.IntegrationCustomNamespaceSyncRule']]]:
         """
-        Each element controls the data collected by Splunk Observability for the specified namespace. If you specify this
-        property, Splunk Observability ignores values in the "custom_cloudwatch_namespaces" property.
+        Each element controls the data collected by Splunk Observability Cloud for the specified namespace. Conflicts with the `custom_cloudwatch_namespaces` property.
         """
         return pulumi.get(self, "custom_namespace_sync_rules")
 
     @property
     @pulumi.getter(name="enableAwsUsage")
     def enable_aws_usage(self) -> pulumi.Output[Optional[bool]]:
         """
-        Flag that controls how Splunk Observability imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`,
-        Splunk Observability imports the metrics.
+        Flag that controls how Splunk Observability Cloud imports usage metrics from AWS to use with AWS Cost Optimizer. If `true`, Splunk Observability Cloud imports the metrics.
         """
         return pulumi.get(self, "enable_aws_usage")
 
     @property
     @pulumi.getter(name="enableCheckLargeVolume")
     def enable_check_large_volume(self) -> pulumi.Output[Optional[bool]]:
         """
-        Controls how Splunk Observability checks for large amounts of data for this AWS integration. If true, Splunk
-        Observability monitors the amount of data coming in from the integration.
+        Controls how Splunk Observability Cloud checks for large amounts of data for this AWS integration. If `true`, Splunk Observability Cloud monitors the amount of data coming in from the integration.
         """
         return pulumi.get(self, "enable_check_large_volume")
 
     @property
     @pulumi.getter(name="enableLogsSync")
     def enable_logs_sync(self) -> pulumi.Output[bool]:
         """
-        Enables AWS logs synchronization.
+        Enable the AWS logs synchronization. Note that this requires the inclusion of `"logs:DescribeLogGroups"`,  `"logs:DeleteSubscriptionFilter"`, `"logs:DescribeSubscriptionFilters"`, `"logs:PutSubscriptionFilter"`, and `"s3:GetBucketLogging"`,  `"s3:GetBucketNotification"`, `"s3:PutBucketNotification"` permissions. Additional permissions may be required to capture logs from specific AWS services.
         """
         return pulumi.get(self, "enable_logs_sync")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="externalId")
     def external_id(self) -> pulumi.Output[Optional[str]]:
         """
-        Used with `aws.ExternalIntegration`. Use this property to specify the external id.
+        The `external_id` property from one of a `aws.ExternalIntegration` or `aws.TokenIntegration`
         """
         return pulumi.get(self, "external_id")
 
     @property
     @pulumi.getter(name="importCloudWatch")
     def import_cloud_watch(self) -> pulumi.Output[Optional[bool]]:
         """
-        Flag that controls how Splunk Observability imports Cloud Watch metrics. If true, Splunk Observability imports Cloud
-        Watch metrics from AWS.
+        Flag that controls how Splunk Observability Cloud imports Cloud Watch metrics. If true, Splunk Observability Cloud imports Cloud Watch metrics from AWS.
         """
         return pulumi.get(self, "import_cloud_watch")
 
     @property
     @pulumi.getter(name="integrationId")
     def integration_id(self) -> pulumi.Output[str]:
         """
-        The ID of this integration
+        The id of one of a `aws.ExternalIntegration` or `aws.TokenIntegration`.
         """
         return pulumi.get(self, "integration_id")
 
     @property
     @pulumi.getter
     def key(self) -> pulumi.Output[Optional[str]]:
         """
-        Used with `aws.TokenIntegration`. Use this property to specify the token.
+        If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the key (this is typically equivalent to the `AWS_SECRET_ACCESS_KEY` environment variable).
         """
         return pulumi.get(self, "key")
 
     @property
     @pulumi.getter(name="metricStatsToSyncs")
     def metric_stats_to_syncs(self) -> pulumi.Output[Optional[Sequence['outputs.IntegrationMetricStatsToSync']]]:
         """
-        Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics
-        that Splunk Observability collects for this metric. If you specify this property, Splunk Observability retrieves only
-        specified AWS statistics. If you don't specify this property, Splunk Observability retrieves the AWS standard set of
-        statistics.
+        Each element in the array is an object that contains an AWS namespace name, AWS metric name and a list of statistics that Splunk Observability Cloud collects for this metric. If you specify this property, Splunk Observability Cloud retrieves only specified AWS statistics when AWS metric streams are not used. When AWS metric streams are used this property specifies additional extended statistics to collect (please note that AWS metric streams API supports percentile stats only; other stats are ignored). If you don't specify this property, Splunk Observability Cloud retrieves the AWS standard set of statistics.
         """
         return pulumi.get(self, "metric_stats_to_syncs")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration. Please specify the name in `aws.ExternalIntegration` or `signalfx_aws_integration_token`
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> pulumi.Output[Optional[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @property
     @pulumi.getter(name="namespaceSyncRules")
     def namespace_sync_rules(self) -> pulumi.Output[Optional[Sequence['outputs.IntegrationNamespaceSyncRule']]]:
         """
-        Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that
-        Splunk Observability collects for the namespace. If you specify this property, Splunk Observability ignores the values
-        in the AWS CloudWatch Integration Model "services" property. If you don't specify either property, Splunk Observability
-        syncs all data in all AWS namespaces.
+        Each element in the array is an object that contains an AWS namespace name and a filter that controls the data that Splunk Observability Cloud collects for the namespace. Conflicts with the `services` property. If you don't specify either property, Splunk Observability Cloud syncs all data in all AWS namespaces.
         """
         return pulumi.get(self, "namespace_sync_rules")
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> pulumi.Output[Optional[int]]:
         """
-        AWS poll rate (in seconds). Between `60` and `600`.
+        AWS poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @property
     @pulumi.getter
     def regions(self) -> pulumi.Output[Sequence[str]]:
         """
-        List of AWS regions that Splunk Observability should monitor.
+        List of AWS regions that Splunk Observability Cloud should monitor. It cannot be empty.
         """
         return pulumi.get(self, "regions")
 
     @property
     @pulumi.getter(name="roleArn")
     def role_arn(self) -> pulumi.Output[Optional[str]]:
         """
-        Used with `aws.ExternalIntegration`. Use this property to specify the AIM role ARN.
+        Role ARN that you add to an existing AWS integration object. **Note**: Ensure you use the `arn` property of your role, not the id!
         """
         return pulumi.get(self, "role_arn")
 
     @property
     @pulumi.getter
     def services(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of AWS services that you want Splunk Observability to monitor. Each element is a string designating an AWS service.
+        List of AWS services that you want Splunk Observability Cloud to monitor. Each element is a string designating an AWS service. Can be an empty list to import data for all supported services. Conflicts with `namespace_sync_rule`. See [Amazon Web Services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#amazon-web-services) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @property
     @pulumi.getter(name="syncCustomNamespacesOnly")
     def sync_custom_namespaces_only(self) -> pulumi.Output[Optional[bool]]:
         """
-        Indicates that Splunk Observability should sync metrics and metadata from custom AWS namespaces only (see the
-        `custom_namespace_sync_rule` field for details). Defaults to `false`.
+        Indicates that Splunk Observability Cloud should sync metrics and metadata from custom AWS namespaces only (see the `custom_namespace_sync_rule` above). Defaults to `false`.
         """
         return pulumi.get(self, "sync_custom_namespaces_only")
 
     @property
     @pulumi.getter
     def token(self) -> pulumi.Output[Optional[str]]:
         """
-        Used with `aws.TokenIntegration`. Use this property to specify the token.
+        If you specify `auth_method = \\"SecurityToken\\"` in your request to create an AWS integration object, use this property to specify the token (this is typically equivalent to the `AWS_ACCESS_KEY_ID` environment variable).
         """
         return pulumi.get(self, "token")
 
     @property
     @pulumi.getter(name="useMetricStreamsSync")
     def use_metric_streams_sync(self) -> pulumi.Output[bool]:
         """
-        Enables the use of Cloudwatch Metric Streams for metrics synchronization.
+        Enable the use of Amazon Cloudwatch Metric Streams for ingesting metrics.<br>
+        Note that this requires the inclusion of `"cloudwatch:ListMetricStreams"`,`"cloudwatch:GetMetricStream"`, `"cloudwatch:PutMetricStream"`, `"cloudwatch:DeleteMetricStream"`, `"cloudwatch:StartMetricStreams"`, `"cloudwatch:StopMetricStreams"` and `"iam:PassRole"` permissions.<br>
+        Note you need to deploy additional resources on your AWS account to enable CloudWatch metrics streaming. Select one of the [CloudFormation templates](https://docs.splunk.com/Observability/gdi/get-data-in/connect/aws/aws-cloudformation.html) to deploy all the required resources.
         """
         return pulumi.get(self, "use_metric_streams_sync")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/outputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/outputs.py`

 * *Files 20% similar despite different names*

```diff
@@ -40,56 +40,56 @@
 
     def __init__(__self__, *,
                  namespace: str,
                  default_action: Optional[str] = None,
                  filter_action: Optional[str] = None,
                  filter_source: Optional[str] = None):
         """
-        :param str namespace: An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
-        :param str default_action: Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
-        :param str filter_action: Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
-        :param str filter_source: Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        :param str namespace: An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
+        :param str default_action: Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
+        :param str filter_action: Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
+        :param str filter_source: Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         pulumi.set(__self__, "namespace", namespace)
         if default_action is not None:
             pulumi.set(__self__, "default_action", default_action)
         if filter_action is not None:
             pulumi.set(__self__, "filter_action", filter_action)
         if filter_source is not None:
             pulumi.set(__self__, "filter_source", filter_source)
 
     @property
     @pulumi.getter
     def namespace(self) -> str:
         """
-        An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
+        An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See the AWS documentation on publishing metrics for more information.
         """
         return pulumi.get(self, "namespace")
 
     @property
     @pulumi.getter(name="defaultAction")
     def default_action(self) -> Optional[str]:
         """
-        Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
+        Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "default_action")
 
     @property
     @pulumi.getter(name="filterAction")
     def filter_action(self) -> Optional[str]:
         """
-        Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
+        Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "filter_action")
 
     @property
     @pulumi.getter(name="filterSource")
     def filter_source(self) -> Optional[str]:
         """
-        Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         return pulumi.get(self, "filter_source")
 
 
 @pulumi.output_type
 class IntegrationMetricStatsToSync(dict):
     def __init__(__self__, *,
@@ -155,53 +155,53 @@
 
     def __init__(__self__, *,
                  namespace: str,
                  default_action: Optional[str] = None,
                  filter_action: Optional[str] = None,
                  filter_source: Optional[str] = None):
         """
-        :param str namespace: An AWS namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
-        :param str default_action: Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
-        :param str filter_action: Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
-        :param str filter_source: Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        :param str namespace: An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
+        :param str default_action: Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
+        :param str filter_action: Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
+        :param str filter_source: Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         pulumi.set(__self__, "namespace", namespace)
         if default_action is not None:
             pulumi.set(__self__, "default_action", default_action)
         if filter_action is not None:
             pulumi.set(__self__, "filter_action", filter_action)
         if filter_source is not None:
             pulumi.set(__self__, "filter_source", filter_source)
 
     @property
     @pulumi.getter
     def namespace(self) -> str:
         """
-        An AWS namespace having custom AWS metrics that you want to sync with Splunk Observability. See the AWS documentation on publishing metrics for more information.
+        An AWS custom namespace having custom AWS metrics that you want to sync with Splunk Observability Cloud. See `services` field description below for additional information.
         """
         return pulumi.get(self, "namespace")
 
     @property
     @pulumi.getter(name="defaultAction")
     def default_action(self) -> Optional[str]:
         """
-        Controls the Splunk Observability default behavior for processing data from an AWS namespace. Splunk Observability ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability treats data that doesn't match the filter. The available actions are one of "Include" or "Exclude".
+        Controls the Splunk Observability Cloud default behavior for processing data from an AWS namespace. Splunk Observability Cloud ignores this property unless you specify the `filter_action` and `filter_source` properties. If you do specify them, use this property to control how Splunk Observability Cloud treats data that doesn't match the filter. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "default_action")
 
     @property
     @pulumi.getter(name="filterAction")
     def filter_action(self) -> Optional[str]:
         """
-        Controls how Splunk Observability processes data from a custom AWS namespace. The available actions are one of "Include" or "Exclude".
+        Controls how Splunk Observability Cloud processes data from a custom AWS namespace. The available actions are one of `"Include"` or `"Exclude"`.
         """
         return pulumi.get(self, "filter_action")
 
     @property
     @pulumi.getter(name="filterSource")
     def filter_source(self) -> Optional[str]:
         """
-        Expression that selects the data that Splunk Observability should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
+        Expression that selects the data that Splunk Observability Cloud should sync for the custom namespace associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function; it can be any valid SignalFlow filter expression.
         """
         return pulumi.get(self, "filter_source")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/aws/token_integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/aws/token_integration.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,24 +13,24 @@
 
 @pulumi.input_type
 class TokenIntegrationArgs:
     def __init__(__self__, *,
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a TokenIntegration resource.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: The name of this integration
         """
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        The name of this integration
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -39,42 +39,42 @@
 class _TokenIntegrationState:
     def __init__(__self__, *,
                  name: Optional[pulumi.Input[str]] = None,
                  signalfx_aws_account: Optional[pulumi.Input[str]] = None,
                  token_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering TokenIntegration resources.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] signalfx_aws_account: The Splunk Observability AWS account ID to use with an AWS role.
+        :param pulumi.Input[str] name: The name of this integration
+        :param pulumi.Input[str] signalfx_aws_account: The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         :param pulumi.Input[str] token_id: The SignalFx-generated AWS token to use with an AWS integration.
         """
         if name is not None:
             pulumi.set(__self__, "name", name)
         if signalfx_aws_account is not None:
             pulumi.set(__self__, "signalfx_aws_account", signalfx_aws_account)
         if token_id is not None:
             pulumi.set(__self__, "token_id", token_id)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        The name of this integration
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="signalfxAwsAccount")
     def signalfx_aws_account(self) -> Optional[pulumi.Input[str]]:
         """
-        The Splunk Observability AWS account ID to use with an AWS role.
+        The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         """
         return pulumi.get(self, "signalfx_aws_account")
 
     @signalfx_aws_account.setter
     def signalfx_aws_account(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "signalfx_aws_account", value)
 
@@ -103,28 +103,17 @@
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observabilit Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         > **WARNING** This resource implements a part of a workflow. You must use it with `aws.Integration`.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) The name of this integration
-
-        ## Attributes
-
-        In addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration to use with `aws.Integration`
-        * `signalfx_aws_account` - The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: The name of this integration
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: Optional[TokenIntegrationArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -133,25 +122,14 @@
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observabilit Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         > **WARNING** This resource implements a part of a workflow. You must use it with `aws.Integration`.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) The name of this integration
-
-        ## Attributes
-
-        In addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration to use with `aws.Integration`
-        * `signalfx_aws_account` - The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
-
         :param str resource_name: The name of the resource.
         :param TokenIntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(TokenIntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -194,16 +172,16 @@
         """
         Get an existing TokenIntegration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] signalfx_aws_account: The Splunk Observability AWS account ID to use with an AWS role.
+        :param pulumi.Input[str] name: The name of this integration
+        :param pulumi.Input[str] signalfx_aws_account: The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         :param pulumi.Input[str] token_id: The SignalFx-generated AWS token to use with an AWS integration.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _TokenIntegrationState.__new__(_TokenIntegrationState)
 
         __props__.__dict__["name"] = name
@@ -211,23 +189,23 @@
         __props__.__dict__["token_id"] = token_id
         return TokenIntegration(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        The name of this integration
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="signalfxAwsAccount")
     def signalfx_aws_account(self) -> pulumi.Output[str]:
         """
-        The Splunk Observability AWS account ID to use with an AWS role.
+        The AWS Account ARN to use with your policies/roles, provided by Splunk Observability Cloud.
         """
         return pulumi.get(self, "signalfx_aws_account")
 
     @property
     @pulumi.getter(name="tokenId")
     def token_id(self) -> pulumi.Output[str]:
         """
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/integration.py`

 * *Files 19% similar despite different names*

```diff
@@ -29,39 +29,29 @@
                  name: Optional[pulumi.Input[str]] = None,
                  named_token: Optional[pulumi.Input[str]] = None,
                  poll_rate: Optional[pulumi.Input[int]] = None,
                  resource_filter_rules: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]]] = None,
                  sync_guest_os_namespaces: Optional[pulumi.Input[bool]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-               Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] subscriptions: List of Azure subscriptions that Splunk Observability Cloud should monitor.
-        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant.
+        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_services: Additional Azure resource types that you want to sync with Observability Cloud.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-               `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-               so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-               addition to the default namespaces.
-        :param pulumi.Input[str] environment: what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-               `"azure"`
-        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-               import only metadata. Defaults to true.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]] resource_filter_rules: List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-               filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-               limited to tags and must start with the azure_tag_ prefix..
-        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-               telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-               Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
+        :param pulumi.Input[str] environment: What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
+        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]] resource_filter_rules: List of rules for filtering Azure resources by their tags.
+        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
         """
         pulumi.set(__self__, "app_id", app_id)
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "secret_key", secret_key)
         pulumi.set(__self__, "services", services)
         pulumi.set(__self__, "subscriptions", subscriptions)
         pulumi.set(__self__, "tenant_id", tenant_id)
@@ -84,52 +74,51 @@
         if sync_guest_os_namespaces is not None:
             pulumi.set(__self__, "sync_guest_os_namespaces", sync_guest_os_namespaces)
 
     @property
     @pulumi.getter(name="appId")
     def app_id(self) -> pulumi.Input[str]:
         """
-        Azure application ID for the Splunk Observability Cloud app.
+        Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "app_id")
 
     @app_id.setter
     def app_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "app_id", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="secretKey")
     def secret_key(self) -> pulumi.Input[str]:
         """
-        Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
+        Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "secret_key")
 
     @secret_key.setter
     def secret_key(self, value: pulumi.Input[str]):
         pulumi.set(self, "secret_key", value)
 
     @property
     @pulumi.getter
     def services(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-        Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @services.setter
     def services(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "services", value)
 
@@ -145,15 +134,15 @@
     def subscriptions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
         pulumi.set(self, "subscriptions", value)
 
     @property
     @pulumi.getter(name="tenantId")
     def tenant_id(self) -> pulumi.Input[str]:
         """
-        Azure ID of the Azure tenant.
+        Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "tenant_id")
 
     @tenant_id.setter
     def tenant_id(self, value: pulumi.Input[str]):
         pulumi.set(self, "tenant_id", value)
 
@@ -169,108 +158,99 @@
     def additional_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "additional_services", value)
 
     @property
     @pulumi.getter(name="customNamespacesPerServices")
     def custom_namespaces_per_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]]]:
         """
-        Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-        `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-        so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-        addition to the default namespaces.
+        Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
         """
         return pulumi.get(self, "custom_namespaces_per_services")
 
     @custom_namespaces_per_services.setter
     def custom_namespaces_per_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]]]):
         pulumi.set(self, "custom_namespaces_per_services", value)
 
     @property
     @pulumi.getter
     def environment(self) -> Optional[pulumi.Input[str]]:
         """
-        what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-        `"azure"`
+        What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
         """
         return pulumi.get(self, "environment")
 
     @environment.setter
     def environment(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "environment", value)
 
     @property
     @pulumi.getter(name="importAzureMonitor")
     def import_azure_monitor(self) -> Optional[pulumi.Input[bool]]:
         """
-        If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-        import only metadata. Defaults to true.
+        If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
         """
         return pulumi.get(self, "import_azure_monitor")
 
     @import_azure_monitor.setter
     def import_azure_monitor(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "import_azure_monitor", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> Optional[pulumi.Input[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @named_token.setter
     def named_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "named_token", value)
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        Azure poll rate (in seconds). Between `60` and `600`.
+        Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @poll_rate.setter
     def poll_rate(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "poll_rate", value)
 
     @property
     @pulumi.getter(name="resourceFilterRules")
     def resource_filter_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]]]:
         """
-        List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-        filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-        limited to tags and must start with the azure_tag_ prefix..
+        List of rules for filtering Azure resources by their tags.
         """
         return pulumi.get(self, "resource_filter_rules")
 
     @resource_filter_rules.setter
     def resource_filter_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]]]):
         pulumi.set(self, "resource_filter_rules", value)
 
     @property
     @pulumi.getter(name="syncGuestOsNamespaces")
     def sync_guest_os_namespaces(self) -> Optional[pulumi.Input[bool]]:
         """
-        If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-        telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-        Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
+        If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
         """
         return pulumi.get(self, "sync_guest_os_namespaces")
 
     @sync_guest_os_namespaces.setter
     def sync_guest_os_namespaces(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "sync_guest_os_namespaces", value)
 
@@ -292,38 +272,28 @@
                  services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  subscriptions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  sync_guest_os_namespaces: Optional[pulumi.Input[bool]] = None,
                  tenant_id: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_services: Additional Azure resource types that you want to sync with Observability Cloud.
-        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-               `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-               so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-               addition to the default namespaces.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] environment: what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-               `"azure"`
-        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-               import only metadata. Defaults to true.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]] resource_filter_rules: List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-               filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-               limited to tags and must start with the azure_tag_ prefix..
-        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-               Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] environment: What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
+        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]] resource_filter_rules: List of rules for filtering Azure resources by their tags.
+        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] subscriptions: List of Azure subscriptions that Splunk Observability Cloud should monitor.
-        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-               telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-               Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
-        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant.
+        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
+        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         if additional_services is not None:
             pulumi.set(__self__, "additional_services", additional_services)
         if app_id is not None:
             pulumi.set(__self__, "app_id", app_id)
         if custom_namespaces_per_services is not None:
             pulumi.set(__self__, "custom_namespaces_per_services", custom_namespaces_per_services)
@@ -364,143 +334,135 @@
     def additional_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "additional_services", value)
 
     @property
     @pulumi.getter(name="appId")
     def app_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Azure application ID for the Splunk Observability Cloud app.
+        Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "app_id")
 
     @app_id.setter
     def app_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "app_id", value)
 
     @property
     @pulumi.getter(name="customNamespacesPerServices")
     def custom_namespaces_per_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]]]:
         """
-        Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-        `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-        so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-        addition to the default namespaces.
+        Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
         """
         return pulumi.get(self, "custom_namespaces_per_services")
 
     @custom_namespaces_per_services.setter
     def custom_namespaces_per_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationCustomNamespacesPerServiceArgs']]]]):
         pulumi.set(self, "custom_namespaces_per_services", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def environment(self) -> Optional[pulumi.Input[str]]:
         """
-        what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-        `"azure"`
+        What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
         """
         return pulumi.get(self, "environment")
 
     @environment.setter
     def environment(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "environment", value)
 
     @property
     @pulumi.getter(name="importAzureMonitor")
     def import_azure_monitor(self) -> Optional[pulumi.Input[bool]]:
         """
-        If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-        import only metadata. Defaults to true.
+        If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
         """
         return pulumi.get(self, "import_azure_monitor")
 
     @import_azure_monitor.setter
     def import_azure_monitor(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "import_azure_monitor", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> Optional[pulumi.Input[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @named_token.setter
     def named_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "named_token", value)
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        Azure poll rate (in seconds). Between `60` and `600`.
+        Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @poll_rate.setter
     def poll_rate(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "poll_rate", value)
 
     @property
     @pulumi.getter(name="resourceFilterRules")
     def resource_filter_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]]]:
         """
-        List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-        filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-        limited to tags and must start with the azure_tag_ prefix..
+        List of rules for filtering Azure resources by their tags.
         """
         return pulumi.get(self, "resource_filter_rules")
 
     @resource_filter_rules.setter
     def resource_filter_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationResourceFilterRuleArgs']]]]):
         pulumi.set(self, "resource_filter_rules", value)
 
     @property
     @pulumi.getter(name="secretKey")
     def secret_key(self) -> Optional[pulumi.Input[str]]:
         """
-        Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
+        Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "secret_key")
 
     @secret_key.setter
     def secret_key(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "secret_key", value)
 
     @property
     @pulumi.getter
     def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-        Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @services.setter
     def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "services", value)
 
@@ -516,29 +478,27 @@
     def subscriptions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "subscriptions", value)
 
     @property
     @pulumi.getter(name="syncGuestOsNamespaces")
     def sync_guest_os_namespaces(self) -> Optional[pulumi.Input[bool]]:
         """
-        If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-        telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-        Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
+        If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
         """
         return pulumi.get(self, "sync_guest_os_namespaces")
 
     @sync_guest_os_namespaces.setter
     def sync_guest_os_namespaces(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "sync_guest_os_namespaces", value)
 
     @property
     @pulumi.getter(name="tenantId")
     def tenant_id(self) -> Optional[pulumi.Input[str]]:
         """
-        Azure ID of the Azure tenant.
+        Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "tenant_id")
 
     @tenant_id.setter
     def tenant_id(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "tenant_id", value)
 
@@ -567,107 +527,45 @@
         """
         Splunk Observability Cloud Azure integrations. For help with this integration see [Monitoring Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html).
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `app_id` - (Required) Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `custom_namespaces_per_service` - (Optional) Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
-          * `namespaces` - (Required) The additional namespaces.
-          * `service` - (Required) The name of the service.
-        * `environment` (Optional) What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
-        * `name` - (Required) Name of the integration.
-        * `named_token` - (Optional) Name of the org token to be used for data ingestion. If not specified then default access token is used.
-        * `poll_rate` - (Optional) Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
-        * `resource_filter_rules` - (Optional) List of rules for filtering Azure resources by their tags.
-          * `filter_source` - (Required) Expression that selects the data that Splunk Observability Cloud should sync for the resource associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function. The source of each filter rule must be in the form filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are limited to tags and must start with the azure_tag_ prefix.
-        * `secret_key` - (Required) Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
-        * `services` - (Required) List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
-        * `subscriptions` - (Required) List of Azure subscriptions that Splunk Observability Cloud should monitor.
-        * `sync_guest_os_namespaces` - (Optional) If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
-        * `import_azure_monitor` - (Optional) If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
-        * `tenant_id` (Required) Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_services: Additional Azure resource types that you want to sync with Observability Cloud.
-        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespacesPerServiceArgs']]]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-               `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-               so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-               addition to the default namespaces.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] environment: what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-               `"azure"`
-        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-               import only metadata. Defaults to true.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationResourceFilterRuleArgs']]]] resource_filter_rules: List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-               filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-               limited to tags and must start with the azure_tag_ prefix..
-        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-               Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespacesPerServiceArgs']]]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] environment: What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
+        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationResourceFilterRuleArgs']]]] resource_filter_rules: List of rules for filtering Azure resources by their tags.
+        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] subscriptions: List of Azure subscriptions that Splunk Observability Cloud should monitor.
-        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-               telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-               Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
-        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant.
+        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
+        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Splunk Observability Cloud Azure integrations. For help with this integration see [Monitoring Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html).
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `app_id` - (Required) Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `custom_namespaces_per_service` - (Optional) Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
-          * `namespaces` - (Required) The additional namespaces.
-          * `service` - (Required) The name of the service.
-        * `environment` (Optional) What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
-        * `name` - (Required) Name of the integration.
-        * `named_token` - (Optional) Name of the org token to be used for data ingestion. If not specified then default access token is used.
-        * `poll_rate` - (Optional) Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
-        * `resource_filter_rules` - (Optional) List of rules for filtering Azure resources by their tags.
-          * `filter_source` - (Required) Expression that selects the data that Splunk Observability Cloud should sync for the resource associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function. The source of each filter rule must be in the form filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are limited to tags and must start with the azure_tag_ prefix.
-        * `secret_key` - (Required) Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
-        * `services` - (Required) List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
-        * `subscriptions` - (Required) List of Azure subscriptions that Splunk Observability Cloud should monitor.
-        * `sync_guest_os_namespaces` - (Optional) If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
-        * `import_azure_monitor` - (Optional) If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
-        * `tenant_id` (Required) Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -761,38 +659,28 @@
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] additional_services: Additional Azure resource types that you want to sync with Observability Cloud.
-        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespacesPerServiceArgs']]]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-               `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-               so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-               addition to the default namespaces.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] environment: what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-               `"azure"`
-        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-               import only metadata. Defaults to true.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationResourceFilterRuleArgs']]]] resource_filter_rules: List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-               filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-               limited to tags and must start with the azure_tag_ prefix..
-        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-               Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        :param pulumi.Input[str] app_id: Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationCustomNamespacesPerServiceArgs']]]] custom_namespaces_per_services: Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] environment: What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
+        :param pulumi.Input[bool] import_azure_monitor: If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationResourceFilterRuleArgs']]]] resource_filter_rules: List of rules for filtering Azure resources by their tags.
+        :param pulumi.Input[str] secret_key: Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] subscriptions: List of Azure subscriptions that Splunk Observability Cloud should monitor.
-        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-               telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-               Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
-        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant.
+        :param pulumi.Input[bool] sync_guest_os_namespaces: If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
+        :param pulumi.Input[str] tenant_id: Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
         __props__.__dict__["additional_services"] = additional_services
         __props__.__dict__["app_id"] = app_id
@@ -819,103 +707,95 @@
         """
         return pulumi.get(self, "additional_services")
 
     @property
     @pulumi.getter(name="appId")
     def app_id(self) -> pulumi.Output[str]:
         """
-        Azure application ID for the Splunk Observability Cloud app.
+        Azure application ID for the Splunk Observability Cloud app. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "app_id")
 
     @property
     @pulumi.getter(name="customNamespacesPerServices")
     def custom_namespaces_per_services(self) -> pulumi.Output[Optional[Sequence['outputs.IntegrationCustomNamespacesPerService']]]:
         """
-        Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter
-        `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do
-        so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in
-        addition to the default namespaces.
+        Allows for more fine-grained control of syncing of custom namespaces, should the boolean convenience parameter `sync_guest_os_namespaces` be not enough. The customer may specify a map of services to custom namespaces. If they do so, for each service which is a key in this map, we will attempt to sync metrics from namespaces in the value list in addition to the default namespaces.
         """
         return pulumi.get(self, "custom_namespaces_per_services")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def environment(self) -> pulumi.Output[Optional[str]]:
         """
-        what type of Azure integration this is. The allowed values are `"azure_us_government"` and `"azure"`. Defaults to
-        `"azure"`
+        What type of Azure integration this is. The allowed values are `\\"azure_us_government\\"` and `\\"azure\\"`. Defaults to `\\"azure\\"`.
         """
         return pulumi.get(self, "environment")
 
     @property
     @pulumi.getter(name="importAzureMonitor")
     def import_azure_monitor(self) -> pulumi.Output[Optional[bool]]:
         """
-        If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will
-        import only metadata. Defaults to true.
+        If enabled, Splunk Observability Cloud will sync also Azure Monitor data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
         """
         return pulumi.get(self, "import_azure_monitor")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> pulumi.Output[Optional[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> pulumi.Output[Optional[int]]:
         """
-        Azure poll rate (in seconds). Between `60` and `600`.
+        Azure poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @property
     @pulumi.getter(name="resourceFilterRules")
     def resource_filter_rules(self) -> pulumi.Output[Optional[Sequence['outputs.IntegrationResourceFilterRule']]]:
         """
-        List of rules for filtering Azure resources by their tags. The source of each filter rule must be in the form
-        filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are
-        limited to tags and must start with the azure_tag_ prefix..
+        List of rules for filtering Azure resources by their tags.
         """
         return pulumi.get(self, "resource_filter_rules")
 
     @property
     @pulumi.getter(name="secretKey")
     def secret_key(self) -> pulumi.Output[str]:
         """
-        Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant.
+        Azure secret key that associates the Splunk Observability Cloud app in Azure with the Azure tenant ID. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "secret_key")
 
     @property
     @pulumi.getter
     def services(self) -> pulumi.Output[Sequence[str]]:
         """
-        List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Splunk
-        Observability Cloud only supports certain services, and if you specify an unsupported one, you receive an API error.
+        List of Microsoft Azure service names for the Azure services you want Splunk Observability Cloud to monitor. Can be an empty list to import data for all supported services. See [Microsoft Azure services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#azure-integrations) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @property
     @pulumi.getter
     def subscriptions(self) -> pulumi.Output[Sequence[str]]:
         """
@@ -923,21 +803,19 @@
         """
         return pulumi.get(self, "subscriptions")
 
     @property
     @pulumi.getter(name="syncGuestOsNamespaces")
     def sync_guest_os_namespaces(self) -> pulumi.Output[Optional[bool]]:
         """
-        If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets):
-        telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their
-        Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested.
+        If enabled, Splunk Observability Cloud will try to sync additional namespaces for VMs (including VMs in scale sets): telegraf/mem, telegraf/cpu, azure.vm.windows.guest (these are namespaces recommended by Azure when enabling their Diagnostic Extension). If there are no metrics there, no new datapoints will be ingested. Defaults to false.
         """
         return pulumi.get(self, "sync_guest_os_namespaces")
 
     @property
     @pulumi.getter(name="tenantId")
     def tenant_id(self) -> pulumi.Output[str]:
         """
-        Azure ID of the Azure tenant.
+        Azure ID of the Azure tenant. To learn how to get this ID, see the topic [Connect to Microsoft Azure](https://docs.splunk.com/observability/en/gdi/get-data-in/connect/azure/azure.html) in the product documentation.
         """
         return pulumi.get(self, "tenant_id")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/azure/outputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/azure/_inputs.py`

 * *Files 27% similar despite different names*

```diff
@@ -6,69 +6,70 @@
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
 from .. import _utilities
 
 __all__ = [
-    'IntegrationCustomNamespacesPerService',
-    'IntegrationResourceFilterRule',
+    'IntegrationCustomNamespacesPerServiceArgs',
+    'IntegrationResourceFilterRuleArgs',
 ]
 
-@pulumi.output_type
-class IntegrationCustomNamespacesPerService(dict):
+@pulumi.input_type
+class IntegrationCustomNamespacesPerServiceArgs:
     def __init__(__self__, *,
-                 namespaces: Sequence[str],
-                 service: str):
+                 namespaces: pulumi.Input[Sequence[pulumi.Input[str]]],
+                 service: pulumi.Input[str]):
         """
-        :param Sequence[str] namespaces: The namespaces to sync
-        :param str service: The name of the service
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] namespaces: The additional namespaces.
+        :param pulumi.Input[str] service: The name of the service.
         """
         pulumi.set(__self__, "namespaces", namespaces)
         pulumi.set(__self__, "service", service)
 
     @property
     @pulumi.getter
-    def namespaces(self) -> Sequence[str]:
+    def namespaces(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
         """
-        The namespaces to sync
+        The additional namespaces.
         """
         return pulumi.get(self, "namespaces")
 
+    @namespaces.setter
+    def namespaces(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
+        pulumi.set(self, "namespaces", value)
+
     @property
     @pulumi.getter
-    def service(self) -> str:
+    def service(self) -> pulumi.Input[str]:
         """
-        The name of the service
+        The name of the service.
         """
         return pulumi.get(self, "service")
 
+    @service.setter
+    def service(self, value: pulumi.Input[str]):
+        pulumi.set(self, "service", value)
 
-@pulumi.output_type
-class IntegrationResourceFilterRule(dict):
-    @staticmethod
-    def __key_warning(key: str):
-        suggest = None
-        if key == "filterSource":
-            suggest = "filter_source"
-
-        if suggest:
-            pulumi.log.warn(f"Key '{key}' not found in IntegrationResourceFilterRule. Access the value via the '{suggest}' property getter instead.")
-
-    def __getitem__(self, key: str) -> Any:
-        IntegrationResourceFilterRule.__key_warning(key)
-        return super().__getitem__(key)
-
-    def get(self, key: str, default = None) -> Any:
-        IntegrationResourceFilterRule.__key_warning(key)
-        return super().get(key, default)
 
+@pulumi.input_type
+class IntegrationResourceFilterRuleArgs:
     def __init__(__self__, *,
-                 filter_source: str):
+                 filter_source: pulumi.Input[str]):
+        """
+        :param pulumi.Input[str] filter_source: Expression that selects the data that Splunk Observability Cloud should sync for the resource associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function. The source of each filter rule must be in the form filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are limited to tags and must start with the azure_tag_ prefix.
+        """
         pulumi.set(__self__, "filter_source", filter_source)
 
     @property
     @pulumi.getter(name="filterSource")
-    def filter_source(self) -> str:
+    def filter_source(self) -> pulumi.Input[str]:
+        """
+        Expression that selects the data that Splunk Observability Cloud should sync for the resource associated with this sync rule. The expression uses the syntax defined for the SignalFlow `filter()` function. The source of each filter rule must be in the form filter('key', 'value'). You can join multiple filter statements using the and and or operators. Referenced keys are limited to tags and must start with the azure_tag_ prefix.
+        """
         return pulumi.get(self, "filter_source")
 
+    @filter_source.setter
+    def filter_source(self, value: pulumi.Input[str]):
+        pulumi.set(self, "filter_source", value)
+
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/config/__init__.pyi` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/config/__init__.pyi`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/config/vars.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/config/vars.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/dashboard_group.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/dashboard_group.py`

 * *Files 9% similar despite different names*

```diff
@@ -22,21 +22,21 @@
                  description: Optional[pulumi.Input[str]] = None,
                  import_qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierArgs']]]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  permissions: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]]] = None,
                  teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
         The set of arguments for constructing a DashboardGroup resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]] dashboards: Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
-        :param pulumi.Input[str] description: Description of the dashboard group
-        :param pulumi.Input[str] name: Name of the dashboard group
-        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]] permissions: The custom access control list for this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]] dashboards: [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[str] description: Description of the dashboard group.
+        :param pulumi.Input[str] name: Name of the dashboard group.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]] permissions: [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to.
         """
         if authorized_writer_teams is not None:
             warnings.warn("""Please use permissions field now""", DeprecationWarning)
             pulumi.log.warn("""authorized_writer_teams is deprecated: Please use permissions field now""")
         if authorized_writer_teams is not None:
             pulumi.set(__self__, "authorized_writer_teams", authorized_writer_teams)
         if authorized_writer_users is not None:
@@ -57,57 +57,57 @@
         if teams is not None:
             pulumi.set(__self__, "teams", teams)
 
     @property
     @pulumi.getter(name="authorizedWriterTeams")
     def authorized_writer_teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs that have write access to this dashboard
+        Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
         """
         warnings.warn("""Please use permissions field now""", DeprecationWarning)
         pulumi.log.warn("""authorized_writer_teams is deprecated: Please use permissions field now""")
 
         return pulumi.get(self, "authorized_writer_teams")
 
     @authorized_writer_teams.setter
     def authorized_writer_teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_teams", value)
 
     @property
     @pulumi.getter(name="authorizedWriterUsers")
     def authorized_writer_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        User IDs that have write access to this dashboard
+        User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
         """
         warnings.warn("""Please use permissions field now""", DeprecationWarning)
         pulumi.log.warn("""authorized_writer_users is deprecated: Please use permissions field now""")
 
         return pulumi.get(self, "authorized_writer_users")
 
     @authorized_writer_users.setter
     def authorized_writer_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_users", value)
 
     @property
     @pulumi.getter
     def dashboards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]]]:
         """
-        Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
+        [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
         """
         return pulumi.get(self, "dashboards")
 
     @dashboards.setter
     def dashboards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]]]):
         pulumi.set(self, "dashboards", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the dashboard group
+        Description of the dashboard group.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
@@ -120,39 +120,39 @@
     def import_qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierArgs']]]]):
         pulumi.set(self, "import_qualifiers", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the dashboard group
+        Name of the dashboard group.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]]]:
         """
-        The custom access control list for this dashboard
+        [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
         """
         return pulumi.get(self, "permissions")
 
     @permissions.setter
     def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]]]):
         pulumi.set(self, "permissions", value)
 
     @property
     @pulumi.getter
     def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs to associate the dashboard group to
+        Team IDs to associate the dashboard group to.
         """
         return pulumi.get(self, "teams")
 
     @teams.setter
     def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "teams", value)
 
@@ -166,21 +166,21 @@
                  description: Optional[pulumi.Input[str]] = None,
                  import_qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierArgs']]]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  permissions: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]]] = None,
                  teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
         Input properties used for looking up and filtering DashboardGroup resources.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]] dashboards: Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
-        :param pulumi.Input[str] description: Description of the dashboard group
-        :param pulumi.Input[str] name: Name of the dashboard group
-        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]] permissions: The custom access control list for this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]] dashboards: [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[str] description: Description of the dashboard group.
+        :param pulumi.Input[str] name: Name of the dashboard group.
+        :param pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]] permissions: [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to.
         """
         if authorized_writer_teams is not None:
             warnings.warn("""Please use permissions field now""", DeprecationWarning)
             pulumi.log.warn("""authorized_writer_teams is deprecated: Please use permissions field now""")
         if authorized_writer_teams is not None:
             pulumi.set(__self__, "authorized_writer_teams", authorized_writer_teams)
         if authorized_writer_users is not None:
@@ -201,57 +201,57 @@
         if teams is not None:
             pulumi.set(__self__, "teams", teams)
 
     @property
     @pulumi.getter(name="authorizedWriterTeams")
     def authorized_writer_teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs that have write access to this dashboard
+        Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
         """
         warnings.warn("""Please use permissions field now""", DeprecationWarning)
         pulumi.log.warn("""authorized_writer_teams is deprecated: Please use permissions field now""")
 
         return pulumi.get(self, "authorized_writer_teams")
 
     @authorized_writer_teams.setter
     def authorized_writer_teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_teams", value)
 
     @property
     @pulumi.getter(name="authorizedWriterUsers")
     def authorized_writer_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        User IDs that have write access to this dashboard
+        User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
         """
         warnings.warn("""Please use permissions field now""", DeprecationWarning)
         pulumi.log.warn("""authorized_writer_users is deprecated: Please use permissions field now""")
 
         return pulumi.get(self, "authorized_writer_users")
 
     @authorized_writer_users.setter
     def authorized_writer_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_users", value)
 
     @property
     @pulumi.getter
     def dashboards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]]]:
         """
-        Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
+        [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
         """
         return pulumi.get(self, "dashboards")
 
     @dashboards.setter
     def dashboards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupDashboardArgs']]]]):
         pulumi.set(self, "dashboards", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the dashboard group
+        Description of the dashboard group.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
@@ -264,39 +264,39 @@
     def import_qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupImportQualifierArgs']]]]):
         pulumi.set(self, "import_qualifiers", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the dashboard group
+        Name of the dashboard group.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def permissions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]]]:
         """
-        The custom access control list for this dashboard
+        [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
         """
         return pulumi.get(self, "permissions")
 
     @permissions.setter
     def permissions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardGroupPermissionArgs']]]]):
         pulumi.set(self, "permissions", value)
 
     @property
     @pulumi.getter
     def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs to associate the dashboard group to
+        Team IDs to associate the dashboard group to.
         """
         return pulumi.get(self, "teams")
 
     @teams.setter
     def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "teams", value)
 
@@ -324,56 +324,23 @@
 
         ## Example
 
         ## Example with permissions
 
         ## Example With mirrored dashboards
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the dashboard group.
-        * `description` - (Required) Description of the dashboard group.
-        * `teams` - (Optional) Team IDs to associate the dashboard group to.
-        * `authorized_writer_teams` - (Optional) Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
-        * `authorized_writer_users` - (Optional) User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
-        * `permissions` - (Optional) [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
-          * `principal_id` - (Required) ID of the user, team, or organization for which you're granting permissions.
-          * `principal_type` - (Required) Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
-          * `actions` - (Required) Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
-        * `dashboard` - (Optional) [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
-          * `dashboard_id` - (Required) The dashboard id to mirror
-          * `name_override` - (Optional) The name that will override the original dashboards's name.
-          * `description_override` - (Optional) The description that will override the original dashboards's description.
-          * `filter_override` - (Optional) The description that will override the original dashboards's description.
-            * `property` - (Required) The name of a dimension to filter against.
-            * `values` - (Required) A list of values to be used with the `property`, they will be combined via `OR`.
-            * `negated` - (Optional) If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
-          * `filter_override` - (Optional) The description that will override the original dashboards's description.
-            * `property` - (Required) A metric time series dimension or property name.
-            * `values` - (Optional) (Optional) List of of strings (which will be treated as an OR filter on the property).
-            * `values_suggested` - (Optional) A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-        * `dashboard.config_id` - The ID of the association between the dashboard group and the dashboard
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupDashboardArgs']]]] dashboards: Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
-        :param pulumi.Input[str] description: Description of the dashboard group
-        :param pulumi.Input[str] name: Name of the dashboard group
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupPermissionArgs']]]] permissions: The custom access control list for this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupDashboardArgs']]]] dashboards: [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[str] description: Description of the dashboard group.
+        :param pulumi.Input[str] name: Name of the dashboard group.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupPermissionArgs']]]] permissions: [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: Optional[DashboardGroupArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -386,47 +353,14 @@
 
         ## Example
 
         ## Example with permissions
 
         ## Example With mirrored dashboards
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the dashboard group.
-        * `description` - (Required) Description of the dashboard group.
-        * `teams` - (Optional) Team IDs to associate the dashboard group to.
-        * `authorized_writer_teams` - (Optional) Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
-        * `authorized_writer_users` - (Optional) User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
-        * `permissions` - (Optional) [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
-          * `principal_id` - (Required) ID of the user, team, or organization for which you're granting permissions.
-          * `principal_type` - (Required) Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
-          * `actions` - (Required) Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
-        * `dashboard` - (Optional) [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
-          * `dashboard_id` - (Required) The dashboard id to mirror
-          * `name_override` - (Optional) The name that will override the original dashboards's name.
-          * `description_override` - (Optional) The description that will override the original dashboards's description.
-          * `filter_override` - (Optional) The description that will override the original dashboards's description.
-            * `property` - (Required) The name of a dimension to filter against.
-            * `values` - (Required) A list of values to be used with the `property`, they will be combined via `OR`.
-            * `negated` - (Optional) If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
-          * `filter_override` - (Optional) The description that will override the original dashboards's description.
-            * `property` - (Required) A metric time series dimension or property name.
-            * `values` - (Optional) (Optional) List of of strings (which will be treated as an OR filter on the property).
-            * `values_suggested` - (Optional) A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-        * `dashboard.config_id` - The ID of the association between the dashboard group and the dashboard
-
         :param str resource_name: The name of the resource.
         :param DashboardGroupArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(DashboardGroupArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -484,21 +418,21 @@
         """
         Get an existing DashboardGroup resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupDashboardArgs']]]] dashboards: Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
-        :param pulumi.Input[str] description: Description of the dashboard group
-        :param pulumi.Input[str] name: Name of the dashboard group
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupPermissionArgs']]]] permissions: The custom access control list for this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupDashboardArgs']]]] dashboards: [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[str] description: Description of the dashboard group.
+        :param pulumi.Input[str] name: Name of the dashboard group.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DashboardGroupPermissionArgs']]]] permissions: [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the dashboard group to.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _DashboardGroupState.__new__(_DashboardGroupState)
 
         __props__.__dict__["authorized_writer_teams"] = authorized_writer_teams
         __props__.__dict__["authorized_writer_users"] = authorized_writer_users
@@ -510,70 +444,70 @@
         __props__.__dict__["teams"] = teams
         return DashboardGroup(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="authorizedWriterTeams")
     def authorized_writer_teams(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Team IDs that have write access to this dashboard
+        Team IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's team (or user id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
         """
         warnings.warn("""Please use permissions field now""", DeprecationWarning)
         pulumi.log.warn("""authorized_writer_teams is deprecated: Please use permissions field now""")
 
         return pulumi.get(self, "authorized_writer_teams")
 
     @property
     @pulumi.getter(name="authorizedWriterUsers")
     def authorized_writer_users(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        User IDs that have write access to this dashboard
+        User IDs that have write access to this dashboard group. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`). **Note:** Deprecated use `permissions` instead.
         """
         warnings.warn("""Please use permissions field now""", DeprecationWarning)
         pulumi.log.warn("""authorized_writer_users is deprecated: Please use permissions field now""")
 
         return pulumi.get(self, "authorized_writer_users")
 
     @property
     @pulumi.getter
     def dashboards(self) -> pulumi.Output[Optional[Sequence['outputs.DashboardGroupDashboard']]]:
         """
-        Dashboard IDs that are members of this dashboard group. Also handles 'mirrored' dashboards.
+        [Mirrored dashboards](https://docs.splunk.com/observability/en/data-visualization/dashboards/dashboard-share-clone-mirror.html#mirror-dashboard) in this dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
         """
         return pulumi.get(self, "dashboards")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the dashboard group
+        Description of the dashboard group.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="importQualifiers")
     def import_qualifiers(self) -> pulumi.Output[Optional[Sequence['outputs.DashboardGroupImportQualifier']]]:
         return pulumi.get(self, "import_qualifiers")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the dashboard group
+        Name of the dashboard group.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def permissions(self) -> pulumi.Output[Sequence['outputs.DashboardGroupPermission']]:
         """
-        The custom access control list for this dashboard
+        [Permissions](https://docs.splunk.com/Observability/infrastructure/terms-concepts/permissions.html) List of read and write permission configuration to specify which user, team, and organization can view and/or edit your dashboard group. **Note:** This feature is not present in all accounts. Please contact support if you are unsure.
         """
         return pulumi.get(self, "permissions")
 
     @property
     @pulumi.getter
     def teams(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Team IDs to associate the dashboard group to
+        Team IDs to associate the dashboard group to.
         """
         return pulumi.get(self, "teams")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/data_link.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/view.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,454 +3,560 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
+from .. import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['DataLinkArgs', 'DataLink']
+__all__ = ['ViewArgs', 'View']
 
 @pulumi.input_type
-class DataLinkArgs:
+class ViewArgs:
     def __init__(__self__, *,
-                 context_dashboard_id: Optional[pulumi.Input[str]] = None,
-                 property_name: Optional[pulumi.Input[str]] = None,
-                 property_value: Optional[pulumi.Input[str]] = None,
-                 target_external_urls: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]]] = None,
-                 target_signalfx_dashboards: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]]] = None,
-                 target_splunks: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]]] = None):
+                 program_text: pulumi.Input[str],
+                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]] = None,
+                 default_connection: Optional[pulumi.Input[str]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 end_time: Optional[pulumi.Input[int]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]] = None,
+                 start_time: Optional[pulumi.Input[int]] = None,
+                 time_range: Optional[pulumi.Input[int]] = None):
         """
-        The set of arguments for constructing a DataLink resource.
-        :param pulumi.Input[str] context_dashboard_id: The dashobard ID to which this data link will be applied
-        :param pulumi.Input[str] property_name: Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-               `property_name`.
-        :param pulumi.Input[str] property_value: Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-               `property_name`.
-        :param pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]] target_external_urls: Link to an external URL
-        :param pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]] target_signalfx_dashboards: Link to a Splunk Observability Cloud dashboard
-        :param pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]] target_splunks: Link to a Splunk instance
+        The set of arguments for constructing a View resource.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
+        :param pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]] columns: The column headers to show on the log view.
+        :param pulumi.Input[str] default_connection: The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log view.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log view.
+        :param pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]] sort_options: The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
-        if context_dashboard_id is not None:
-            pulumi.set(__self__, "context_dashboard_id", context_dashboard_id)
-        if property_name is not None:
-            pulumi.set(__self__, "property_name", property_name)
-        if property_value is not None:
-            pulumi.set(__self__, "property_value", property_value)
-        if target_external_urls is not None:
-            pulumi.set(__self__, "target_external_urls", target_external_urls)
-        if target_signalfx_dashboards is not None:
-            pulumi.set(__self__, "target_signalfx_dashboards", target_signalfx_dashboards)
-        if target_splunks is not None:
-            pulumi.set(__self__, "target_splunks", target_splunks)
+        pulumi.set(__self__, "program_text", program_text)
+        if columns is not None:
+            pulumi.set(__self__, "columns", columns)
+        if default_connection is not None:
+            pulumi.set(__self__, "default_connection", default_connection)
+        if description is not None:
+            pulumi.set(__self__, "description", description)
+        if end_time is not None:
+            pulumi.set(__self__, "end_time", end_time)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if sort_options is not None:
+            pulumi.set(__self__, "sort_options", sort_options)
+        if start_time is not None:
+            pulumi.set(__self__, "start_time", start_time)
+        if time_range is not None:
+            pulumi.set(__self__, "time_range", time_range)
 
     @property
-    @pulumi.getter(name="contextDashboardId")
-    def context_dashboard_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="programText")
+    def program_text(self) -> pulumi.Input[str]:
         """
-        The dashobard ID to which this data link will be applied
+        Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
         """
-        return pulumi.get(self, "context_dashboard_id")
+        return pulumi.get(self, "program_text")
 
-    @context_dashboard_id.setter
-    def context_dashboard_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "context_dashboard_id", value)
+    @program_text.setter
+    def program_text(self, value: pulumi.Input[str]):
+        pulumi.set(self, "program_text", value)
 
     @property
-    @pulumi.getter(name="propertyName")
-    def property_name(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]:
         """
-        Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-        `property_name`.
+        The column headers to show on the log view.
         """
-        return pulumi.get(self, "property_name")
+        return pulumi.get(self, "columns")
 
-    @property_name.setter
-    def property_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "property_name", value)
+    @columns.setter
+    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]):
+        pulumi.set(self, "columns", value)
 
     @property
-    @pulumi.getter(name="propertyValue")
-    def property_value(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="defaultConnection")
+    def default_connection(self) -> Optional[pulumi.Input[str]]:
         """
-        Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-        `property_name`.
+        The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
         """
-        return pulumi.get(self, "property_value")
+        return pulumi.get(self, "default_connection")
 
-    @property_value.setter
-    def property_value(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "property_value", value)
+    @default_connection.setter
+    def default_connection(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "default_connection", value)
 
     @property
-    @pulumi.getter(name="targetExternalUrls")
-    def target_external_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]]]:
+    @pulumi.getter
+    def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Link to an external URL
+        Description of the log view.
         """
-        return pulumi.get(self, "target_external_urls")
+        return pulumi.get(self, "description")
 
-    @target_external_urls.setter
-    def target_external_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]]]):
-        pulumi.set(self, "target_external_urls", value)
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
 
     @property
-    @pulumi.getter(name="targetSignalfxDashboards")
-    def target_signalfx_dashboards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]]]:
+    @pulumi.getter(name="endTime")
+    def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Link to a Splunk Observability Cloud dashboard
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
-        return pulumi.get(self, "target_signalfx_dashboards")
+        return pulumi.get(self, "end_time")
 
-    @target_signalfx_dashboards.setter
-    def target_signalfx_dashboards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]]]):
-        pulumi.set(self, "target_signalfx_dashboards", value)
+    @end_time.setter
+    def end_time(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "end_time", value)
 
     @property
-    @pulumi.getter(name="targetSplunks")
-    def target_splunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]]]:
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Link to a Splunk instance
+        Name of the log view.
         """
-        return pulumi.get(self, "target_splunks")
+        return pulumi.get(self, "name")
 
-    @target_splunks.setter
-    def target_splunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]]]):
-        pulumi.set(self, "target_splunks", value)
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
+
+    @property
+    @pulumi.getter(name="sortOptions")
+    def sort_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]:
+        """
+        The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
+        """
+        return pulumi.get(self, "sort_options")
+
+    @sort_options.setter
+    def sort_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]):
+        pulumi.set(self, "sort_options", value)
+
+    @property
+    @pulumi.getter(name="startTime")
+    def start_time(self) -> Optional[pulumi.Input[int]]:
+        """
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        """
+        return pulumi.get(self, "start_time")
+
+    @start_time.setter
+    def start_time(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "start_time", value)
+
+    @property
+    @pulumi.getter(name="timeRange")
+    def time_range(self) -> Optional[pulumi.Input[int]]:
+        """
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        """
+        return pulumi.get(self, "time_range")
+
+    @time_range.setter
+    def time_range(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "time_range", value)
 
 
 @pulumi.input_type
-class _DataLinkState:
+class _ViewState:
     def __init__(__self__, *,
-                 context_dashboard_id: Optional[pulumi.Input[str]] = None,
-                 property_name: Optional[pulumi.Input[str]] = None,
-                 property_value: Optional[pulumi.Input[str]] = None,
-                 target_external_urls: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]]] = None,
-                 target_signalfx_dashboards: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]]] = None,
-                 target_splunks: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]]] = None):
+                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]] = None,
+                 default_connection: Optional[pulumi.Input[str]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 end_time: Optional[pulumi.Input[int]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 program_text: Optional[pulumi.Input[str]] = None,
+                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]] = None,
+                 start_time: Optional[pulumi.Input[int]] = None,
+                 time_range: Optional[pulumi.Input[int]] = None,
+                 url: Optional[pulumi.Input[str]] = None):
         """
-        Input properties used for looking up and filtering DataLink resources.
-        :param pulumi.Input[str] context_dashboard_id: The dashobard ID to which this data link will be applied
-        :param pulumi.Input[str] property_name: Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-               `property_name`.
-        :param pulumi.Input[str] property_value: Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-               `property_name`.
-        :param pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]] target_external_urls: Link to an external URL
-        :param pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]] target_signalfx_dashboards: Link to a Splunk Observability Cloud dashboard
-        :param pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]] target_splunks: Link to a Splunk instance
+        Input properties used for looking up and filtering View resources.
+        :param pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]] columns: The column headers to show on the log view.
+        :param pulumi.Input[str] default_connection: The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log view.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log view.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
+        :param pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]] sort_options: The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] url: The URL of the log view.
         """
-        if context_dashboard_id is not None:
-            pulumi.set(__self__, "context_dashboard_id", context_dashboard_id)
-        if property_name is not None:
-            pulumi.set(__self__, "property_name", property_name)
-        if property_value is not None:
-            pulumi.set(__self__, "property_value", property_value)
-        if target_external_urls is not None:
-            pulumi.set(__self__, "target_external_urls", target_external_urls)
-        if target_signalfx_dashboards is not None:
-            pulumi.set(__self__, "target_signalfx_dashboards", target_signalfx_dashboards)
-        if target_splunks is not None:
-            pulumi.set(__self__, "target_splunks", target_splunks)
+        if columns is not None:
+            pulumi.set(__self__, "columns", columns)
+        if default_connection is not None:
+            pulumi.set(__self__, "default_connection", default_connection)
+        if description is not None:
+            pulumi.set(__self__, "description", description)
+        if end_time is not None:
+            pulumi.set(__self__, "end_time", end_time)
+        if name is not None:
+            pulumi.set(__self__, "name", name)
+        if program_text is not None:
+            pulumi.set(__self__, "program_text", program_text)
+        if sort_options is not None:
+            pulumi.set(__self__, "sort_options", sort_options)
+        if start_time is not None:
+            pulumi.set(__self__, "start_time", start_time)
+        if time_range is not None:
+            pulumi.set(__self__, "time_range", time_range)
+        if url is not None:
+            pulumi.set(__self__, "url", url)
 
     @property
-    @pulumi.getter(name="contextDashboardId")
-    def context_dashboard_id(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]:
         """
-        The dashobard ID to which this data link will be applied
+        The column headers to show on the log view.
         """
-        return pulumi.get(self, "context_dashboard_id")
+        return pulumi.get(self, "columns")
 
-    @context_dashboard_id.setter
-    def context_dashboard_id(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "context_dashboard_id", value)
+    @columns.setter
+    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]):
+        pulumi.set(self, "columns", value)
 
     @property
-    @pulumi.getter(name="propertyName")
-    def property_name(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="defaultConnection")
+    def default_connection(self) -> Optional[pulumi.Input[str]]:
         """
-        Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-        `property_name`.
+        The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
         """
-        return pulumi.get(self, "property_name")
+        return pulumi.get(self, "default_connection")
 
-    @property_name.setter
-    def property_name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "property_name", value)
+    @default_connection.setter
+    def default_connection(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "default_connection", value)
 
     @property
-    @pulumi.getter(name="propertyValue")
-    def property_value(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-        `property_name`.
+        Description of the log view.
         """
-        return pulumi.get(self, "property_value")
+        return pulumi.get(self, "description")
 
-    @property_value.setter
-    def property_value(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "property_value", value)
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
 
     @property
-    @pulumi.getter(name="targetExternalUrls")
-    def target_external_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]]]:
+    @pulumi.getter(name="endTime")
+    def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Link to an external URL
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
-        return pulumi.get(self, "target_external_urls")
+        return pulumi.get(self, "end_time")
 
-    @target_external_urls.setter
-    def target_external_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetExternalUrlArgs']]]]):
-        pulumi.set(self, "target_external_urls", value)
+    @end_time.setter
+    def end_time(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "end_time", value)
 
     @property
-    @pulumi.getter(name="targetSignalfxDashboards")
-    def target_signalfx_dashboards(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]]]:
+    @pulumi.getter
+    def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Link to a Splunk Observability Cloud dashboard
+        Name of the log view.
         """
-        return pulumi.get(self, "target_signalfx_dashboards")
+        return pulumi.get(self, "name")
 
-    @target_signalfx_dashboards.setter
-    def target_signalfx_dashboards(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSignalfxDashboardArgs']]]]):
-        pulumi.set(self, "target_signalfx_dashboards", value)
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
     @property
-    @pulumi.getter(name="targetSplunks")
-    def target_splunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]]]:
+    @pulumi.getter(name="programText")
+    def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Link to a Splunk instance
+        Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
         """
-        return pulumi.get(self, "target_splunks")
+        return pulumi.get(self, "program_text")
 
-    @target_splunks.setter
-    def target_splunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataLinkTargetSplunkArgs']]]]):
-        pulumi.set(self, "target_splunks", value)
+    @program_text.setter
+    def program_text(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "program_text", value)
 
+    @property
+    @pulumi.getter(name="sortOptions")
+    def sort_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]:
+        """
+        The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
+        """
+        return pulumi.get(self, "sort_options")
 
-class DataLink(pulumi.CustomResource):
-    @overload
-    def __init__(__self__,
-                 resource_name: str,
-                 opts: Optional[pulumi.ResourceOptions] = None,
-                 context_dashboard_id: Optional[pulumi.Input[str]] = None,
-                 property_name: Optional[pulumi.Input[str]] = None,
-                 property_value: Optional[pulumi.Input[str]] = None,
-                 target_external_urls: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetExternalUrlArgs']]]]] = None,
-                 target_signalfx_dashboards: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSignalfxDashboardArgs']]]]] = None,
-                 target_splunks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSplunkArgs']]]]] = None,
-                 __props__=None):
+    @sort_options.setter
+    def sort_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]):
+        pulumi.set(self, "sort_options", value)
+
+    @property
+    @pulumi.getter(name="startTime")
+    def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Manage Splunk Observability Cloud [Data Links](https://docs.signalfx.com/en/latest/managing/data-links.html).
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        """
+        return pulumi.get(self, "start_time")
 
-        ## Example
+    @start_time.setter
+    def start_time(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "start_time", value)
 
-        ## Arguments
+    @property
+    @pulumi.getter(name="timeRange")
+    def time_range(self) -> Optional[pulumi.Input[int]]:
+        """
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        """
+        return pulumi.get(self, "time_range")
 
-        The following arguments are supported in the resource block:
+    @time_range.setter
+    def time_range(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "time_range", value)
 
-        * `property_name` - (Optional) Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify `property_name`.
-        * `property_value` - (Optional) Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify `property_name`.
-        * `context_dashboard_id` - (Optional) If provided, scopes this data link to the supplied dashboard id. If omitted then the link will be global.
-        * `target_external_url` - (Optional) Link to an external URL
-          * `name` (Required) User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-          * `url`- (Required) URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
-          * `time_format` - (Optional) [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
-          * `minimum_time_window` - (Optional) The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
-          * `property_key_mapping` - Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
-        * `target_signalfx_dashboard` - (Optional) Link to a Splunk Observability Cloud dashboard
-          * `name` (Required) User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-          * `is_default` - (Optional) Flag that designates a target as the default for a data link object. `true` by default
-          * `dashboard_id` - (Required) SignalFx-assigned ID of the dashboard link target
-          * `dashboard_group_id` - (Required) SignalFx-assigned ID of the dashboard link target's dashboard group
-        * `target_splunk` - (Optional) Link to an external URL
-          * `name` (Required) User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-          * `property_key_mapping` - Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
+    @property
+    @pulumi.getter
+    def url(self) -> Optional[pulumi.Input[str]]:
+        """
+        The URL of the log view.
+        """
+        return pulumi.get(self, "url")
 
-        ## Attributes
+    @url.setter
+    def url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "url", value)
 
-        In a addition to all arguments above, the following attributes are exported:
 
-        * `id` - The ID of the link.
+class View(pulumi.CustomResource):
+    @overload
+    def __init__(__self__,
+                 resource_name: str,
+                 opts: Optional[pulumi.ResourceOptions] = None,
+                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]]] = None,
+                 default_connection: Optional[pulumi.Input[str]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 end_time: Optional[pulumi.Input[int]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 program_text: Optional[pulumi.Input[str]] = None,
+                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]]] = None,
+                 start_time: Optional[pulumi.Input[int]] = None,
+                 time_range: Optional[pulumi.Input[int]] = None,
+                 __props__=None):
+        """
+        You can add logs data to your Observability Cloud dashboards without turning your logs into metrics first.
+
+        A log view displays log lines in a table form in a dashboard and shows you in detail what is happening and why.
+
+        ## Example
 
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] context_dashboard_id: The dashobard ID to which this data link will be applied
-        :param pulumi.Input[str] property_name: Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-               `property_name`.
-        :param pulumi.Input[str] property_value: Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-               `property_name`.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetExternalUrlArgs']]]] target_external_urls: Link to an external URL
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSignalfxDashboardArgs']]]] target_signalfx_dashboards: Link to a Splunk Observability Cloud dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSplunkArgs']]]] target_splunks: Link to a Splunk instance
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]] columns: The column headers to show on the log view.
+        :param pulumi.Input[str] default_connection: The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log view.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log view.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]] sort_options: The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: Optional[DataLinkArgs] = None,
+                 args: ViewArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Manage Splunk Observability Cloud [Data Links](https://docs.signalfx.com/en/latest/managing/data-links.html).
-
-        ## Example
-
-        ## Arguments
+        You can add logs data to your Observability Cloud dashboards without turning your logs into metrics first.
 
-        The following arguments are supported in the resource block:
+        A log view displays log lines in a table form in a dashboard and shows you in detail what is happening and why.
 
-        * `property_name` - (Optional) Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify `property_name`.
-        * `property_value` - (Optional) Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify `property_name`.
-        * `context_dashboard_id` - (Optional) If provided, scopes this data link to the supplied dashboard id. If omitted then the link will be global.
-        * `target_external_url` - (Optional) Link to an external URL
-          * `name` (Required) User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-          * `url`- (Required) URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
-          * `time_format` - (Optional) [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
-          * `minimum_time_window` - (Optional) The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
-          * `property_key_mapping` - Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
-        * `target_signalfx_dashboard` - (Optional) Link to a Splunk Observability Cloud dashboard
-          * `name` (Required) User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-          * `is_default` - (Optional) Flag that designates a target as the default for a data link object. `true` by default
-          * `dashboard_id` - (Required) SignalFx-assigned ID of the dashboard link target
-          * `dashboard_group_id` - (Required) SignalFx-assigned ID of the dashboard link target's dashboard group
-        * `target_splunk` - (Optional) Link to an external URL
-          * `name` (Required) User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-          * `property_key_mapping` - Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the link.
+        ## Example
 
         :param str resource_name: The name of the resource.
-        :param DataLinkArgs args: The arguments to use to populate this resource's properties.
+        :param ViewArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(DataLinkArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(ViewArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 context_dashboard_id: Optional[pulumi.Input[str]] = None,
-                 property_name: Optional[pulumi.Input[str]] = None,
-                 property_value: Optional[pulumi.Input[str]] = None,
-                 target_external_urls: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetExternalUrlArgs']]]]] = None,
-                 target_signalfx_dashboards: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSignalfxDashboardArgs']]]]] = None,
-                 target_splunks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSplunkArgs']]]]] = None,
+                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]]] = None,
+                 default_connection: Optional[pulumi.Input[str]] = None,
+                 description: Optional[pulumi.Input[str]] = None,
+                 end_time: Optional[pulumi.Input[int]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 program_text: Optional[pulumi.Input[str]] = None,
+                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]]] = None,
+                 start_time: Optional[pulumi.Input[int]] = None,
+                 time_range: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = DataLinkArgs.__new__(DataLinkArgs)
+            __props__ = ViewArgs.__new__(ViewArgs)
 
-            __props__.__dict__["context_dashboard_id"] = context_dashboard_id
-            __props__.__dict__["property_name"] = property_name
-            __props__.__dict__["property_value"] = property_value
-            __props__.__dict__["target_external_urls"] = target_external_urls
-            __props__.__dict__["target_signalfx_dashboards"] = target_signalfx_dashboards
-            __props__.__dict__["target_splunks"] = target_splunks
-        super(DataLink, __self__).__init__(
-            'signalfx:index/dataLink:DataLink',
+            __props__.__dict__["columns"] = columns
+            __props__.__dict__["default_connection"] = default_connection
+            __props__.__dict__["description"] = description
+            __props__.__dict__["end_time"] = end_time
+            __props__.__dict__["name"] = name
+            if program_text is None and not opts.urn:
+                raise TypeError("Missing required property 'program_text'")
+            __props__.__dict__["program_text"] = program_text
+            __props__.__dict__["sort_options"] = sort_options
+            __props__.__dict__["start_time"] = start_time
+            __props__.__dict__["time_range"] = time_range
+            __props__.__dict__["url"] = None
+        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="signalfx:logs/view:View")])
+        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
+        super(View, __self__).__init__(
+            'signalfx:log/view:View',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            context_dashboard_id: Optional[pulumi.Input[str]] = None,
-            property_name: Optional[pulumi.Input[str]] = None,
-            property_value: Optional[pulumi.Input[str]] = None,
-            target_external_urls: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetExternalUrlArgs']]]]] = None,
-            target_signalfx_dashboards: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSignalfxDashboardArgs']]]]] = None,
-            target_splunks: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSplunkArgs']]]]] = None) -> 'DataLink':
+            columns: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]]] = None,
+            default_connection: Optional[pulumi.Input[str]] = None,
+            description: Optional[pulumi.Input[str]] = None,
+            end_time: Optional[pulumi.Input[int]] = None,
+            name: Optional[pulumi.Input[str]] = None,
+            program_text: Optional[pulumi.Input[str]] = None,
+            sort_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]]] = None,
+            start_time: Optional[pulumi.Input[int]] = None,
+            time_range: Optional[pulumi.Input[int]] = None,
+            url: Optional[pulumi.Input[str]] = None) -> 'View':
         """
-        Get an existing DataLink resource's state with the given name, id, and optional extra
+        Get an existing View resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] context_dashboard_id: The dashobard ID to which this data link will be applied
-        :param pulumi.Input[str] property_name: Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-               `property_name`.
-        :param pulumi.Input[str] property_value: Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-               `property_name`.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetExternalUrlArgs']]]] target_external_urls: Link to an external URL
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSignalfxDashboardArgs']]]] target_signalfx_dashboards: Link to a Splunk Observability Cloud dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DataLinkTargetSplunkArgs']]]] target_splunks: Link to a Splunk instance
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]] columns: The column headers to show on the log view.
+        :param pulumi.Input[str] default_connection: The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log view.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log view.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]] sort_options: The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] url: The URL of the log view.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _DataLinkState.__new__(_DataLinkState)
+        __props__ = _ViewState.__new__(_ViewState)
 
-        __props__.__dict__["context_dashboard_id"] = context_dashboard_id
-        __props__.__dict__["property_name"] = property_name
-        __props__.__dict__["property_value"] = property_value
-        __props__.__dict__["target_external_urls"] = target_external_urls
-        __props__.__dict__["target_signalfx_dashboards"] = target_signalfx_dashboards
-        __props__.__dict__["target_splunks"] = target_splunks
-        return DataLink(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["columns"] = columns
+        __props__.__dict__["default_connection"] = default_connection
+        __props__.__dict__["description"] = description
+        __props__.__dict__["end_time"] = end_time
+        __props__.__dict__["name"] = name
+        __props__.__dict__["program_text"] = program_text
+        __props__.__dict__["sort_options"] = sort_options
+        __props__.__dict__["start_time"] = start_time
+        __props__.__dict__["time_range"] = time_range
+        __props__.__dict__["url"] = url
+        return View(resource_name, opts=opts, __props__=__props__)
+
+    @property
+    @pulumi.getter
+    def columns(self) -> pulumi.Output[Optional[Sequence['outputs.ViewColumn']]]:
+        """
+        The column headers to show on the log view.
+        """
+        return pulumi.get(self, "columns")
+
+    @property
+    @pulumi.getter(name="defaultConnection")
+    def default_connection(self) -> pulumi.Output[Optional[str]]:
+        """
+        The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        """
+        return pulumi.get(self, "default_connection")
+
+    @property
+    @pulumi.getter
+    def description(self) -> pulumi.Output[Optional[str]]:
+        """
+        Description of the log view.
+        """
+        return pulumi.get(self, "description")
+
+    @property
+    @pulumi.getter(name="endTime")
+    def end_time(self) -> pulumi.Output[Optional[int]]:
+        """
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        """
+        return pulumi.get(self, "end_time")
 
     @property
-    @pulumi.getter(name="contextDashboardId")
-    def context_dashboard_id(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter
+    def name(self) -> pulumi.Output[str]:
         """
-        The dashobard ID to which this data link will be applied
+        Name of the log view.
         """
-        return pulumi.get(self, "context_dashboard_id")
+        return pulumi.get(self, "name")
 
     @property
-    @pulumi.getter(name="propertyName")
-    def property_name(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="programText")
+    def program_text(self) -> pulumi.Output[str]:
         """
-        Name (key) of the metadata that's the trigger of a data link. If you specify `property_value`, you must specify
-        `property_name`.
+        Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
         """
-        return pulumi.get(self, "property_name")
+        return pulumi.get(self, "program_text")
 
     @property
-    @pulumi.getter(name="propertyValue")
-    def property_value(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="sortOptions")
+    def sort_options(self) -> pulumi.Output[Optional[Sequence['outputs.ViewSortOption']]]:
         """
-        Value of the metadata that's the trigger of a data link. If you specify this property, you must also specify
-        `property_name`.
+        The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
         """
-        return pulumi.get(self, "property_value")
+        return pulumi.get(self, "sort_options")
 
     @property
-    @pulumi.getter(name="targetExternalUrls")
-    def target_external_urls(self) -> pulumi.Output[Optional[Sequence['outputs.DataLinkTargetExternalUrl']]]:
+    @pulumi.getter(name="startTime")
+    def start_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Link to an external URL
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
-        return pulumi.get(self, "target_external_urls")
+        return pulumi.get(self, "start_time")
 
     @property
-    @pulumi.getter(name="targetSignalfxDashboards")
-    def target_signalfx_dashboards(self) -> pulumi.Output[Optional[Sequence['outputs.DataLinkTargetSignalfxDashboard']]]:
+    @pulumi.getter(name="timeRange")
+    def time_range(self) -> pulumi.Output[Optional[int]]:
         """
-        Link to a Splunk Observability Cloud dashboard
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
-        return pulumi.get(self, "target_signalfx_dashboards")
+        return pulumi.get(self, "time_range")
 
     @property
-    @pulumi.getter(name="targetSplunks")
-    def target_splunks(self) -> pulumi.Output[Optional[Sequence['outputs.DataLinkTargetSplunk']]]:
+    @pulumi.getter
+    def url(self) -> pulumi.Output[str]:
         """
-        Link to a Splunk instance
+        The URL of the log view.
         """
-        return pulumi.get(self, "target_splunks")
+        return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/detector.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/detector.py`

 * *Files 7% similar despite different names*

```diff
@@ -32,34 +32,32 @@
                  tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  time_range: Optional[pulumi.Input[int]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]]] = None):
         """
         The set of arguments for constructing a Detector resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]] rules: Set of rules used for alerting
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[str] description: Description of the detector
-        :param pulumi.Input[bool] disable_sampling: (false by default) When false, samples a subset of the output MTS in the visualization.
-        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[int] max_delay: Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
-        :param pulumi.Input[int] min_delay: Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-               is 900 (15m)
-        :param pulumi.Input[str] name: Name of the detector
-        :param pulumi.Input[bool] show_data_markers: (true by default) When true, markers will be drawn for each datapoint within the visualization.
-        :param pulumi.Input[bool] show_event_lines: (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
-        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-               to 3600
+        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]] rules: Set of rules used for alerting.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
+        :param pulumi.Input[str] description: Description of the detector.
+        :param pulumi.Input[bool] disable_sampling: When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] max_delay: allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
+        :param pulumi.Input[int] min_delay: How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
+        :param pulumi.Input[str] name: Name of the detector.
+        :param pulumi.Input[bool] show_data_markers: When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
+        :param pulumi.Input[bool] show_event_lines: When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to.
+        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         pulumi.set(__self__, "program_text", program_text)
         pulumi.set(__self__, "rules", rules)
         if authorized_writer_teams is not None:
             pulumi.set(__self__, "authorized_writer_teams", authorized_writer_teams)
         if authorized_writer_users is not None:
             pulumi.set(__self__, "authorized_writer_users", authorized_writer_users)
@@ -92,197 +90,195 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter
     def rules(self) -> pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]]:
         """
-        Set of rules used for alerting
+        Set of rules used for alerting.
         """
         return pulumi.get(self, "rules")
 
     @rules.setter
     def rules(self, value: pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]]):
         pulumi.set(self, "rules", value)
 
     @property
     @pulumi.getter(name="authorizedWriterTeams")
     def authorized_writer_teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs that have write access to this dashboard
+        Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
         """
         return pulumi.get(self, "authorized_writer_teams")
 
     @authorized_writer_teams.setter
     def authorized_writer_teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_teams", value)
 
     @property
     @pulumi.getter(name="authorizedWriterUsers")
     def authorized_writer_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        User IDs that have write access to this dashboard
+        User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
         """
         return pulumi.get(self, "authorized_writer_users")
 
     @authorized_writer_users.setter
     def authorized_writer_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_users", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the detector
+        Description of the detector.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) When false, samples a subset of the output MTS in the visualization.
+        When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch. Used for visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
+        allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="minDelay")
     def min_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-        is 900 (15m)
+        How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
         """
         return pulumi.get(self, "min_delay")
 
     @min_delay.setter
     def min_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "min_delay", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the detector
+        Name of the detector.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="showDataMarkers")
     def show_data_markers(self) -> Optional[pulumi.Input[bool]]:
         """
-        (true by default) When true, markers will be drawn for each datapoint within the visualization.
+        When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
         """
         return pulumi.get(self, "show_data_markers")
 
     @show_data_markers.setter
     def show_data_markers(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_data_markers", value)
 
     @property
     @pulumi.getter(name="showEventLines")
     def show_event_lines(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
+        When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
         """
         return pulumi.get(self, "show_event_lines")
 
     @show_event_lines.setter
     def show_event_lines(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_event_lines", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch. Used for visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter
     def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Tags associated with the detector
+        Tags associated with the detector.
         """
         return pulumi.get(self, "tags")
 
     @tags.setter
     def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "tags", value)
 
     @property
     @pulumi.getter
     def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs to associate the detector to
+        Team IDs to associate the detector to.
         """
         return pulumi.get(self, "teams")
 
     @teams.setter
     def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "teams", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-        to 3600
+        Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
@@ -298,15 +294,15 @@
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -332,37 +328,34 @@
                  teams: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  time_range: Optional[pulumi.Input[int]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  url: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]]] = None):
         """
         Input properties used for looking up and filtering Detector resources.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[str] description: Description of the detector
-        :param pulumi.Input[bool] disable_sampling: (false by default) When false, samples a subset of the output MTS in the visualization.
-        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] label_resolutions: Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
-               should be triggered
-        :param pulumi.Input[int] max_delay: Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
-        :param pulumi.Input[int] min_delay: Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-               is 900 (15m)
-        :param pulumi.Input[str] name: Name of the detector
-        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]] rules: Set of rules used for alerting
-        :param pulumi.Input[bool] show_data_markers: (true by default) When true, markers will be drawn for each datapoint within the visualization.
-        :param pulumi.Input[bool] show_event_lines: (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
-        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-               to 3600
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
+        :param pulumi.Input[str] description: Description of the detector.
+        :param pulumi.Input[bool] disable_sampling: When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] label_resolutions: The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
+        :param pulumi.Input[int] max_delay: allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
+        :param pulumi.Input[int] min_delay: How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
+        :param pulumi.Input[str] name: Name of the detector.
+        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]] rules: Set of rules used for alerting.
+        :param pulumi.Input[bool] show_data_markers: When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
+        :param pulumi.Input[bool] show_event_lines: When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to.
+        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] url: URL of the detector
-        :param pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] url: The URL of the detector.
+        :param pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         if authorized_writer_teams is not None:
             pulumi.set(__self__, "authorized_writer_teams", authorized_writer_teams)
         if authorized_writer_users is not None:
             pulumi.set(__self__, "authorized_writer_users", authorized_writer_users)
         if description is not None:
             pulumi.set(__self__, "description", description)
@@ -401,210 +394,207 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="authorizedWriterTeams")
     def authorized_writer_teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs that have write access to this dashboard
+        Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
         """
         return pulumi.get(self, "authorized_writer_teams")
 
     @authorized_writer_teams.setter
     def authorized_writer_teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_teams", value)
 
     @property
     @pulumi.getter(name="authorizedWriterUsers")
     def authorized_writer_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        User IDs that have write access to this dashboard
+        User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
         """
         return pulumi.get(self, "authorized_writer_users")
 
     @authorized_writer_users.setter
     def authorized_writer_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "authorized_writer_users", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the detector
+        Description of the detector.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) When false, samples a subset of the output MTS in the visualization.
+        When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch. Used for visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter(name="labelResolutions")
     def label_resolutions(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]:
         """
-        Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
-        should be triggered
+        The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
         """
         return pulumi.get(self, "label_resolutions")
 
     @label_resolutions.setter
     def label_resolutions(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]):
         pulumi.set(self, "label_resolutions", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
+        allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="minDelay")
     def min_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-        is 900 (15m)
+        How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
         """
         return pulumi.get(self, "min_delay")
 
     @min_delay.setter
     def min_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "min_delay", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the detector
+        Name of the detector.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter
     def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]]]:
         """
-        Set of rules used for alerting
+        Set of rules used for alerting.
         """
         return pulumi.get(self, "rules")
 
     @rules.setter
     def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorRuleArgs']]]]):
         pulumi.set(self, "rules", value)
 
     @property
     @pulumi.getter(name="showDataMarkers")
     def show_data_markers(self) -> Optional[pulumi.Input[bool]]:
         """
-        (true by default) When true, markers will be drawn for each datapoint within the visualization.
+        When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
         """
         return pulumi.get(self, "show_data_markers")
 
     @show_data_markers.setter
     def show_data_markers(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_data_markers", value)
 
     @property
     @pulumi.getter(name="showEventLines")
     def show_event_lines(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
+        When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
         """
         return pulumi.get(self, "show_event_lines")
 
     @show_event_lines.setter
     def show_event_lines(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_event_lines", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch. Used for visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter
     def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Tags associated with the detector
+        Tags associated with the detector.
         """
         return pulumi.get(self, "tags")
 
     @tags.setter
     def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "tags", value)
 
     @property
     @pulumi.getter
     def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Team IDs to associate the detector to
+        Team IDs to associate the detector to.
         """
         return pulumi.get(self, "teams")
 
     @teams.setter
     def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "teams", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-        to 3600
+        Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
@@ -620,27 +610,27 @@
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the detector
+        The URL of the detector.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DetectorVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -716,95 +706,42 @@
 
         You need to include all the commas even if you only use a credential id.
 
         You can either configure a Webhook to use an existing integration's credential id:
 
         Or configure one inline:
 
-        ## Arguments
-
-        * `name` - (Required) Name of the detector.
-        * `program_text` - (Required) Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `description` - (Optional) Description of the detector.
-        * `authorized_writer_teams` - (Optional) Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
-        * `authorized_writer_users` - (Optional) User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints. See [Delayed Datapoints](https://docs.splunk.com/observability/en/data-visualization/charts/chart-builder.html#delayed-datapoints) for more info. Max value is `900` seconds (15 minutes). `Auto` (as little as possible) by default.
-        * `min_delay` - (Optional) How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
-        * `show_data_markers` - (Optional) When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
-        * `show_event_lines` - (Optional) When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
-        * `disable_sampling` - (Optional) When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
-        * `time_range` - (Optional) Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `tags` - (Optional) Tags associated with the detector.
-        * `teams` - (Optional) Team IDs to associate the detector to.
-        * `rule` - (Required) Set of rules used for alerting.
-            * `detect_label` - (Required) A detect label which matches a detect label within `program_text`.
-            * `severity` - (Required) The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
-            * `description` - (Optional) Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
-            * `disabled` - (Optional) When true, notifications and events will not be generated for the detect label. `false` by default.
-            * `notifications` - (Optional) List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
-            * `parameterized_body` - (Optional) Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
-            * `parameterized_subject` - (Optional) Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
-            * `runbook_url` - (Optional) URL of page to consult when an alert is triggered. This can be used with custom notification messages.
-            * `tip` - (Optional) Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-
-        **Notes**
-
-        Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
-
-        - `max_delay` allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
-        - `extrapolation` allows you to specify how to handle missing data. An extrapolation policy can be added to individual signals by updating the data block in your `program_text`.
-
-        See [Delayed Datapoints](https://docs.splunk.com/observability/en/data-visualization/charts/chart-builder.html#delayed-datapoints) for more info.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the detector.
-        * `label_resolutions` - The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
-        * `url` - The URL of the detector.
-
         ## Import
 
         Detectors can be imported using their string ID (recoverable from URL: `/#/detector/v2/abc123/edit`, e.g.
 
         ```sh
         $ pulumi import signalfx:index/detector:Detector application_delay abc123
         ```
 
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[str] description: Description of the detector
-        :param pulumi.Input[bool] disable_sampling: (false by default) When false, samples a subset of the output MTS in the visualization.
-        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[int] max_delay: Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
-        :param pulumi.Input[int] min_delay: Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-               is 900 (15m)
-        :param pulumi.Input[str] name: Name of the detector
-        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorRuleArgs']]]] rules: Set of rules used for alerting
-        :param pulumi.Input[bool] show_data_markers: (true by default) When true, markers will be drawn for each datapoint within the visualization.
-        :param pulumi.Input[bool] show_event_lines: (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
-        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-               to 3600
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
+        :param pulumi.Input[str] description: Description of the detector.
+        :param pulumi.Input[bool] disable_sampling: When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] max_delay: allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
+        :param pulumi.Input[int] min_delay: How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
+        :param pulumi.Input[str] name: Name of the detector.
+        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorRuleArgs']]]] rules: Set of rules used for alerting.
+        :param pulumi.Input[bool] show_data_markers: When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
+        :param pulumi.Input[bool] show_event_lines: When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to.
+        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: DetectorArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -855,65 +792,14 @@
 
         You need to include all the commas even if you only use a credential id.
 
         You can either configure a Webhook to use an existing integration's credential id:
 
         Or configure one inline:
 
-        ## Arguments
-
-        * `name` - (Required) Name of the detector.
-        * `program_text` - (Required) Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `description` - (Optional) Description of the detector.
-        * `authorized_writer_teams` - (Optional) Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
-        * `authorized_writer_users` - (Optional) User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints. See [Delayed Datapoints](https://docs.splunk.com/observability/en/data-visualization/charts/chart-builder.html#delayed-datapoints) for more info. Max value is `900` seconds (15 minutes). `Auto` (as little as possible) by default.
-        * `min_delay` - (Optional) How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
-        * `show_data_markers` - (Optional) When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
-        * `show_event_lines` - (Optional) When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
-        * `disable_sampling` - (Optional) When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
-        * `time_range` - (Optional) Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `tags` - (Optional) Tags associated with the detector.
-        * `teams` - (Optional) Team IDs to associate the detector to.
-        * `rule` - (Required) Set of rules used for alerting.
-            * `detect_label` - (Required) A detect label which matches a detect label within `program_text`.
-            * `severity` - (Required) The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
-            * `description` - (Optional) Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
-            * `disabled` - (Optional) When true, notifications and events will not be generated for the detect label. `false` by default.
-            * `notifications` - (Optional) List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
-            * `parameterized_body` - (Optional) Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
-            * `parameterized_subject` - (Optional) Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
-            * `runbook_url` - (Optional) URL of page to consult when an alert is triggered. This can be used with custom notification messages.
-            * `tip` - (Optional) Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-
-        **Notes**
-
-        Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
-
-        - `max_delay` allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
-        - `extrapolation` allows you to specify how to handle missing data. An extrapolation policy can be added to individual signals by updating the data block in your `program_text`.
-
-        See [Delayed Datapoints](https://docs.splunk.com/observability/en/data-visualization/charts/chart-builder.html#delayed-datapoints) for more info.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the detector.
-        * `label_resolutions` - The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
-        * `url` - The URL of the detector.
-
         ## Import
 
         Detectors can be imported using their string ID (recoverable from URL: `/#/detector/v2/abc123/edit`, e.g.
 
         ```sh
         $ pulumi import signalfx:index/detector:Detector application_delay abc123
         ```
@@ -1017,37 +903,34 @@
         """
         Get an existing Detector resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this dashboard
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this dashboard
-        :param pulumi.Input[str] description: Description of the detector
-        :param pulumi.Input[bool] disable_sampling: (false by default) When false, samples a subset of the output MTS in the visualization.
-        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] label_resolutions: Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
-               should be triggered
-        :param pulumi.Input[int] max_delay: Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
-        :param pulumi.Input[int] min_delay: Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-               is 900 (15m)
-        :param pulumi.Input[str] name: Name of the detector
-        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorRuleArgs']]]] rules: Set of rules used for alerting
-        :param pulumi.Input[bool] show_data_markers: (true by default) When true, markers will be drawn for each datapoint within the visualization.
-        :param pulumi.Input[bool] show_event_lines: (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
-        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-               to 3600
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_teams: Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] authorized_writer_users: User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
+        :param pulumi.Input[str] description: Description of the detector.
+        :param pulumi.Input[bool] disable_sampling: When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] label_resolutions: The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
+        :param pulumi.Input[int] max_delay: allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
+        :param pulumi.Input[int] min_delay: How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
+        :param pulumi.Input[str] name: Name of the detector.
+        :param pulumi.Input[str] program_text: Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorRuleArgs']]]] rules: Set of rules used for alerting.
+        :param pulumi.Input[bool] show_data_markers: When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
+        :param pulumi.Input[bool] show_event_lines: When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the detector.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] teams: Team IDs to associate the detector to.
+        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] url: URL of the detector
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] url: The URL of the detector.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['DetectorVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _DetectorState.__new__(_DetectorState)
 
         __props__.__dict__["authorized_writer_teams"] = authorized_writer_teams
         __props__.__dict__["authorized_writer_users"] = authorized_writer_users
@@ -1071,146 +954,143 @@
         __props__.__dict__["viz_options"] = viz_options
         return Detector(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="authorizedWriterTeams")
     def authorized_writer_teams(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Team IDs that have write access to this dashboard
+        Team IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's team id (or user id in `authorized_writer_users`).
         """
         return pulumi.get(self, "authorized_writer_teams")
 
     @property
     @pulumi.getter(name="authorizedWriterUsers")
     def authorized_writer_users(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        User IDs that have write access to this dashboard
+        User IDs that have write access to this detector. Remember to use an admin's token if using this feature and to include that admin's user id (or team id in `authorized_writer_teams`).
         """
         return pulumi.get(self, "authorized_writer_users")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the detector
+        Description of the detector.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) When false, samples a subset of the output MTS in the visualization.
+        When `false`, the visualization may sample the output timeseries rather than displaying them all. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch. Used for visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @property
     @pulumi.getter(name="labelResolutions")
     def label_resolutions(self) -> pulumi.Output[Mapping[str, int]]:
         """
-        Resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert
-        should be triggered
+        The resolutions of the detector alerts in milliseconds that indicate how often data is analyzed to determine if an alert should be triggered.
         """
         return pulumi.get(self, "label_resolutions")
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> pulumi.Output[Optional[int]]:
         """
-        Maximum time (in seconds) to wait for late datapoints. Max value is 900 (15m)
+        allows Splunk Observability Cloud to continue with computation if there is a lag in receiving data points.
         """
         return pulumi.get(self, "max_delay")
 
     @property
     @pulumi.getter(name="minDelay")
     def min_delay(self) -> pulumi.Output[Optional[int]]:
         """
-        Minimum time (in seconds) for the computation to wait even if the datapoints are arriving in a timely fashion. Max value
-        is 900 (15m)
+        How long (in seconds) to wait even if the datapoints are arriving in a timely fashion. Max value is 900 (15m).
         """
         return pulumi.get(self, "min_delay")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the detector
+        Name of the detector.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the detector. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the detector. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter
     def rules(self) -> pulumi.Output[Sequence['outputs.DetectorRule']]:
         """
-        Set of rules used for alerting
+        Set of rules used for alerting.
         """
         return pulumi.get(self, "rules")
 
     @property
     @pulumi.getter(name="showDataMarkers")
     def show_data_markers(self) -> pulumi.Output[Optional[bool]]:
         """
-        (true by default) When true, markers will be drawn for each datapoint within the visualization.
+        When `true`, markers will be drawn for each datapoint within the visualization. `true` by default.
         """
         return pulumi.get(self, "show_data_markers")
 
     @property
     @pulumi.getter(name="showEventLines")
     def show_event_lines(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) When true, vertical lines will be drawn for each triggered event within the visualization.
+        When `true`, the visualization will display a vertical line for each event trigger. `false` by default.
         """
         return pulumi.get(self, "show_event_lines")
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch. Used for visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @property
     @pulumi.getter
     def tags(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Tags associated with the detector
+        Tags associated with the detector.
         """
         return pulumi.get(self, "tags")
 
     @property
     @pulumi.getter
     def teams(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Team IDs to associate the detector to
+        Team IDs to associate the detector to.
         """
         return pulumi.get(self, "teams")
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`. Defaults
-        to 3600
+        Seconds to display in the visualization. This is a rolling range from the current time. Example: `3600` corresponds to `-1h` in web UI. `3600` by default.
         """
         return pulumi.get(self, "time_range")
 
     @property
     @pulumi.getter
     def timezone(self) -> pulumi.Output[Optional[str]]:
         """
@@ -1218,19 +1098,19 @@
         """
         return pulumi.get(self, "timezone")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the detector
+        The URL of the detector.
         """
         return pulumi.get(self, "url")
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> pulumi.Output[Optional[Sequence['outputs.DetectorVizOption']]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/event_feed_chart.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/event_feed_chart.py`

 * *Files 8% similar despite different names*

```diff
@@ -18,20 +18,20 @@
                  description: Optional[pulumi.Input[str]] = None,
                  end_time: Optional[pulumi.Input[int]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  start_time: Optional[pulumi.Input[int]] = None,
                  time_range: Optional[pulumi.Input[int]] = None):
         """
         The set of arguments for constructing a EventFeedChart resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the text note.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         pulumi.set(__self__, "program_text", program_text)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if end_time is not None:
             pulumi.set(__self__, "end_time", end_time)
         if name is not None:
@@ -41,75 +41,75 @@
         if time_range is not None:
             pulumi.set(__self__, "time_range", time_range)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the text note.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the text note.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
@@ -122,21 +122,21 @@
                  name: Optional[pulumi.Input[str]] = None,
                  program_text: Optional[pulumi.Input[str]] = None,
                  start_time: Optional[pulumi.Input[int]] = None,
                  time_range: Optional[pulumi.Input[int]] = None,
                  url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering EventFeedChart resources.
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the text note.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] url: The URL of the chart.
         """
         if description is not None:
             pulumi.set(__self__, "description", description)
         if end_time is not None:
             pulumi.set(__self__, "end_time", end_time)
         if name is not None:
             pulumi.set(__self__, "name", name)
@@ -149,87 +149,87 @@
         if url is not None:
             pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the text note.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the text note.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
@@ -247,70 +247,34 @@
                  time_range: Optional[pulumi.Input[int]] = None,
                  __props__=None):
         """
         Displays a listing of events as a widget in a dashboard.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the text note.
-        * `program_text` - (Required) Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `description` - (Optional) Description of the text note.
-        * `time_range` - (Optional) From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the text note.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: EventFeedChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Displays a listing of events as a widget in a dashboard.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the text note.
-        * `program_text` - (Required) Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `description` - (Optional) Description of the text note.
-        * `time_range` - (Optional) From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param EventFeedChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(EventFeedChartArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -366,21 +330,21 @@
         """
         Get an existing EventFeedChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the text note.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] url: The URL of the chart.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _EventFeedChartState.__new__(_EventFeedChartState)
 
         __props__.__dict__["description"] = description
         __props__.__dict__["end_time"] = end_time
@@ -391,59 +355,59 @@
         __props__.__dict__["url"] = url
         return EventFeedChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart (Optional)
+        Description of the text note.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the text note.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/_inputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/_inputs.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/integration.py`

 * *Files 7% similar despite different names*

```diff
@@ -24,28 +24,24 @@
                  named_token: Optional[pulumi.Input[str]] = None,
                  poll_rate: Optional[pulumi.Input[int]] = None,
                  project_service_keys: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]]] = None,
                  services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  use_metric_source_project_for_quota: Optional[pulumi.Input[bool]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that you want to monitor
-        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-               will import only metadata. Defaults to true.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: GCP poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]] project_service_keys: GCP project service keys
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP enabled services
-        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-               stored. For this to work the service account provided for the project needs to be provided with
-               serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-               settings are used.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
+        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]] project_service_keys: GCP projects to add.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
+        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         pulumi.set(__self__, "enabled", enabled)
         if custom_metric_type_domains is not None:
             pulumi.set(__self__, "custom_metric_type_domains", custom_metric_type_domains)
         if import_gcp_metrics is not None:
             pulumi.set(__self__, "import_gcp_metrics", import_gcp_metrics)
         if include_lists is not None:
@@ -63,127 +59,123 @@
         if use_metric_source_project_for_quota is not None:
             pulumi.set(__self__, "use_metric_source_project_for_quota", use_metric_source_project_for_quota)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="customMetricTypeDomains")
     def custom_metric_type_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of additional GCP service domain names that you want to monitor
+        List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
         """
         return pulumi.get(self, "custom_metric_type_domains")
 
     @custom_metric_type_domains.setter
     def custom_metric_type_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "custom_metric_type_domains", value)
 
     @property
     @pulumi.getter(name="importGcpMetrics")
     def import_gcp_metrics(self) -> Optional[pulumi.Input[bool]]:
         """
-        If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-        will import only metadata. Defaults to true.
+        If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
         """
         return pulumi.get(self, "import_gcp_metrics")
 
     @import_gcp_metrics.setter
     def import_gcp_metrics(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "import_gcp_metrics", value)
 
     @property
     @pulumi.getter(name="includeLists")
     def include_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
+        [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
         """
         return pulumi.get(self, "include_lists")
 
     @include_lists.setter
     def include_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "include_lists", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> Optional[pulumi.Input[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @named_token.setter
     def named_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "named_token", value)
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        GCP poll rate (in seconds). Between `60` and `600`.
+        GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @poll_rate.setter
     def poll_rate(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "poll_rate", value)
 
     @property
     @pulumi.getter(name="projectServiceKeys")
     def project_service_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]]]:
         """
-        GCP project service keys
+        GCP projects to add.
         """
         return pulumi.get(self, "project_service_keys")
 
     @project_service_keys.setter
     def project_service_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]]]):
         pulumi.set(self, "project_service_keys", value)
 
     @property
     @pulumi.getter
     def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        GCP enabled services
+        GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @services.setter
     def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "services", value)
 
     @property
     @pulumi.getter(name="useMetricSourceProjectForQuota")
     def use_metric_source_project_for_quota(self) -> Optional[pulumi.Input[bool]]:
         """
-        When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-        stored. For this to work the service account provided for the project needs to be provided with
-        serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-        settings are used.
+        When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         return pulumi.get(self, "use_metric_source_project_for_quota")
 
     @use_metric_source_project_for_quota.setter
     def use_metric_source_project_for_quota(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "use_metric_source_project_for_quota", value)
 
@@ -199,28 +191,24 @@
                  named_token: Optional[pulumi.Input[str]] = None,
                  poll_rate: Optional[pulumi.Input[int]] = None,
                  project_service_keys: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]]] = None,
                  services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  use_metric_source_project_for_quota: Optional[pulumi.Input[bool]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that you want to monitor
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-               will import only metadata. Defaults to true.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: GCP poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]] project_service_keys: GCP project service keys
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP enabled services
-        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-               stored. For this to work the service account provided for the project needs to be provided with
-               serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-               settings are used.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]] project_service_keys: GCP projects to add.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
+        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         if custom_metric_type_domains is not None:
             pulumi.set(__self__, "custom_metric_type_domains", custom_metric_type_domains)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
         if import_gcp_metrics is not None:
             pulumi.set(__self__, "import_gcp_metrics", import_gcp_metrics)
@@ -239,127 +227,123 @@
         if use_metric_source_project_for_quota is not None:
             pulumi.set(__self__, "use_metric_source_project_for_quota", use_metric_source_project_for_quota)
 
     @property
     @pulumi.getter(name="customMetricTypeDomains")
     def custom_metric_type_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of additional GCP service domain names that you want to monitor
+        List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
         """
         return pulumi.get(self, "custom_metric_type_domains")
 
     @custom_metric_type_domains.setter
     def custom_metric_type_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "custom_metric_type_domains", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="importGcpMetrics")
     def import_gcp_metrics(self) -> Optional[pulumi.Input[bool]]:
         """
-        If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-        will import only metadata. Defaults to true.
+        If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
         """
         return pulumi.get(self, "import_gcp_metrics")
 
     @import_gcp_metrics.setter
     def import_gcp_metrics(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "import_gcp_metrics", value)
 
     @property
     @pulumi.getter(name="includeLists")
     def include_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
+        [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
         """
         return pulumi.get(self, "include_lists")
 
     @include_lists.setter
     def include_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "include_lists", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> Optional[pulumi.Input[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @named_token.setter
     def named_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "named_token", value)
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> Optional[pulumi.Input[int]]:
         """
-        GCP poll rate (in seconds). Between `60` and `600`.
+        GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @poll_rate.setter
     def poll_rate(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "poll_rate", value)
 
     @property
     @pulumi.getter(name="projectServiceKeys")
     def project_service_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]]]:
         """
-        GCP project service keys
+        GCP projects to add.
         """
         return pulumi.get(self, "project_service_keys")
 
     @project_service_keys.setter
     def project_service_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IntegrationProjectServiceKeyArgs']]]]):
         pulumi.set(self, "project_service_keys", value)
 
     @property
     @pulumi.getter
     def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        GCP enabled services
+        GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @services.setter
     def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "services", value)
 
     @property
     @pulumi.getter(name="useMetricSourceProjectForQuota")
     def use_metric_source_project_for_quota(self) -> Optional[pulumi.Input[bool]]:
         """
-        When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-        stored. For this to work the service account provided for the project needs to be provided with
-        serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-        settings are used.
+        When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         return pulumi.get(self, "use_metric_source_project_for_quota")
 
     @use_metric_source_project_for_quota.setter
     def use_metric_source_project_for_quota(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "use_metric_source_project_for_quota", value)
 
@@ -383,82 +367,40 @@
         """
         Splunk Observability Cloud GCP Integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk  Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `custom_metric_type_domains` - (Optional) List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `import_gcp_metrics` - (Optional) If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
-        * `include_list` - (Optional) [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
-        * `name` - (Required) Name of the integration.
-        * `named_token` - (Optional) Name of the org token to be used for data ingestion. If not specified then default access token is used.
-        * `poll_rate` - (Optional) GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
-        * `project_service_keys` - (Required) GCP projects to add.
-        * `services` - (Optional) GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
-        * `use_metric_source_project_for_quota` - (Optional) When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
-
-        ## Attributes
-
-        In addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that you want to monitor
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-               will import only metadata. Defaults to true.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: GCP poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationProjectServiceKeyArgs']]]] project_service_keys: GCP project service keys
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP enabled services
-        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-               stored. For this to work the service account provided for the project needs to be provided with
-               serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-               settings are used.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationProjectServiceKeyArgs']]]] project_service_keys: GCP projects to add.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
+        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Splunk Observability Cloud GCP Integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk  Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `custom_metric_type_domains` - (Optional) List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `import_gcp_metrics` - (Optional) If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
-        * `include_list` - (Optional) [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
-        * `name` - (Required) Name of the integration.
-        * `named_token` - (Optional) Name of the org token to be used for data ingestion. If not specified then default access token is used.
-        * `poll_rate` - (Optional) GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
-        * `project_service_keys` - (Required) GCP projects to add.
-        * `services` - (Optional) GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
-        * `use_metric_source_project_for_quota` - (Optional) When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
-
-        ## Attributes
-
-        In addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -526,28 +468,24 @@
         """
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that you want to monitor
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-               will import only metadata. Defaults to true.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] named_token: A named token to use for ingest
-        :param pulumi.Input[int] poll_rate: GCP poll rate (in seconds). Between `60` and `600`.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationProjectServiceKeyArgs']]]] project_service_keys: GCP project service keys
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP enabled services
-        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-               stored. For this to work the service account provided for the project needs to be provided with
-               serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-               settings are used.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] custom_metric_type_domains: List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[bool] import_gcp_metrics: If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_lists: [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] named_token: Name of the org token to be used for data ingestion. If not specified then default access token is used.
+        :param pulumi.Input[int] poll_rate: GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['IntegrationProjectServiceKeyArgs']]]] project_service_keys: GCP projects to add.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] services: GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
+        :param pulumi.Input[bool] use_metric_source_project_for_quota: When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
         __props__.__dict__["custom_metric_type_domains"] = custom_metric_type_domains
         __props__.__dict__["enabled"] = enabled
@@ -561,87 +499,83 @@
         __props__.__dict__["use_metric_source_project_for_quota"] = use_metric_source_project_for_quota
         return Integration(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="customMetricTypeDomains")
     def custom_metric_type_domains(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of additional GCP service domain names that you want to monitor
+        List of additional GCP service domain names that Splunk Observability Cloud will monitor. See [Custom Metric Type Domains documentation](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/#Custom-metric-type-domains)
         """
         return pulumi.get(self, "custom_metric_type_domains")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="importGcpMetrics")
     def import_gcp_metrics(self) -> pulumi.Output[Optional[bool]]:
         """
-        If enabled, Splunk Observability Cloud will sync also Google Cloud Metrics data. If disabled, Splunk Observability Cloud
-        will import only metadata. Defaults to true.
+        If enabled, Splunk Observability Cloud will sync also Google Cloud Monitoring data. If disabled, Splunk Observability Cloud will import only metadata. Defaults to true.
         """
         return pulumi.get(self, "import_gcp_metrics")
 
     @property
     @pulumi.getter(name="includeLists")
     def include_lists(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of custom metadata keys that you want Observability Cloud to collect for Compute Engine instances.
+        [Compute Metadata Include List](https://dev.splunk.com/observability/docs/integrations/gcp_integration_overview/).
         """
         return pulumi.get(self, "include_lists")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="namedToken")
     def named_token(self) -> pulumi.Output[Optional[str]]:
         """
-        A named token to use for ingest
+        Name of the org token to be used for data ingestion. If not specified then default access token is used.
         """
         return pulumi.get(self, "named_token")
 
     @property
     @pulumi.getter(name="pollRate")
     def poll_rate(self) -> pulumi.Output[Optional[int]]:
         """
-        GCP poll rate (in seconds). Between `60` and `600`.
+        GCP integration poll rate (in seconds). Value between `60` and `600`. Default: `300`.
         """
         return pulumi.get(self, "poll_rate")
 
     @property
     @pulumi.getter(name="projectServiceKeys")
     def project_service_keys(self) -> pulumi.Output[Optional[Sequence['outputs.IntegrationProjectServiceKey']]]:
         """
-        GCP project service keys
+        GCP projects to add.
         """
         return pulumi.get(self, "project_service_keys")
 
     @property
     @pulumi.getter
     def services(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        GCP enabled services
+        GCP service metrics to import. Can be an empty list, or not included, to import 'All services'. See [Google Cloud Platform services](https://docs.splunk.com/Observability/gdi/get-data-in/integrations.html#google-cloud-platform-services) for a list of valid values.
         """
         return pulumi.get(self, "services")
 
     @property
     @pulumi.getter(name="useMetricSourceProjectForQuota")
     def use_metric_source_project_for_quota(self) -> pulumi.Output[Optional[bool]]:
         """
-        When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are
-        stored. For this to work the service account provided for the project needs to be provided with
-        serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota
-        settings are used.
+        When this value is set to true Observability Cloud will force usage of a quota from the project where metrics are stored. For this to work the service account provided for the project needs to be provided with serviceusage.services.use permission or Service Usage Consumer role in this project. When set to false default quota settings are used.
         """
         return pulumi.get(self, "use_metric_source_project_for_quota")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/gcp/outputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/gcp/outputs.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/get_dimension_values.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/get_dimension_values.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/heatmap_chart.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/heatmap_chart.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,28 +28,28 @@
                  name: Optional[pulumi.Input[str]] = None,
                  refresh_interval: Optional[pulumi.Input[int]] = None,
                  sort_by: Optional[pulumi.Input[str]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a HeatmapChart resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input['HeatmapChartColorRangeArgs'] color_range: Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
-        :param pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order)
-        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
+        :param pulumi.Input['HeatmapChartColorRangeArgs'] color_range: Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]] color_scales: One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order).
+        :param pulumi.Input[bool] hide_timestamp: Whether to show the timestamp in the chart. `false` by default.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap.
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         pulumi.set(__self__, "program_text", program_text)
         if color_range is not None:
             pulumi.set(__self__, "color_range", color_range)
         if color_scales is not None:
             pulumi.set(__self__, "color_scales", color_scales)
         if description is not None:
@@ -75,171 +75,171 @@
         if unit_prefix is not None:
             pulumi.set(__self__, "unit_prefix", unit_prefix)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="colorRange")
     def color_range(self) -> Optional[pulumi.Input['HeatmapChartColorRangeArgs']]:
         """
-        Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
+        Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_range")
 
     @color_range.setter
     def color_range(self, value: Optional[pulumi.Input['HeatmapChartColorRangeArgs']]):
         pulumi.set(self, "color_range", value)
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_scales")
 
     @color_scales.setter
     def color_scales(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]]]):
         pulumi.set(self, "color_scales", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="groupBies")
     def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Properties to group by in the heatmap (in nesting order)
+        Properties to group by in the heatmap (in nesting order).
         """
         return pulumi.get(self, "group_bies")
 
     @group_bies.setter
     def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "group_bies", value)
 
     @property
     @pulumi.getter(name="hideTimestamp")
     def hide_timestamp(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether to show the timestamp in the chart
+        Whether to show the timestamp in the chart. `false` by default.
         """
         return pulumi.get(self, "hide_timestamp")
 
     @hide_timestamp.setter
     def hide_timestamp(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "hide_timestamp", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="minimumResolution")
     def minimum_resolution(self) -> Optional[pulumi.Input[int]]:
         """
-        The minimum resolution (in seconds) to use for computing the underlying program
+        The minimum resolution (in seconds) to use for computing the underlying program.
         """
         return pulumi.get(self, "minimum_resolution")
 
     @minimum_resolution.setter
     def minimum_resolution(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "minimum_resolution", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        How often (in seconds) to refresh the values of the heatmap
+        How often (in seconds) to refresh the values of the heatmap.
         """
         return pulumi.get(self, "refresh_interval")
 
     @refresh_interval.setter
     def refresh_interval(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "refresh_interval", value)
 
     @property
     @pulumi.getter(name="sortBy")
     def sort_by(self) -> Optional[pulumi.Input[str]]:
         """
-        The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
+        The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
         """
         return pulumi.get(self, "sort_by")
 
     @sort_by.setter
     def sort_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "sort_by", value)
 
     @property
     @pulumi.getter
     def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
         """
         return pulumi.get(self, "timezone")
 
     @timezone.setter
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
@@ -260,29 +260,29 @@
                  refresh_interval: Optional[pulumi.Input[int]] = None,
                  sort_by: Optional[pulumi.Input[str]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering HeatmapChart resources.
-        :param pulumi.Input['HeatmapChartColorRangeArgs'] color_range: Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
-        :param pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order)
-        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input['HeatmapChartColorRangeArgs'] color_range: Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]] color_scales: One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order).
+        :param pulumi.Input[bool] hide_timestamp: Whether to show the timestamp in the chart. `false` by default.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap.
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
         """
         if color_range is not None:
             pulumi.set(__self__, "color_range", color_range)
         if color_scales is not None:
             pulumi.set(__self__, "color_scales", color_scales)
         if description is not None:
             pulumi.set(__self__, "description", description)
@@ -311,183 +311,183 @@
         if url is not None:
             pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter(name="colorRange")
     def color_range(self) -> Optional[pulumi.Input['HeatmapChartColorRangeArgs']]:
         """
-        Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
+        Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_range")
 
     @color_range.setter
     def color_range(self, value: Optional[pulumi.Input['HeatmapChartColorRangeArgs']]):
         pulumi.set(self, "color_range", value)
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_scales")
 
     @color_scales.setter
     def color_scales(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HeatmapChartColorScaleArgs']]]]):
         pulumi.set(self, "color_scales", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="groupBies")
     def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Properties to group by in the heatmap (in nesting order)
+        Properties to group by in the heatmap (in nesting order).
         """
         return pulumi.get(self, "group_bies")
 
     @group_bies.setter
     def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "group_bies", value)
 
     @property
     @pulumi.getter(name="hideTimestamp")
     def hide_timestamp(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether to show the timestamp in the chart
+        Whether to show the timestamp in the chart. `false` by default.
         """
         return pulumi.get(self, "hide_timestamp")
 
     @hide_timestamp.setter
     def hide_timestamp(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "hide_timestamp", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="minimumResolution")
     def minimum_resolution(self) -> Optional[pulumi.Input[int]]:
         """
-        The minimum resolution (in seconds) to use for computing the underlying program
+        The minimum resolution (in seconds) to use for computing the underlying program.
         """
         return pulumi.get(self, "minimum_resolution")
 
     @minimum_resolution.setter
     def minimum_resolution(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "minimum_resolution", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        How often (in seconds) to refresh the values of the heatmap
+        How often (in seconds) to refresh the values of the heatmap.
         """
         return pulumi.get(self, "refresh_interval")
 
     @refresh_interval.setter
     def refresh_interval(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "refresh_interval", value)
 
     @property
     @pulumi.getter(name="sortBy")
     def sort_by(self) -> Optional[pulumi.Input[str]]:
         """
-        The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
+        The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
         """
         return pulumi.get(self, "sort_by")
 
     @sort_by.setter
     def sort_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "sort_by", value)
 
     @property
     @pulumi.getter
     def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
         """
         return pulumi.get(self, "timezone")
 
     @timezone.setter
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
@@ -513,110 +513,42 @@
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
         This chart type shows the specified plot in a heat map fashion. This format is similar to the [Infrastructure Navigator](https://signalfx-product-docs.readthedocs-hosted.com/en/latest/built-in-content/infra-nav.html#infra), with squares representing each source for the selected metric, and the color of each square representing the value range of the metric.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
-        * `description` - (Optional) Description of the chart.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary`". `"Metric"` by default.
-        * `minimum_resolution` - (Optional) The minimum resolution (in seconds) to use for computing the underlying program.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints.
-        * `timezone` - (Optional) The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
-        * `refresh_interval` - (Optional) How often (in seconds) to refresh the values of the heatmap.
-        * `disable_sampling` - (Optional) If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
-        * `group_by` - (Optional) Properties to group by in the heatmap (in nesting order).
-        * `sort_by` - (Optional) The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
-        * `hide_timestamp` - (Optional) Whether to show the timestamp in the chart. `false` by default.
-        * `color_range` - (Optional, Default) Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
-            * `min_value` - (Optional) The minimum value within the coloring range.
-            * `max_value` - (Optional) The maximum value within the coloring range.
-            * `color` - (Required) The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
-        * `color_scale` - (Optional.  Conflicts with `color_range`) One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
-            * `gt` - (Optional) Indicates the lower threshold non-inclusive value for this range.
-            * `gte` - (Optional) Indicates the lower threshold inclusive value for this range.
-            * `lt` - (Optional) Indicates the upper threshold non-inclusive value for this range.
-            * `lte` - (Optional) Indicates the upper threshold inclusive value for this range.
-            * `color` - (Required) The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[pulumi.InputType['HeatmapChartColorRangeArgs']] color_range: Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['HeatmapChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order)
-        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
+        :param pulumi.Input[pulumi.InputType['HeatmapChartColorRangeArgs']] color_range: Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['HeatmapChartColorScaleArgs']]]] color_scales: One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order).
+        :param pulumi.Input[bool] hide_timestamp: Whether to show the timestamp in the chart. `false` by default.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap.
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: HeatmapChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         This chart type shows the specified plot in a heat map fashion. This format is similar to the [Infrastructure Navigator](https://signalfx-product-docs.readthedocs-hosted.com/en/latest/built-in-content/infra-nav.html#infra), with squares representing each source for the selected metric, and the color of each square representing the value range of the metric.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
-        * `description` - (Optional) Description of the chart.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary`". `"Metric"` by default.
-        * `minimum_resolution` - (Optional) The minimum resolution (in seconds) to use for computing the underlying program.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints.
-        * `timezone` - (Optional) The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
-        * `refresh_interval` - (Optional) How often (in seconds) to refresh the values of the heatmap.
-        * `disable_sampling` - (Optional) If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
-        * `group_by` - (Optional) Properties to group by in the heatmap (in nesting order).
-        * `sort_by` - (Optional) The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
-        * `hide_timestamp` - (Optional) Whether to show the timestamp in the chart. `false` by default.
-        * `color_range` - (Optional, Default) Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
-            * `min_value` - (Optional) The minimum value within the coloring range.
-            * `max_value` - (Optional) The maximum value within the coloring range.
-            * `color` - (Required) The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
-        * `color_scale` - (Optional.  Conflicts with `color_range`) One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
-            * `gt` - (Optional) Indicates the lower threshold non-inclusive value for this range.
-            * `gte` - (Optional) Indicates the lower threshold inclusive value for this range.
-            * `lt` - (Optional) Indicates the upper threshold non-inclusive value for this range.
-            * `lte` - (Optional) Indicates the upper threshold inclusive value for this range.
-            * `color` - (Required) The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param HeatmapChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(HeatmapChartArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -696,29 +628,29 @@
         """
         Get an existing HeatmapChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[pulumi.InputType['HeatmapChartColorRangeArgs']] color_range: Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['HeatmapChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order)
-        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[pulumi.InputType['HeatmapChartColorRangeArgs']] color_range: Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['HeatmapChartColorScaleArgs']]]] color_scales: One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Properties to group by in the heatmap (in nesting order).
+        :param pulumi.Input[bool] hide_timestamp: Whether to show the timestamp in the chart. `false` by default.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the heatmap.
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _HeatmapChartState.__new__(_HeatmapChartState)
 
         __props__.__dict__["color_range"] = color_range
         __props__.__dict__["color_scales"] = color_scales
@@ -737,123 +669,123 @@
         __props__.__dict__["url"] = url
         return HeatmapChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="colorRange")
     def color_range(self) -> pulumi.Output[Optional['outputs.HeatmapChartColorRange']]:
         """
-        Values and color for the color range. Example: colorRange : { min : 0, max : 100, color : "#0000ff" }
+        Values and color for the color range. Example: `color_range : { min : 0, max : 100, color : "#0000ff" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_range")
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> pulumi.Output[Optional[Sequence['outputs.HeatmapChartColorScale']]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        One to N blocks, each defining a single color range including both the color to display for that range and the borders of the range. Example: `color_scale { gt = 60, color = "blue" } color_scale { lte = 60, color = "yellow" }`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_scales")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @property
     @pulumi.getter(name="groupBies")
     def group_bies(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Properties to group by in the heatmap (in nesting order)
+        Properties to group by in the heatmap (in nesting order).
         """
         return pulumi.get(self, "group_bies")
 
     @property
     @pulumi.getter(name="hideTimestamp")
     def hide_timestamp(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) Whether to show the timestamp in the chart
+        Whether to show the timestamp in the chart. `false` by default.
         """
         return pulumi.get(self, "hide_timestamp")
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> pulumi.Output[Optional[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @property
     @pulumi.getter(name="minimumResolution")
     def minimum_resolution(self) -> pulumi.Output[Optional[int]]:
         """
-        The minimum resolution (in seconds) to use for computing the underlying program
+        The minimum resolution (in seconds) to use for computing the underlying program.
         """
         return pulumi.get(self, "minimum_resolution")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info at <https://dev.splunk.com/observability/docs/signalflow/>.
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> pulumi.Output[Optional[int]]:
         """
-        How often (in seconds) to refresh the values of the heatmap
+        How often (in seconds) to refresh the values of the heatmap.
         """
         return pulumi.get(self, "refresh_interval")
 
     @property
     @pulumi.getter(name="sortBy")
     def sort_by(self) -> pulumi.Output[Optional[str]]:
         """
-        The property to use when sorting the elements. Must be prepended with + for ascending or - for descending (e.g. -foo)
+        The property to use when sorting the elements. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`).
         """
         return pulumi.get(self, "sort_by")
 
     @property
     @pulumi.getter
     def timezone(self) -> pulumi.Output[Optional[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
         """
         return pulumi.get(self, "timezone")
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> pulumi.Output[Optional[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/jira/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/jira/integration.py`

 * *Files 13% similar despite different names*

```diff
@@ -24,25 +24,23 @@
                  assignee_display_name: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  password: Optional[pulumi.Input[str]] = None,
                  user_email: Optional[pulumi.Input[str]] = None,
                  username: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[str] assignee_name: Jira user name for the assignee
-        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        :param pulumi.Input[str] assignee_name: Jira user name for the assignee.
+        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         :param pulumi.Input[str] base_url: Base URL of the Jira instance that's integrated with SignalFx.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-               validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
-        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-               this project.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         :param pulumi.Input[str] api_token: The API token for the user email
-        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee.
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the Jira integration.
         :param pulumi.Input[str] user_email: Email address used to authenticate the Jira integration.
         :param pulumi.Input[str] username: User name used to authenticate the Jira integration.
         """
         pulumi.set(__self__, "assignee_name", assignee_name)
         pulumi.set(__self__, "auth_method", auth_method)
         pulumi.set(__self__, "base_url", base_url)
@@ -62,27 +60,27 @@
         if username is not None:
             pulumi.set(__self__, "username", username)
 
     @property
     @pulumi.getter(name="assigneeName")
     def assignee_name(self) -> pulumi.Input[str]:
         """
-        Jira user name for the assignee
+        Jira user name for the assignee.
         """
         return pulumi.get(self, "assignee_name")
 
     @assignee_name.setter
     def assignee_name(self, value: pulumi.Input[str]):
         pulumi.set(self, "assignee_name", value)
 
     @property
     @pulumi.getter(name="authMethod")
     def auth_method(self) -> pulumi.Input[str]:
         """
-        Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         """
         return pulumi.get(self, "auth_method")
 
     @auth_method.setter
     def auth_method(self, value: pulumi.Input[str]):
         pulumi.set(self, "auth_method", value)
 
@@ -98,41 +96,39 @@
     def base_url(self, value: pulumi.Input[str]):
         pulumi.set(self, "base_url", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="issueType")
     def issue_type(self) -> pulumi.Input[str]:
         """
-        Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-        validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
         """
         return pulumi.get(self, "issue_type")
 
     @issue_type.setter
     def issue_type(self, value: pulumi.Input[str]):
         pulumi.set(self, "issue_type", value)
 
     @property
     @pulumi.getter(name="projectKey")
     def project_key(self) -> pulumi.Input[str]:
         """
-        Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-        this project.
+        Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         """
         return pulumi.get(self, "project_key")
 
     @project_key.setter
     def project_key(self, value: pulumi.Input[str]):
         pulumi.set(self, "project_key", value)
 
@@ -148,27 +144,27 @@
     def api_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "api_token", value)
 
     @property
     @pulumi.getter(name="assigneeDisplayName")
     def assignee_display_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Jira display name for the assignee
+        Jira display name for the assignee.
         """
         return pulumi.get(self, "assignee_display_name")
 
     @assignee_display_name.setter
     def assignee_display_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "assignee_display_name", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -223,25 +219,23 @@
                  password: Optional[pulumi.Input[str]] = None,
                  project_key: Optional[pulumi.Input[str]] = None,
                  user_email: Optional[pulumi.Input[str]] = None,
                  username: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
         :param pulumi.Input[str] api_token: The API token for the user email
-        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee
-        :param pulumi.Input[str] assignee_name: Jira user name for the assignee
-        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee.
+        :param pulumi.Input[str] assignee_name: Jira user name for the assignee.
+        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         :param pulumi.Input[str] base_url: Base URL of the Jira instance that's integrated with SignalFx.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-               validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the Jira integration.
-        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-               this project.
+        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         :param pulumi.Input[str] user_email: Email address used to authenticate the Jira integration.
         :param pulumi.Input[str] username: User name used to authenticate the Jira integration.
         """
         if api_token is not None:
             pulumi.set(__self__, "api_token", api_token)
         if assignee_display_name is not None:
             pulumi.set(__self__, "assignee_display_name", assignee_display_name)
@@ -278,39 +272,39 @@
     def api_token(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "api_token", value)
 
     @property
     @pulumi.getter(name="assigneeDisplayName")
     def assignee_display_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Jira display name for the assignee
+        Jira display name for the assignee.
         """
         return pulumi.get(self, "assignee_display_name")
 
     @assignee_display_name.setter
     def assignee_display_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "assignee_display_name", value)
 
     @property
     @pulumi.getter(name="assigneeName")
     def assignee_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Jira user name for the assignee
+        Jira user name for the assignee.
         """
         return pulumi.get(self, "assignee_name")
 
     @assignee_name.setter
     def assignee_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "assignee_name", value)
 
     @property
     @pulumi.getter(name="authMethod")
     def auth_method(self) -> Optional[pulumi.Input[str]]:
         """
-        Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         """
         return pulumi.get(self, "auth_method")
 
     @auth_method.setter
     def auth_method(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "auth_method", value)
 
@@ -326,40 +320,39 @@
     def base_url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "base_url", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="issueType")
     def issue_type(self) -> Optional[pulumi.Input[str]]:
         """
-        Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-        validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
         """
         return pulumi.get(self, "issue_type")
 
     @issue_type.setter
     def issue_type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "issue_type", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -375,16 +368,15 @@
     def password(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "password", value)
 
     @property
     @pulumi.getter(name="projectKey")
     def project_key(self) -> Optional[pulumi.Input[str]]:
         """
-        Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-        this project.
+        Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         """
         return pulumi.get(self, "project_key")
 
     @project_key.setter
     def project_key(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "project_key", value)
 
@@ -434,49 +426,26 @@
         """
         Splunk Observability Cloud Jira integrations. For help with this integration see [Integration with Jira](https://docs.splunk.com/observability/en/admin/notif-services/jira.html).
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `auth_method` - (Required) Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
-        * `api_token` - (Required if `auth_method` is `EmailAndToken`) The API token for the user email
-        * `user_email` - (Required if `auth_method` is `EmailAndToken`) Email address used to authenticate the Jira integration.
-        * `username` - (Required if `auth_method` is `UsernameAndPassword`) User name used to authenticate the Jira integration.
-        * `password` - (Required if `auth_method` is `UsernameAndPassword`) Password used to authenticate the Jira integration.
-        * `base_url` - (Required) Base URL of the Jira instance that's integrated with SignalFx.
-        * `issue_type` - (Required) Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
-        * `project_key` - (Required) Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
-        * `assignee_name` - (Required) Jira user name for the assignee.
-        * `assignee_display_name` - (Optional) Jira display name for the assignee.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[str] api_token: The API token for the user email
-        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee
-        :param pulumi.Input[str] assignee_name: Jira user name for the assignee
-        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee.
+        :param pulumi.Input[str] assignee_name: Jira user name for the assignee.
+        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         :param pulumi.Input[str] base_url: Base URL of the Jira instance that's integrated with SignalFx.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-               validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the Jira integration.
-        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-               this project.
+        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         :param pulumi.Input[str] user_email: Email address used to authenticate the Jira integration.
         :param pulumi.Input[str] username: User name used to authenticate the Jira integration.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
@@ -485,35 +454,14 @@
         """
         Splunk Observability Cloud Jira integrations. For help with this integration see [Integration with Jira](https://docs.splunk.com/observability/en/admin/notif-services/jira.html).
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `auth_method` - (Required) Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
-        * `api_token` - (Required if `auth_method` is `EmailAndToken`) The API token for the user email
-        * `user_email` - (Required if `auth_method` is `EmailAndToken`) Email address used to authenticate the Jira integration.
-        * `username` - (Required if `auth_method` is `UsernameAndPassword`) User name used to authenticate the Jira integration.
-        * `password` - (Required if `auth_method` is `UsernameAndPassword`) Password used to authenticate the Jira integration.
-        * `base_url` - (Required) Base URL of the Jira instance that's integrated with SignalFx.
-        * `issue_type` - (Required) Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
-        * `project_key` - (Required) Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
-        * `assignee_name` - (Required) Jira user name for the assignee.
-        * `assignee_display_name` - (Optional) Jira display name for the assignee.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -598,25 +546,23 @@
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[str] api_token: The API token for the user email
-        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee
-        :param pulumi.Input[str] assignee_name: Jira user name for the assignee
-        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        :param pulumi.Input[str] assignee_display_name: Jira display name for the assignee.
+        :param pulumi.Input[str] assignee_name: Jira user name for the assignee.
+        :param pulumi.Input[str] auth_method: Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         :param pulumi.Input[str] base_url: Base URL of the Jira instance that's integrated with SignalFx.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-               validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] issue_type: Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the Jira integration.
-        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-               this project.
+        :param pulumi.Input[str] project_key: Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         :param pulumi.Input[str] user_email: Email address used to authenticate the Jira integration.
         :param pulumi.Input[str] username: User name used to authenticate the Jira integration.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
@@ -642,31 +588,31 @@
         """
         return pulumi.get(self, "api_token")
 
     @property
     @pulumi.getter(name="assigneeDisplayName")
     def assignee_display_name(self) -> pulumi.Output[Optional[str]]:
         """
-        Jira display name for the assignee
+        Jira display name for the assignee.
         """
         return pulumi.get(self, "assignee_display_name")
 
     @property
     @pulumi.getter(name="assigneeName")
     def assignee_name(self) -> pulumi.Output[str]:
         """
-        Jira user name for the assignee
+        Jira user name for the assignee.
         """
         return pulumi.get(self, "assignee_name")
 
     @property
     @pulumi.getter(name="authMethod")
     def auth_method(self) -> pulumi.Output[str]:
         """
-        Authentication method used when creating the Jira integration. One of `EmailAndToken` or `UsernameAndPassword`
+        Authentication method used when creating the Jira integration. One of `EmailAndToken` (using `user_email` and `api_token`) or `UsernameAndPassword` (using `username` and `password`).
         """
         return pulumi.get(self, "auth_method")
 
     @property
     @pulumi.getter(name="baseUrl")
     def base_url(self) -> pulumi.Output[str]:
         """
@@ -674,32 +620,31 @@
         """
         return pulumi.get(self, "base_url")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="issueType")
     def issue_type(self) -> pulumi.Output[str]:
         """
-        Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud
-        validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
+        Issue type (for example, Story) for tickets that Jira creates for detector notifications. Splunk Observability Cloud validates issue types, so you must specify a type that's valid for the Jira project specified in `projectKey`.
         """
         return pulumi.get(self, "issue_type")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def password(self) -> pulumi.Output[Optional[str]]:
         """
@@ -707,16 +652,15 @@
         """
         return pulumi.get(self, "password")
 
     @property
     @pulumi.getter(name="projectKey")
     def project_key(self) -> pulumi.Output[str]:
         """
-        Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to
-        this project.
+        Jira key of an existing project. When Jira creates a new ticket for a detector notification, the ticket is assigned to this project.
         """
         return pulumi.get(self, "project_key")
 
     @property
     @pulumi.getter(name="userEmail")
     def user_email(self) -> pulumi.Output[Optional[str]]:
         """
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/list_chart.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/list_chart.py`

 * *Files 5% similar despite different names*

```diff
@@ -34,35 +34,34 @@
                  start_time: Optional[pulumi.Input[int]] = None,
                  time_range: Optional[pulumi.Input[int]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]]] = None):
         """
         The set of arguments for constructing a ListChart resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Scale", "Metric" or "Dimension"
-        :param pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[bool] hide_missing_values: (false by default) If `true`, missing data points in the chart would be hidden
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-               ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
+        :param pulumi.Input[str] color_by: Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[bool] hide_missing_values: Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         pulumi.set(__self__, "program_text", program_text)
         if color_by is not None:
             pulumi.set(__self__, "color_by", color_by)
         if color_scales is not None:
             pulumi.set(__self__, "color_scales", color_scales)
         if description is not None:
@@ -103,247 +102,246 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Scale", "Metric" or "Dimension"
+        Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @color_by.setter
     def color_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_by", value)
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_scales")
 
     @color_scales.setter
     def color_scales(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]]]):
         pulumi.set(self, "color_scales", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter(name="hideMissingValues")
     def hide_missing_values(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If `true`, missing data points in the chart would be hidden
+        Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
         """
         return pulumi.get(self, "hide_missing_values")
 
     @hide_missing_values.setter
     def hide_missing_values(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "hide_missing_values", value)
 
     @property
     @pulumi.getter(name="legendFieldsToHides")
     def legend_fields_to_hides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
+        List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
         """
         warnings.warn("""Please use legend_options_fields""", DeprecationWarning)
         pulumi.log.warn("""legend_fields_to_hides is deprecated: Please use legend_options_fields""")
 
         return pulumi.get(self, "legend_fields_to_hides")
 
     @legend_fields_to_hides.setter
     def legend_fields_to_hides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "legend_fields_to_hides", value)
 
     @property
     @pulumi.getter(name="legendOptionsFields")
     def legend_options_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]]]:
         """
-        List of property and enabled flags to control the order and presence of datatable labels in a chart.
+        List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
         """
         return pulumi.get(self, "legend_options_fields")
 
     @legend_options_fields.setter
     def legend_options_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]]]):
         pulumi.set(self, "legend_options_fields", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="maxPrecision")
     def max_precision(self) -> Optional[pulumi.Input[int]]:
         """
-        Maximum number of digits to display when rounding values up or down
+        Maximum number of digits to display when rounding values up or down.
         """
         return pulumi.get(self, "max_precision")
 
     @max_precision.setter
     def max_precision(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_precision", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        How often (in seconds) to refresh the values of the list
+        How often (in seconds) to refresh the values of the list.
         """
         return pulumi.get(self, "refresh_interval")
 
     @refresh_interval.setter
     def refresh_interval(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "refresh_interval", value)
 
     @property
     @pulumi.getter(name="secondaryVisualization")
     def secondary_visualization(self) -> Optional[pulumi.Input[str]]:
         """
-        (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
+        The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
         """
         return pulumi.get(self, "secondary_visualization")
 
     @secondary_visualization.setter
     def secondary_visualization(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "secondary_visualization", value)
 
     @property
     @pulumi.getter(name="sortBy")
     def sort_by(self) -> Optional[pulumi.Input[str]]:
         """
-        The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-        ascending or - for descending (e.g. -foo)
+        The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
         """
         return pulumi.get(self, "sort_by")
 
     @sort_by.setter
     def sort_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "sort_by", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
     @property
     @pulumi.getter
     def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
         """
         return pulumi.get(self, "timezone")
 
     @timezone.setter
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -370,36 +368,35 @@
                  time_range: Optional[pulumi.Input[int]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  url: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]]] = None):
         """
         Input properties used for looking up and filtering ListChart resources.
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Scale", "Metric" or "Dimension"
-        :param pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[bool] hide_missing_values: (false by default) If `true`, missing data points in the chart would be hidden
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-               ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
-        :param pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] color_by: Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[bool] hide_missing_values: Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         if color_by is not None:
             pulumi.set(__self__, "color_by", color_by)
         if color_scales is not None:
             pulumi.set(__self__, "color_scales", color_scales)
         if description is not None:
             pulumi.set(__self__, "description", description)
@@ -443,259 +440,258 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Scale", "Metric" or "Dimension"
+        Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @color_by.setter
     def color_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_by", value)
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_scales")
 
     @color_scales.setter
     def color_scales(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartColorScaleArgs']]]]):
         pulumi.set(self, "color_scales", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter(name="hideMissingValues")
     def hide_missing_values(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If `true`, missing data points in the chart would be hidden
+        Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
         """
         return pulumi.get(self, "hide_missing_values")
 
     @hide_missing_values.setter
     def hide_missing_values(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "hide_missing_values", value)
 
     @property
     @pulumi.getter(name="legendFieldsToHides")
     def legend_fields_to_hides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
+        List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
         """
         warnings.warn("""Please use legend_options_fields""", DeprecationWarning)
         pulumi.log.warn("""legend_fields_to_hides is deprecated: Please use legend_options_fields""")
 
         return pulumi.get(self, "legend_fields_to_hides")
 
     @legend_fields_to_hides.setter
     def legend_fields_to_hides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "legend_fields_to_hides", value)
 
     @property
     @pulumi.getter(name="legendOptionsFields")
     def legend_options_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]]]:
         """
-        List of property and enabled flags to control the order and presence of datatable labels in a chart.
+        List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
         """
         return pulumi.get(self, "legend_options_fields")
 
     @legend_options_fields.setter
     def legend_options_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartLegendOptionsFieldArgs']]]]):
         pulumi.set(self, "legend_options_fields", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="maxPrecision")
     def max_precision(self) -> Optional[pulumi.Input[int]]:
         """
-        Maximum number of digits to display when rounding values up or down
+        Maximum number of digits to display when rounding values up or down.
         """
         return pulumi.get(self, "max_precision")
 
     @max_precision.setter
     def max_precision(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_precision", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        How often (in seconds) to refresh the values of the list
+        How often (in seconds) to refresh the values of the list.
         """
         return pulumi.get(self, "refresh_interval")
 
     @refresh_interval.setter
     def refresh_interval(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "refresh_interval", value)
 
     @property
     @pulumi.getter(name="secondaryVisualization")
     def secondary_visualization(self) -> Optional[pulumi.Input[str]]:
         """
-        (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
+        The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
         """
         return pulumi.get(self, "secondary_visualization")
 
     @secondary_visualization.setter
     def secondary_visualization(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "secondary_visualization", value)
 
     @property
     @pulumi.getter(name="sortBy")
     def sort_by(self) -> Optional[pulumi.Input[str]]:
         """
-        The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-        ascending or - for descending (e.g. -foo)
+        The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
         """
         return pulumi.get(self, "sort_by")
 
     @sort_by.setter
     def sort_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "sort_by", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
     @property
     @pulumi.getter
     def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
         """
         return pulumi.get(self, "timezone")
 
     @timezone.setter
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ListChartVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -729,139 +725,50 @@
         """
         This chart type displays current data values in a list format.
 
         The name of each value in the chart reflects the name of the plot and any associated dimensions. We recommend you click the Pencil icon and give the plot a meaningful name, as in plot B from the example. Otherwise, just the raw metric name will be displayed on the chart, as in plot A from the example.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
-        * `description` - (Optional) Description of the chart.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary`". `"Metric"` by default.
-        * `color_by` - (Optional) Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints.
-        * `timezone` - (Optional) The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
-        * `disable_sampling` - (Optional) If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
-        * `refresh_interval` - (Optional) How often (in seconds) to refresh the values of the list.
-        * `hide_missing_values` - (Optional) Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-        * `legend_fields_to_hide` - (Optional) List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
-        * `legend_options_fields` - (Optional) List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
-            * `property` The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
-            * `enabled` True or False depending on if you want the property to be shown or hidden.
-        * `max_precision` - (Optional) Maximum number of digits to display when rounding values up or down.
-        * `secondary_visualization` - (Optional) The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
-        * `color_scale` - (Optional. `color_by` must be `"Scale"`) Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
-            * `gt` - (Optional) Indicates the lower threshold non-inclusive value for this range.
-            * `gte` - (Optional) Indicates the lower threshold inclusive value for this range.
-            * `lt` - (Optional) Indicates the upper threshold non-inculsive value for this range.
-            * `lte` - (Optional) Indicates the upper threshold inclusive value for this range.
-            * `color` - (Required) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        * `sort_by` - (Optional) The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
-        * `time_range` - (Optional) How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Scale", "Metric" or "Dimension"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[bool] hide_missing_values: (false by default) If `true`, missing data points in the chart would be hidden
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-               ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] color_by: Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[bool] hide_missing_values: Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: ListChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         This chart type displays current data values in a list format.
 
         The name of each value in the chart reflects the name of the plot and any associated dimensions. We recommend you click the Pencil icon and give the plot a meaningful name, as in plot B from the example. Otherwise, just the raw metric name will be displayed on the chart, as in plot A from the example.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
-        * `description` - (Optional) Description of the chart.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary`". `"Metric"` by default.
-        * `color_by` - (Optional) Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints.
-        * `timezone` - (Optional) The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
-        * `disable_sampling` - (Optional) If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
-        * `refresh_interval` - (Optional) How often (in seconds) to refresh the values of the list.
-        * `hide_missing_values` - (Optional) Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-        * `legend_fields_to_hide` - (Optional) List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
-        * `legend_options_fields` - (Optional) List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
-            * `property` The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
-            * `enabled` True or False depending on if you want the property to be shown or hidden.
-        * `max_precision` - (Optional) Maximum number of digits to display when rounding values up or down.
-        * `secondary_visualization` - (Optional) The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
-        * `color_scale` - (Optional. `color_by` must be `"Scale"`) Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
-            * `gt` - (Optional) Indicates the lower threshold non-inclusive value for this range.
-            * `gte` - (Optional) Indicates the lower threshold inclusive value for this range.
-            * `lt` - (Optional) Indicates the upper threshold non-inculsive value for this range.
-            * `lte` - (Optional) Indicates the upper threshold inclusive value for this range.
-            * `color` - (Required) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        * `sort_by` - (Optional) The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
-        * `time_range` - (Optional) How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param ListChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(ListChartArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -959,36 +866,35 @@
         """
         Get an existing ListChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Scale", "Metric" or "Dimension"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[bool] hide_missing_values: (false by default) If `true`, missing data points in the chart would be hidden
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-               ascending or - for descending (e.g. -foo)
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] color_by: Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[bool] hide_missing_values: Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] max_precision: Maximum number of digits to display when rounding values up or down.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
+        :param pulumi.Input[str] sort_by: The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ListChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _ListChartState.__new__(_ListChartState)
 
         __props__.__dict__["color_by"] = color_by
         __props__.__dict__["color_scales"] = color_scales
@@ -1013,175 +919,174 @@
         __props__.__dict__["viz_options"] = viz_options
         return ListChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> pulumi.Output[Optional[str]]:
         """
-        (Metric by default) Must be "Scale", "Metric" or "Dimension"
+        Must be one of `"Scale"`, `"Dimension"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> pulumi.Output[Optional[Sequence['outputs.ListChartColorScale']]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.splunk.com/observability/en/data-visualization/charts/chart-options.html).
         """
         return pulumi.get(self, "color_scales")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default.
         """
         return pulumi.get(self, "disable_sampling")
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @property
     @pulumi.getter(name="hideMissingValues")
     def hide_missing_values(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) If `true`, missing data points in the chart would be hidden
+        Determines whether to hide missing data points in the chart. If `true`, missing data points in the chart would be hidden. `false` by default.
         """
         return pulumi.get(self, "hide_missing_values")
 
     @property
     @pulumi.getter(name="legendFieldsToHides")
     def legend_fields_to_hides(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
+        List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
         """
         warnings.warn("""Please use legend_options_fields""", DeprecationWarning)
         pulumi.log.warn("""legend_fields_to_hides is deprecated: Please use legend_options_fields""")
 
         return pulumi.get(self, "legend_fields_to_hides")
 
     @property
     @pulumi.getter(name="legendOptionsFields")
     def legend_options_fields(self) -> pulumi.Output[Optional[Sequence['outputs.ListChartLegendOptionsField']]]:
         """
-        List of property and enabled flags to control the order and presence of datatable labels in a chart.
+        List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
         """
         return pulumi.get(self, "legend_options_fields")
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> pulumi.Output[Optional[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @property
     @pulumi.getter(name="maxPrecision")
     def max_precision(self) -> pulumi.Output[Optional[int]]:
         """
-        Maximum number of digits to display when rounding values up or down
+        Maximum number of digits to display when rounding values up or down.
         """
         return pulumi.get(self, "max_precision")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info[in the Splunk Observability Cloud docs](https://developers.signalfx.com/signalflow_analytics/signalflow_overview.html#_signalflow_programming_language).
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> pulumi.Output[Optional[int]]:
         """
-        How often (in seconds) to refresh the values of the list
+        How often (in seconds) to refresh the values of the list.
         """
         return pulumi.get(self, "refresh_interval")
 
     @property
     @pulumi.getter(name="secondaryVisualization")
     def secondary_visualization(self) -> pulumi.Output[Optional[str]]:
         """
-        (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
+        The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`Sparkline`).
         """
         return pulumi.get(self, "secondary_visualization")
 
     @property
     @pulumi.getter(name="sortBy")
     def sort_by(self) -> pulumi.Output[Optional[str]]:
         """
-        The property to use when sorting the elements. Use 'value' if you want to sort by value. Must be prepended with + for
-        ascending or - for descending (e.g. -foo)
+        The property to use when sorting the elements. Use `value` if you want to sort by value. Must be prepended with `+` for ascending or `-` for descending (e.g. `-foo`). Note there are some special values for some of the options provided in the UX: `"value"` for Value, `"sf_originatingMetric"` for Metric, and `"sf_metric"` for plot.
         """
         return pulumi.get(self, "sort_by")
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @property
     @pulumi.getter
     def timezone(self) -> pulumi.Output[Optional[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        The property value is a string that denotes the geographic region associated with the time zone, (default UTC).
         """
         return pulumi.get(self, "timezone")
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> pulumi.Output[Optional[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> pulumi.Output[Optional[Sequence['outputs.ListChartVizOption']]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/_inputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/_inputs.py`

 * *Files 10% similar despite different names*

```diff
@@ -15,23 +15,23 @@
 ]
 
 @pulumi.input_type
 class ViewColumnArgs:
     def __init__(__self__, *,
                  name: pulumi.Input[str]):
         """
-        :param pulumi.Input[str] name: Name of the column
+        :param pulumi.Input[str] name: Name of the log view.
         """
         pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Input[str]:
         """
-        Name of the column
+        Name of the log view.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: pulumi.Input[str]):
         pulumi.set(self, "name", value)
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/outputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/outputs.py`

 * *Files 2% similar despite different names*

```diff
@@ -15,23 +15,23 @@
 ]
 
 @pulumi.output_type
 class ViewColumn(dict):
     def __init__(__self__, *,
                  name: str):
         """
-        :param str name: Name of the column
+        :param str name: Name of the log view.
         """
         pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def name(self) -> str:
         """
-        Name of the column
+        Name of the log view.
         """
         return pulumi.get(self, "name")
 
 
 @pulumi.output_type
 class ViewSortOption(dict):
     def __init__(__self__, *,
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/timeline.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/log/timeline.py`

 * *Files 7% similar despite different names*

```diff
@@ -19,21 +19,21 @@
                  description: Optional[pulumi.Input[str]] = None,
                  end_time: Optional[pulumi.Input[int]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  start_time: Optional[pulumi.Input[int]] = None,
                  time_range: Optional[pulumi.Input[int]] = None):
         """
         The set of arguments for constructing a Timeline resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        :param pulumi.Input[str] program_text: Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
+        :param pulumi.Input[str] default_connection: The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log timeline.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log timeline.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         pulumi.set(__self__, "program_text", program_text)
         if default_connection is not None:
             pulumi.set(__self__, "default_connection", default_connection)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if end_time is not None:
@@ -45,87 +45,87 @@
         if time_range is not None:
             pulumi.set(__self__, "time_range", time_range)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="defaultConnection")
     def default_connection(self) -> Optional[pulumi.Input[str]]:
         """
-        default connection that the dashboard uses
+        The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
         """
         return pulumi.get(self, "default_connection")
 
     @default_connection.setter
     def default_connection(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "default_connection", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the log timeline.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the log timeline.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
@@ -139,22 +139,22 @@
                  name: Optional[pulumi.Input[str]] = None,
                  program_text: Optional[pulumi.Input[str]] = None,
                  start_time: Optional[pulumi.Input[int]] = None,
                  time_range: Optional[pulumi.Input[int]] = None,
                  url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Timeline resources.
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] default_connection: The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log timeline.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log timeline.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] url: The URL of the log timeline.
         """
         if default_connection is not None:
             pulumi.set(__self__, "default_connection", default_connection)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if end_time is not None:
             pulumi.set(__self__, "end_time", end_time)
@@ -169,99 +169,99 @@
         if url is not None:
             pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter(name="defaultConnection")
     def default_connection(self) -> Optional[pulumi.Input[str]]:
         """
-        default connection that the dashboard uses
+        The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
         """
         return pulumi.get(self, "default_connection")
 
     @default_connection.setter
     def default_connection(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "default_connection", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the log timeline.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the log timeline.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the log timeline.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
@@ -282,75 +282,37 @@
         """
         You can add logs data to your Observability Cloud dashboards without turning your logs into metrics first.
 
         A log timeline chart displays timeline visualization in a dashboard and shows you in detail what is happening and why.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the log timeline.
-        * `program_text` - (Required) Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
-        * `description` - (Optional) Description of the log timeline.
-        * `time_range` - (Optional) From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `default_connection` - (Optional) The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the log timeline.
-        * `url` - The URL of the log timeline.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        :param pulumi.Input[str] default_connection: The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log timeline.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log timeline.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: TimelineArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         You can add logs data to your Observability Cloud dashboards without turning your logs into metrics first.
 
         A log timeline chart displays timeline visualization in a dashboard and shows you in detail what is happening and why.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the log timeline.
-        * `program_text` - (Required) Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
-        * `description` - (Optional) Description of the log timeline.
-        * `time_range` - (Optional) From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `default_connection` - (Optional) The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the log timeline.
-        * `url` - The URL of the log timeline.
-
         :param str resource_name: The name of the resource.
         :param TimelineArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(TimelineArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -409,22 +371,22 @@
         """
         Get an existing Timeline resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] default_connection: The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
+        :param pulumi.Input[str] description: Description of the log timeline.
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[str] name: Name of the log timeline.
+        :param pulumi.Input[str] program_text: Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[int] time_range: From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] url: The URL of the log timeline.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _TimelineState.__new__(_TimelineState)
 
         __props__.__dict__["default_connection"] = default_connection
         __props__.__dict__["description"] = description
@@ -436,67 +398,67 @@
         __props__.__dict__["url"] = url
         return Timeline(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="defaultConnection")
     def default_connection(self) -> pulumi.Output[Optional[str]]:
         """
-        default connection that the dashboard uses
+        The connection that the log timeline uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
         """
         return pulumi.get(self, "default_connection")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart (Optional)
+        Description of the log timeline.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the log timeline.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the log timeline. More info at https://dev.splunk.com/observability/docs/.
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the log timeline.
         """
         return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/log/view.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/table_chart.py`

 * *Files 13% similar despite different names*

```diff
@@ -3,602 +3,695 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from .. import _utilities
+from . import _utilities
 from . import outputs
 from ._inputs import *
 
-__all__ = ['ViewArgs', 'View']
+__all__ = ['TableChartArgs', 'TableChart']
 
 @pulumi.input_type
-class ViewArgs:
+class TableChartArgs:
     def __init__(__self__, *,
                  program_text: pulumi.Input[str],
-                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]] = None,
-                 default_connection: Optional[pulumi.Input[str]] = None,
                  description: Optional[pulumi.Input[str]] = None,
-                 end_time: Optional[pulumi.Input[int]] = None,
+                 disable_sampling: Optional[pulumi.Input[bool]] = None,
+                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 hide_timestamp: Optional[pulumi.Input[bool]] = None,
+                 max_delay: Optional[pulumi.Input[int]] = None,
+                 minimum_resolution: Optional[pulumi.Input[int]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]] = None,
-                 start_time: Optional[pulumi.Input[int]] = None,
-                 time_range: Optional[pulumi.Input[int]] = None):
-        """
-        The set of arguments for constructing a View resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]] columns: Column configuration
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]] sort_options: Sorting options configuration
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+                 refresh_interval: Optional[pulumi.Input[int]] = None,
+                 timezone: Optional[pulumi.Input[str]] = None,
+                 unit_prefix: Optional[pulumi.Input[str]] = None,
+                 viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]]] = None):
+        """
+        The set of arguments for constructing a TableChart resource.
+        :param pulumi.Input[str] program_text: The SignalFlow for your Data Table Chart
+        :param pulumi.Input[str] description: Description of the table chart.
+        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Dimension to group by
+        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
+        :param pulumi.Input[str] name: Name of the table chart.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the Table
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
+        :param pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
         """
         pulumi.set(__self__, "program_text", program_text)
-        if columns is not None:
-            pulumi.set(__self__, "columns", columns)
-        if default_connection is not None:
-            pulumi.set(__self__, "default_connection", default_connection)
         if description is not None:
             pulumi.set(__self__, "description", description)
-        if end_time is not None:
-            pulumi.set(__self__, "end_time", end_time)
+        if disable_sampling is not None:
+            pulumi.set(__self__, "disable_sampling", disable_sampling)
+        if group_bies is not None:
+            pulumi.set(__self__, "group_bies", group_bies)
+        if hide_timestamp is not None:
+            pulumi.set(__self__, "hide_timestamp", hide_timestamp)
+        if max_delay is not None:
+            pulumi.set(__self__, "max_delay", max_delay)
+        if minimum_resolution is not None:
+            pulumi.set(__self__, "minimum_resolution", minimum_resolution)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if sort_options is not None:
-            pulumi.set(__self__, "sort_options", sort_options)
-        if start_time is not None:
-            pulumi.set(__self__, "start_time", start_time)
-        if time_range is not None:
-            pulumi.set(__self__, "time_range", time_range)
+        if refresh_interval is not None:
+            pulumi.set(__self__, "refresh_interval", refresh_interval)
+        if timezone is not None:
+            pulumi.set(__self__, "timezone", timezone)
+        if unit_prefix is not None:
+            pulumi.set(__self__, "unit_prefix", unit_prefix)
+        if viz_options is not None:
+            pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        The SignalFlow for your Data Table Chart
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter
-    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]:
+    def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Column configuration
+        Description of the table chart.
         """
-        return pulumi.get(self, "columns")
+        return pulumi.get(self, "description")
 
-    @columns.setter
-    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]):
-        pulumi.set(self, "columns", value)
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
 
     @property
-    @pulumi.getter(name="defaultConnection")
-    def default_connection(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="disableSampling")
+    def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        default connection that the dashboard uses
+        (false by default) If false, samples a subset of the output MTS, which improves UI performance
         """
-        return pulumi.get(self, "default_connection")
+        return pulumi.get(self, "disable_sampling")
 
-    @default_connection.setter
-    def default_connection(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "default_connection", value)
+    @disable_sampling.setter
+    def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "disable_sampling", value)
 
     @property
-    @pulumi.getter
-    def description(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="groupBies")
+    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Description of the chart (Optional)
+        Dimension to group by
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "group_bies")
 
-    @description.setter
-    def description(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "description", value)
+    @group_bies.setter
+    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "group_bies", value)
 
     @property
-    @pulumi.getter(name="endTime")
-    def end_time(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="hideTimestamp")
+    def hide_timestamp(self) -> Optional[pulumi.Input[bool]]:
         """
-        Seconds since epoch to end the visualization
+        (false by default) Whether to show the timestamp in the chart
         """
-        return pulumi.get(self, "end_time")
+        return pulumi.get(self, "hide_timestamp")
 
-    @end_time.setter
-    def end_time(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "end_time", value)
+    @hide_timestamp.setter
+    def hide_timestamp(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "hide_timestamp", value)
+
+    @property
+    @pulumi.getter(name="maxDelay")
+    def max_delay(self) -> Optional[pulumi.Input[int]]:
+        """
+        How long (in seconds) to wait for late datapoints
+        """
+        return pulumi.get(self, "max_delay")
+
+    @max_delay.setter
+    def max_delay(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "max_delay", value)
+
+    @property
+    @pulumi.getter(name="minimumResolution")
+    def minimum_resolution(self) -> Optional[pulumi.Input[int]]:
+        """
+        The minimum resolution (in seconds) to use for computing the underlying program
+        """
+        return pulumi.get(self, "minimum_resolution")
+
+    @minimum_resolution.setter
+    def minimum_resolution(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "minimum_resolution", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the table chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
-    @pulumi.getter(name="sortOptions")
-    def sort_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]:
+    @pulumi.getter(name="refreshInterval")
+    def refresh_interval(self) -> Optional[pulumi.Input[int]]:
+        """
+        How often (in seconds) to refresh the values of the Table
+        """
+        return pulumi.get(self, "refresh_interval")
+
+    @refresh_interval.setter
+    def refresh_interval(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "refresh_interval", value)
+
+    @property
+    @pulumi.getter
+    def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        Sorting options configuration
+        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
         """
-        return pulumi.get(self, "sort_options")
+        return pulumi.get(self, "timezone")
 
-    @sort_options.setter
-    def sort_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]):
-        pulumi.set(self, "sort_options", value)
+    @timezone.setter
+    def timezone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "timezone", value)
 
     @property
-    @pulumi.getter(name="startTime")
-    def start_time(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="unitPrefix")
+    def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        Seconds since epoch to start the visualization
+        (Metric by default) Must be "Metric" or "Binary"
         """
-        return pulumi.get(self, "start_time")
+        return pulumi.get(self, "unit_prefix")
 
-    @start_time.setter
-    def start_time(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "start_time", value)
+    @unit_prefix.setter
+    def unit_prefix(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "unit_prefix", value)
 
     @property
-    @pulumi.getter(name="timeRange")
-    def time_range(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="vizOptions")
+    def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        Plot-level customization options, associated with a publish statement
         """
-        return pulumi.get(self, "time_range")
+        return pulumi.get(self, "viz_options")
 
-    @time_range.setter
-    def time_range(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "time_range", value)
+    @viz_options.setter
+    def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]]]):
+        pulumi.set(self, "viz_options", value)
 
 
 @pulumi.input_type
-class _ViewState:
+class _TableChartState:
     def __init__(__self__, *,
-                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]] = None,
-                 default_connection: Optional[pulumi.Input[str]] = None,
                  description: Optional[pulumi.Input[str]] = None,
-                 end_time: Optional[pulumi.Input[int]] = None,
+                 disable_sampling: Optional[pulumi.Input[bool]] = None,
+                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 hide_timestamp: Optional[pulumi.Input[bool]] = None,
+                 max_delay: Optional[pulumi.Input[int]] = None,
+                 minimum_resolution: Optional[pulumi.Input[int]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  program_text: Optional[pulumi.Input[str]] = None,
-                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]] = None,
-                 start_time: Optional[pulumi.Input[int]] = None,
-                 time_range: Optional[pulumi.Input[int]] = None,
-                 url: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering View resources.
-        :param pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]] columns: Column configuration
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]] sort_options: Sorting options configuration
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] url: URL of the chart
-        """
-        if columns is not None:
-            pulumi.set(__self__, "columns", columns)
-        if default_connection is not None:
-            pulumi.set(__self__, "default_connection", default_connection)
+                 refresh_interval: Optional[pulumi.Input[int]] = None,
+                 timezone: Optional[pulumi.Input[str]] = None,
+                 unit_prefix: Optional[pulumi.Input[str]] = None,
+                 url: Optional[pulumi.Input[str]] = None,
+                 viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]]] = None):
+        """
+        Input properties used for looking up and filtering TableChart resources.
+        :param pulumi.Input[str] description: Description of the table chart.
+        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Dimension to group by
+        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
+        :param pulumi.Input[str] name: Name of the table chart.
+        :param pulumi.Input[str] program_text: The SignalFlow for your Data Table Chart
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the Table
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        """
         if description is not None:
             pulumi.set(__self__, "description", description)
-        if end_time is not None:
-            pulumi.set(__self__, "end_time", end_time)
+        if disable_sampling is not None:
+            pulumi.set(__self__, "disable_sampling", disable_sampling)
+        if group_bies is not None:
+            pulumi.set(__self__, "group_bies", group_bies)
+        if hide_timestamp is not None:
+            pulumi.set(__self__, "hide_timestamp", hide_timestamp)
+        if max_delay is not None:
+            pulumi.set(__self__, "max_delay", max_delay)
+        if minimum_resolution is not None:
+            pulumi.set(__self__, "minimum_resolution", minimum_resolution)
         if name is not None:
             pulumi.set(__self__, "name", name)
         if program_text is not None:
             pulumi.set(__self__, "program_text", program_text)
-        if sort_options is not None:
-            pulumi.set(__self__, "sort_options", sort_options)
-        if start_time is not None:
-            pulumi.set(__self__, "start_time", start_time)
-        if time_range is not None:
-            pulumi.set(__self__, "time_range", time_range)
+        if refresh_interval is not None:
+            pulumi.set(__self__, "refresh_interval", refresh_interval)
+        if timezone is not None:
+            pulumi.set(__self__, "timezone", timezone)
+        if unit_prefix is not None:
+            pulumi.set(__self__, "unit_prefix", unit_prefix)
         if url is not None:
             pulumi.set(__self__, "url", url)
+        if viz_options is not None:
+            pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter
-    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]:
+    def description(self) -> Optional[pulumi.Input[str]]:
+        """
+        Description of the table chart.
+        """
+        return pulumi.get(self, "description")
+
+    @description.setter
+    def description(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "description", value)
+
+    @property
+    @pulumi.getter(name="disableSampling")
+    def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        Column configuration
+        (false by default) If false, samples a subset of the output MTS, which improves UI performance
         """
-        return pulumi.get(self, "columns")
+        return pulumi.get(self, "disable_sampling")
 
-    @columns.setter
-    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewColumnArgs']]]]):
-        pulumi.set(self, "columns", value)
+    @disable_sampling.setter
+    def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "disable_sampling", value)
 
     @property
-    @pulumi.getter(name="defaultConnection")
-    def default_connection(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="groupBies")
+    def group_bies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        default connection that the dashboard uses
+        Dimension to group by
         """
-        return pulumi.get(self, "default_connection")
+        return pulumi.get(self, "group_bies")
 
-    @default_connection.setter
-    def default_connection(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "default_connection", value)
+    @group_bies.setter
+    def group_bies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
+        pulumi.set(self, "group_bies", value)
 
     @property
-    @pulumi.getter
-    def description(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter(name="hideTimestamp")
+    def hide_timestamp(self) -> Optional[pulumi.Input[bool]]:
         """
-        Description of the chart (Optional)
+        (false by default) Whether to show the timestamp in the chart
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "hide_timestamp")
 
-    @description.setter
-    def description(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "description", value)
+    @hide_timestamp.setter
+    def hide_timestamp(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "hide_timestamp", value)
 
     @property
-    @pulumi.getter(name="endTime")
-    def end_time(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="maxDelay")
+    def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        How long (in seconds) to wait for late datapoints
         """
-        return pulumi.get(self, "end_time")
+        return pulumi.get(self, "max_delay")
 
-    @end_time.setter
-    def end_time(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "end_time", value)
+    @max_delay.setter
+    def max_delay(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "max_delay", value)
+
+    @property
+    @pulumi.getter(name="minimumResolution")
+    def minimum_resolution(self) -> Optional[pulumi.Input[int]]:
+        """
+        The minimum resolution (in seconds) to use for computing the underlying program
+        """
+        return pulumi.get(self, "minimum_resolution")
+
+    @minimum_resolution.setter
+    def minimum_resolution(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "minimum_resolution", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the table chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        The SignalFlow for your Data Table Chart
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
-    @pulumi.getter(name="sortOptions")
-    def sort_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]:
+    @pulumi.getter(name="refreshInterval")
+    def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        Sorting options configuration
+        How often (in seconds) to refresh the values of the Table
         """
-        return pulumi.get(self, "sort_options")
+        return pulumi.get(self, "refresh_interval")
 
-    @sort_options.setter
-    def sort_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ViewSortOptionArgs']]]]):
-        pulumi.set(self, "sort_options", value)
+    @refresh_interval.setter
+    def refresh_interval(self, value: Optional[pulumi.Input[int]]):
+        pulumi.set(self, "refresh_interval", value)
 
     @property
-    @pulumi.getter(name="startTime")
-    def start_time(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter
+    def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        Seconds since epoch to start the visualization
+        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
         """
-        return pulumi.get(self, "start_time")
+        return pulumi.get(self, "timezone")
 
-    @start_time.setter
-    def start_time(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "start_time", value)
+    @timezone.setter
+    def timezone(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "timezone", value)
 
     @property
-    @pulumi.getter(name="timeRange")
-    def time_range(self) -> Optional[pulumi.Input[int]]:
+    @pulumi.getter(name="unitPrefix")
+    def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        (Metric by default) Must be "Metric" or "Binary"
         """
-        return pulumi.get(self, "time_range")
+        return pulumi.get(self, "unit_prefix")
 
-    @time_range.setter
-    def time_range(self, value: Optional[pulumi.Input[int]]):
-        pulumi.set(self, "time_range", value)
+    @unit_prefix.setter
+    def unit_prefix(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
+    @property
+    @pulumi.getter(name="vizOptions")
+    def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]]]:
+        """
+        Plot-level customization options, associated with a publish statement
+        """
+        return pulumi.get(self, "viz_options")
+
+    @viz_options.setter
+    def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TableChartVizOptionArgs']]]]):
+        pulumi.set(self, "viz_options", value)
+
 
-class View(pulumi.CustomResource):
+class TableChart(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]]] = None,
-                 default_connection: Optional[pulumi.Input[str]] = None,
                  description: Optional[pulumi.Input[str]] = None,
-                 end_time: Optional[pulumi.Input[int]] = None,
+                 disable_sampling: Optional[pulumi.Input[bool]] = None,
+                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 hide_timestamp: Optional[pulumi.Input[bool]] = None,
+                 max_delay: Optional[pulumi.Input[int]] = None,
+                 minimum_resolution: Optional[pulumi.Input[int]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  program_text: Optional[pulumi.Input[str]] = None,
-                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]]] = None,
-                 start_time: Optional[pulumi.Input[int]] = None,
-                 time_range: Optional[pulumi.Input[int]] = None,
+                 refresh_interval: Optional[pulumi.Input[int]] = None,
+                 timezone: Optional[pulumi.Input[str]] = None,
+                 unit_prefix: Optional[pulumi.Input[str]] = None,
+                 viz_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TableChartVizOptionArgs']]]]] = None,
                  __props__=None):
         """
-        You can add logs data to your Observability Cloud dashboards without turning your logs into metrics first.
-
-        A log view displays log lines in a table form in a dashboard and shows you in detail what is happening and why.
+        This special type of chart displays a data table. This table can be grouped by a dimension.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the log view.
-        * `program_text` - (Required) Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
-        * `description` - (Optional) Description of the log view.
-        * `time_range` - (Optional) From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `columns` - (Optional) The column headers to show on the log view.
-        * `sort_options` - (Optional) The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
-        * `default_connection` - (Optional) The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the log view.
-        * `url` - The URL of the log view.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]] columns: Column configuration
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]] sort_options: Sorting options configuration
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        :param pulumi.Input[str] description: Description of the table chart.
+        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Dimension to group by
+        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
+        :param pulumi.Input[str] name: Name of the table chart.
+        :param pulumi.Input[str] program_text: The SignalFlow for your Data Table Chart
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the Table
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TableChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: ViewArgs,
+                 args: TableChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        You can add logs data to your Observability Cloud dashboards without turning your logs into metrics first.
-
-        A log view displays log lines in a table form in a dashboard and shows you in detail what is happening and why.
+        This special type of chart displays a data table. This table can be grouped by a dimension.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the log view.
-        * `program_text` - (Required) Signalflow program text for the log view. More info at https://developers.signalfx.com/docs/signalflow-overview.
-        * `description` - (Optional) Description of the log view.
-        * `time_range` - (Optional) From when to display data. Splunk Observability Cloud time syntax (e.g. `"-5m"`, `"-1h"`). Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `columns` - (Optional) The column headers to show on the log view.
-        * `sort_options` - (Optional) The sorting options configuration to specify if the log view table needs to be sorted in a particular field.
-        * `default_connection` - (Optional) The connection that the log view uses to fetch data. This could be Splunk Enterprise, Splunk Enterprise Cloud or Observability Cloud.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the log view.
-        * `url` - The URL of the log view.
-
         :param str resource_name: The name of the resource.
-        :param ViewArgs args: The arguments to use to populate this resource's properties.
+        :param TableChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(ViewArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(TableChartArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 columns: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]]] = None,
-                 default_connection: Optional[pulumi.Input[str]] = None,
                  description: Optional[pulumi.Input[str]] = None,
-                 end_time: Optional[pulumi.Input[int]] = None,
+                 disable_sampling: Optional[pulumi.Input[bool]] = None,
+                 group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+                 hide_timestamp: Optional[pulumi.Input[bool]] = None,
+                 max_delay: Optional[pulumi.Input[int]] = None,
+                 minimum_resolution: Optional[pulumi.Input[int]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  program_text: Optional[pulumi.Input[str]] = None,
-                 sort_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]]] = None,
-                 start_time: Optional[pulumi.Input[int]] = None,
-                 time_range: Optional[pulumi.Input[int]] = None,
+                 refresh_interval: Optional[pulumi.Input[int]] = None,
+                 timezone: Optional[pulumi.Input[str]] = None,
+                 unit_prefix: Optional[pulumi.Input[str]] = None,
+                 viz_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TableChartVizOptionArgs']]]]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = ViewArgs.__new__(ViewArgs)
+            __props__ = TableChartArgs.__new__(TableChartArgs)
 
-            __props__.__dict__["columns"] = columns
-            __props__.__dict__["default_connection"] = default_connection
             __props__.__dict__["description"] = description
-            __props__.__dict__["end_time"] = end_time
+            __props__.__dict__["disable_sampling"] = disable_sampling
+            __props__.__dict__["group_bies"] = group_bies
+            __props__.__dict__["hide_timestamp"] = hide_timestamp
+            __props__.__dict__["max_delay"] = max_delay
+            __props__.__dict__["minimum_resolution"] = minimum_resolution
             __props__.__dict__["name"] = name
             if program_text is None and not opts.urn:
                 raise TypeError("Missing required property 'program_text'")
             __props__.__dict__["program_text"] = program_text
-            __props__.__dict__["sort_options"] = sort_options
-            __props__.__dict__["start_time"] = start_time
-            __props__.__dict__["time_range"] = time_range
+            __props__.__dict__["refresh_interval"] = refresh_interval
+            __props__.__dict__["timezone"] = timezone
+            __props__.__dict__["unit_prefix"] = unit_prefix
+            __props__.__dict__["viz_options"] = viz_options
             __props__.__dict__["url"] = None
-        alias_opts = pulumi.ResourceOptions(aliases=[pulumi.Alias(type_="signalfx:logs/view:View")])
-        opts = pulumi.ResourceOptions.merge(opts, alias_opts)
-        super(View, __self__).__init__(
-            'signalfx:log/view:View',
+        super(TableChart, __self__).__init__(
+            'signalfx:index/tableChart:TableChart',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            columns: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]]] = None,
-            default_connection: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
-            end_time: Optional[pulumi.Input[int]] = None,
+            disable_sampling: Optional[pulumi.Input[bool]] = None,
+            group_bies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
+            hide_timestamp: Optional[pulumi.Input[bool]] = None,
+            max_delay: Optional[pulumi.Input[int]] = None,
+            minimum_resolution: Optional[pulumi.Input[int]] = None,
             name: Optional[pulumi.Input[str]] = None,
             program_text: Optional[pulumi.Input[str]] = None,
-            sort_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]]] = None,
-            start_time: Optional[pulumi.Input[int]] = None,
-            time_range: Optional[pulumi.Input[int]] = None,
-            url: Optional[pulumi.Input[str]] = None) -> 'View':
+            refresh_interval: Optional[pulumi.Input[int]] = None,
+            timezone: Optional[pulumi.Input[str]] = None,
+            unit_prefix: Optional[pulumi.Input[str]] = None,
+            url: Optional[pulumi.Input[str]] = None,
+            viz_options: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TableChartVizOptionArgs']]]]] = None) -> 'TableChart':
         """
-        Get an existing View resource's state with the given name, id, and optional extra
+        Get an existing TableChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewColumnArgs']]]] columns: Column configuration
-        :param pulumi.Input[str] default_connection: default connection that the dashboard uses
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['ViewSortOptionArgs']]]] sort_options: Sorting options configuration
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] description: Description of the table chart.
+        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_bies: Dimension to group by
+        :param pulumi.Input[bool] hide_timestamp: (false by default) Whether to show the timestamp in the chart
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
+        :param pulumi.Input[str] name: Name of the table chart.
+        :param pulumi.Input[str] program_text: The SignalFlow for your Data Table Chart
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the Table
+        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TableChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _ViewState.__new__(_ViewState)
+        __props__ = _TableChartState.__new__(_TableChartState)
 
-        __props__.__dict__["columns"] = columns
-        __props__.__dict__["default_connection"] = default_connection
         __props__.__dict__["description"] = description
-        __props__.__dict__["end_time"] = end_time
+        __props__.__dict__["disable_sampling"] = disable_sampling
+        __props__.__dict__["group_bies"] = group_bies
+        __props__.__dict__["hide_timestamp"] = hide_timestamp
+        __props__.__dict__["max_delay"] = max_delay
+        __props__.__dict__["minimum_resolution"] = minimum_resolution
         __props__.__dict__["name"] = name
         __props__.__dict__["program_text"] = program_text
-        __props__.__dict__["sort_options"] = sort_options
-        __props__.__dict__["start_time"] = start_time
-        __props__.__dict__["time_range"] = time_range
+        __props__.__dict__["refresh_interval"] = refresh_interval
+        __props__.__dict__["timezone"] = timezone
+        __props__.__dict__["unit_prefix"] = unit_prefix
         __props__.__dict__["url"] = url
-        return View(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["viz_options"] = viz_options
+        return TableChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
-    def columns(self) -> pulumi.Output[Optional[Sequence['outputs.ViewColumn']]]:
+    def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Column configuration
+        Description of the table chart.
         """
-        return pulumi.get(self, "columns")
+        return pulumi.get(self, "description")
 
     @property
-    @pulumi.getter(name="defaultConnection")
-    def default_connection(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="disableSampling")
+    def disable_sampling(self) -> pulumi.Output[Optional[bool]]:
         """
-        default connection that the dashboard uses
+        (false by default) If false, samples a subset of the output MTS, which improves UI performance
         """
-        return pulumi.get(self, "default_connection")
+        return pulumi.get(self, "disable_sampling")
 
     @property
-    @pulumi.getter
-    def description(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter(name="groupBies")
+    def group_bies(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Description of the chart (Optional)
+        Dimension to group by
         """
-        return pulumi.get(self, "description")
+        return pulumi.get(self, "group_bies")
 
     @property
-    @pulumi.getter(name="endTime")
-    def end_time(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="hideTimestamp")
+    def hide_timestamp(self) -> pulumi.Output[Optional[bool]]:
         """
-        Seconds since epoch to end the visualization
+        (false by default) Whether to show the timestamp in the chart
         """
-        return pulumi.get(self, "end_time")
+        return pulumi.get(self, "hide_timestamp")
+
+    @property
+    @pulumi.getter(name="maxDelay")
+    def max_delay(self) -> pulumi.Output[Optional[int]]:
+        """
+        How long (in seconds) to wait for late datapoints
+        """
+        return pulumi.get(self, "max_delay")
+
+    @property
+    @pulumi.getter(name="minimumResolution")
+    def minimum_resolution(self) -> pulumi.Output[Optional[int]]:
+        """
+        The minimum resolution (in seconds) to use for computing the underlying program
+        """
+        return pulumi.get(self, "minimum_resolution")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the table chart.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        The SignalFlow for your Data Table Chart
         """
         return pulumi.get(self, "program_text")
 
     @property
-    @pulumi.getter(name="sortOptions")
-    def sort_options(self) -> pulumi.Output[Optional[Sequence['outputs.ViewSortOption']]]:
+    @pulumi.getter(name="refreshInterval")
+    def refresh_interval(self) -> pulumi.Output[Optional[int]]:
         """
-        Sorting options configuration
+        How often (in seconds) to refresh the values of the Table
         """
-        return pulumi.get(self, "sort_options")
+        return pulumi.get(self, "refresh_interval")
 
     @property
-    @pulumi.getter(name="startTime")
-    def start_time(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter
+    def timezone(self) -> pulumi.Output[Optional[str]]:
         """
-        Seconds since epoch to start the visualization
+        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
         """
-        return pulumi.get(self, "start_time")
+        return pulumi.get(self, "timezone")
 
     @property
-    @pulumi.getter(name="timeRange")
-    def time_range(self) -> pulumi.Output[Optional[int]]:
+    @pulumi.getter(name="unitPrefix")
+    def unit_prefix(self) -> pulumi.Output[Optional[str]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        (Metric by default) Must be "Metric" or "Binary"
         """
-        return pulumi.get(self, "time_range")
+        return pulumi.get(self, "unit_prefix")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
+    @property
+    @pulumi.getter(name="vizOptions")
+    def viz_options(self) -> pulumi.Output[Optional[Sequence['outputs.TableChartVizOption']]]:
+        """
+        Plot-level customization options, associated with a publish statement
+        """
+        return pulumi.get(self, "viz_options")
+
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/metric_ruleset.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/metric_ruleset.py`

 * *Files 26% similar despite different names*

```diff
@@ -17,52 +17,52 @@
 class MetricRulesetArgs:
     def __init__(__self__, *,
                  metric_name: pulumi.Input[str],
                  routing_rules: pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]],
                  aggregation_rules: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]]] = None):
         """
         The set of arguments for constructing a MetricRuleset resource.
-        :param pulumi.Input[str] metric_name: Name of the metric
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]] routing_rules: Location to send the input metric
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]] aggregation_rules: Aggregation rules in the ruleset
+        :param pulumi.Input[str] metric_name: Name of the input metric
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]] routing_rules: Routing Rule object
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]] aggregation_rules: List of aggregation rules for the metric
         """
         pulumi.set(__self__, "metric_name", metric_name)
         pulumi.set(__self__, "routing_rules", routing_rules)
         if aggregation_rules is not None:
             pulumi.set(__self__, "aggregation_rules", aggregation_rules)
 
     @property
     @pulumi.getter(name="metricName")
     def metric_name(self) -> pulumi.Input[str]:
         """
-        Name of the metric
+        Name of the input metric
         """
         return pulumi.get(self, "metric_name")
 
     @metric_name.setter
     def metric_name(self, value: pulumi.Input[str]):
         pulumi.set(self, "metric_name", value)
 
     @property
     @pulumi.getter(name="routingRules")
     def routing_rules(self) -> pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]]:
         """
-        Location to send the input metric
+        Routing Rule object
         """
         return pulumi.get(self, "routing_rules")
 
     @routing_rules.setter
     def routing_rules(self, value: pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]]):
         pulumi.set(self, "routing_rules", value)
 
     @property
     @pulumi.getter(name="aggregationRules")
     def aggregation_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]]]:
         """
-        Aggregation rules in the ruleset
+        List of aggregation rules for the metric
         """
         return pulumi.get(self, "aggregation_rules")
 
     @aggregation_rules.setter
     def aggregation_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]]]):
         pulumi.set(self, "aggregation_rules", value)
 
@@ -77,22 +77,22 @@
                  last_updated_by: Optional[pulumi.Input[str]] = None,
                  last_updated_by_name: Optional[pulumi.Input[str]] = None,
                  metric_name: Optional[pulumi.Input[str]] = None,
                  routing_rules: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]]] = None,
                  version: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering MetricRuleset resources.
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]] aggregation_rules: Aggregation rules in the ruleset
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]] aggregation_rules: List of aggregation rules for the metric
         :param pulumi.Input[str] created: Timestamp of when the metric ruleset was created
         :param pulumi.Input[str] creator: ID of the creator of the metric ruleset
         :param pulumi.Input[str] last_updated: Timestamp of when the metric ruleset was last updated
         :param pulumi.Input[str] last_updated_by: ID of user who last updated the metric ruleset
         :param pulumi.Input[str] last_updated_by_name: Name of user who last updated this metric ruleset
-        :param pulumi.Input[str] metric_name: Name of the metric
-        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]] routing_rules: Location to send the input metric
+        :param pulumi.Input[str] metric_name: Name of the input metric
+        :param pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]] routing_rules: Routing Rule object
         :param pulumi.Input[str] version: Version of the ruleset
         """
         if aggregation_rules is not None:
             pulumi.set(__self__, "aggregation_rules", aggregation_rules)
         if created is not None:
             pulumi.set(__self__, "created", created)
         if creator is not None:
@@ -110,15 +110,15 @@
         if version is not None:
             pulumi.set(__self__, "version", version)
 
     @property
     @pulumi.getter(name="aggregationRules")
     def aggregation_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]]]:
         """
-        Aggregation rules in the ruleset
+        List of aggregation rules for the metric
         """
         return pulumi.get(self, "aggregation_rules")
 
     @aggregation_rules.setter
     def aggregation_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetAggregationRuleArgs']]]]):
         pulumi.set(self, "aggregation_rules", value)
 
@@ -182,27 +182,27 @@
     def last_updated_by_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "last_updated_by_name", value)
 
     @property
     @pulumi.getter(name="metricName")
     def metric_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the metric
+        Name of the input metric
         """
         return pulumi.get(self, "metric_name")
 
     @metric_name.setter
     def metric_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "metric_name", value)
 
     @property
     @pulumi.getter(name="routingRules")
     def routing_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]]]:
         """
-        Location to send the input metric
+        Routing Rule object
         """
         return pulumi.get(self, "routing_rules")
 
     @routing_rules.setter
     def routing_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MetricRulesetRoutingRuleArgs']]]]):
         pulumi.set(self, "routing_rules", value)
 
@@ -231,77 +231,33 @@
         """
         Provides an Observability Cloud resource for managing metric rulesets.
 
         > **NOTE** When managing metric rulesets to drop data use a session token for an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `metric_name` - (Required) Name of the input metric
-        * `aggregation_rules` - (Optional) List of aggregation rules for the metric
-          * `enabled` - (Required) When false, this rule will not generate aggregated MTSs
-          * `name` - (Optional) name of the aggregation rule
-          * `matcher` - (Required) Matcher object
-            * `type` - (Required) Type of matcher. Must always be "dimension"
-            * `filters` - (Optional) List of filters to filter the set of input MTSs
-              * `property` - (Required) - Name of the dimension
-              * `property_value` - (Required) - Value of the dimension
-              * `not` - When true, this filter will match all values not matching the property_values
-          * `aggregator` - (Required) - Aggregator object
-            * `type` - (Required) Type of aggregator. Must always be "rollup"
-            * `dimensions` - (Required) List of dimensions to either be kept or dropped in the new aggregated MTSs
-            * `drop_dimensions` - (Required) when true, the specified dimensions will be dropped from the aggregated MTSs
-            * `output_name` - (Required) name of the new aggregated metric
-        * `routing_rule` - (Required) Routing Rule object
-          * `destination` - (Required) - end destination of the input metric. Must be `RealTime` or `Drop`
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetAggregationRuleArgs']]]] aggregation_rules: Aggregation rules in the ruleset
-        :param pulumi.Input[str] metric_name: Name of the metric
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetRoutingRuleArgs']]]] routing_rules: Location to send the input metric
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetAggregationRuleArgs']]]] aggregation_rules: List of aggregation rules for the metric
+        :param pulumi.Input[str] metric_name: Name of the input metric
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetRoutingRuleArgs']]]] routing_rules: Routing Rule object
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: MetricRulesetArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Provides an Observability Cloud resource for managing metric rulesets.
 
         > **NOTE** When managing metric rulesets to drop data use a session token for an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `metric_name` - (Required) Name of the input metric
-        * `aggregation_rules` - (Optional) List of aggregation rules for the metric
-          * `enabled` - (Required) When false, this rule will not generate aggregated MTSs
-          * `name` - (Optional) name of the aggregation rule
-          * `matcher` - (Required) Matcher object
-            * `type` - (Required) Type of matcher. Must always be "dimension"
-            * `filters` - (Optional) List of filters to filter the set of input MTSs
-              * `property` - (Required) - Name of the dimension
-              * `property_value` - (Required) - Value of the dimension
-              * `not` - When true, this filter will match all values not matching the property_values
-          * `aggregator` - (Required) - Aggregator object
-            * `type` - (Required) Type of aggregator. Must always be "rollup"
-            * `dimensions` - (Required) List of dimensions to either be kept or dropped in the new aggregated MTSs
-            * `drop_dimensions` - (Required) when true, the specified dimensions will be dropped from the aggregated MTSs
-            * `output_name` - (Required) name of the new aggregated metric
-        * `routing_rule` - (Required) Routing Rule object
-          * `destination` - (Required) - end destination of the input metric. Must be `RealTime` or `Drop`
-
         :param str resource_name: The name of the resource.
         :param MetricRulesetArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(MetricRulesetArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -360,22 +316,22 @@
         """
         Get an existing MetricRuleset resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetAggregationRuleArgs']]]] aggregation_rules: Aggregation rules in the ruleset
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetAggregationRuleArgs']]]] aggregation_rules: List of aggregation rules for the metric
         :param pulumi.Input[str] created: Timestamp of when the metric ruleset was created
         :param pulumi.Input[str] creator: ID of the creator of the metric ruleset
         :param pulumi.Input[str] last_updated: Timestamp of when the metric ruleset was last updated
         :param pulumi.Input[str] last_updated_by: ID of user who last updated the metric ruleset
         :param pulumi.Input[str] last_updated_by_name: Name of user who last updated this metric ruleset
-        :param pulumi.Input[str] metric_name: Name of the metric
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetRoutingRuleArgs']]]] routing_rules: Location to send the input metric
+        :param pulumi.Input[str] metric_name: Name of the input metric
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['MetricRulesetRoutingRuleArgs']]]] routing_rules: Routing Rule object
         :param pulumi.Input[str] version: Version of the ruleset
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _MetricRulesetState.__new__(_MetricRulesetState)
 
         __props__.__dict__["aggregation_rules"] = aggregation_rules
@@ -389,15 +345,15 @@
         __props__.__dict__["version"] = version
         return MetricRuleset(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="aggregationRules")
     def aggregation_rules(self) -> pulumi.Output[Optional[Sequence['outputs.MetricRulesetAggregationRule']]]:
         """
-        Aggregation rules in the ruleset
+        List of aggregation rules for the metric
         """
         return pulumi.get(self, "aggregation_rules")
 
     @property
     @pulumi.getter
     def created(self) -> pulumi.Output[str]:
         """
@@ -437,23 +393,23 @@
         """
         return pulumi.get(self, "last_updated_by_name")
 
     @property
     @pulumi.getter(name="metricName")
     def metric_name(self) -> pulumi.Output[str]:
         """
-        Name of the metric
+        Name of the input metric
         """
         return pulumi.get(self, "metric_name")
 
     @property
     @pulumi.getter(name="routingRules")
     def routing_rules(self) -> pulumi.Output[Sequence['outputs.MetricRulesetRoutingRule']]:
         """
-        Location to send the input metric
+        Routing Rule object
         """
         return pulumi.get(self, "routing_rules")
 
     @property
     @pulumi.getter
     def version(self) -> pulumi.Output[str]:
         """
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/opsgenie/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/webhook_integration.py`

 * *Files 12% similar despite different names*

```diff
@@ -3,322 +3,331 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from .. import _utilities
+from . import _utilities
+from . import outputs
+from ._inputs import *
 
-__all__ = ['IntegrationArgs', 'Integration']
+__all__ = ['WebhookIntegrationArgs', 'WebhookIntegration']
 
 @pulumi.input_type
-class IntegrationArgs:
+class WebhookIntegrationArgs:
     def __init__(__self__, *,
-                 api_key: pulumi.Input[str],
                  enabled: pulumi.Input[bool],
-                 api_url: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None):
+                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 shared_secret: Optional[pulumi.Input[str]] = None,
+                 url: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[str] api_key: Opsgenie API key
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] api_url: Opsgenie API URL for integration
-        :param pulumi.Input[str] name: Name of the integration
+        The set of arguments for constructing a WebhookIntegration resource.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]] headers: A header to send with the request
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] url: The URL to request
         """
-        pulumi.set(__self__, "api_key", api_key)
         pulumi.set(__self__, "enabled", enabled)
-        if api_url is not None:
-            pulumi.set(__self__, "api_url", api_url)
+        if headers is not None:
+            pulumi.set(__self__, "headers", headers)
         if name is not None:
             pulumi.set(__self__, "name", name)
-
-    @property
-    @pulumi.getter(name="apiKey")
-    def api_key(self) -> pulumi.Input[str]:
-        """
-        Opsgenie API key
-        """
-        return pulumi.get(self, "api_key")
-
-    @api_key.setter
-    def api_key(self, value: pulumi.Input[str]):
-        pulumi.set(self, "api_key", value)
+        if shared_secret is not None:
+            pulumi.set(__self__, "shared_secret", shared_secret)
+        if url is not None:
+            pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
-    @pulumi.getter(name="apiUrl")
-    def api_url(self) -> Optional[pulumi.Input[str]]:
+    @pulumi.getter
+    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]:
         """
-        Opsgenie API URL for integration
+        A header to send with the request
         """
-        return pulumi.get(self, "api_url")
+        return pulumi.get(self, "headers")
 
-    @api_url.setter
-    def api_url(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "api_url", value)
+    @headers.setter
+    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]):
+        pulumi.set(self, "headers", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
+    @property
+    @pulumi.getter(name="sharedSecret")
+    def shared_secret(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "shared_secret")
+
+    @shared_secret.setter
+    def shared_secret(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "shared_secret", value)
+
+    @property
+    @pulumi.getter
+    def url(self) -> Optional[pulumi.Input[str]]:
+        """
+        The URL to request
+        """
+        return pulumi.get(self, "url")
+
+    @url.setter
+    def url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "url", value)
+
 
 @pulumi.input_type
-class _IntegrationState:
+class _WebhookIntegrationState:
     def __init__(__self__, *,
-                 api_key: Optional[pulumi.Input[str]] = None,
-                 api_url: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
-                 name: Optional[pulumi.Input[str]] = None):
+                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]] = None,
+                 name: Optional[pulumi.Input[str]] = None,
+                 shared_secret: Optional[pulumi.Input[str]] = None,
+                 url: Optional[pulumi.Input[str]] = None):
+        """
+        Input properties used for looking up and filtering WebhookIntegration resources.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]] headers: A header to send with the request
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] url: The URL to request
         """
-        Input properties used for looking up and filtering Integration resources.
-        :param pulumi.Input[str] api_key: Opsgenie API key
-        :param pulumi.Input[str] api_url: Opsgenie API URL for integration
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        """
-        if api_key is not None:
-            pulumi.set(__self__, "api_key", api_key)
-        if api_url is not None:
-            pulumi.set(__self__, "api_url", api_url)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
+        if headers is not None:
+            pulumi.set(__self__, "headers", headers)
         if name is not None:
             pulumi.set(__self__, "name", name)
-
-    @property
-    @pulumi.getter(name="apiKey")
-    def api_key(self) -> Optional[pulumi.Input[str]]:
-        """
-        Opsgenie API key
-        """
-        return pulumi.get(self, "api_key")
-
-    @api_key.setter
-    def api_key(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "api_key", value)
-
-    @property
-    @pulumi.getter(name="apiUrl")
-    def api_url(self) -> Optional[pulumi.Input[str]]:
-        """
-        Opsgenie API URL for integration
-        """
-        return pulumi.get(self, "api_url")
-
-    @api_url.setter
-    def api_url(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "api_url", value)
+        if shared_secret is not None:
+            pulumi.set(__self__, "shared_secret", shared_secret)
+        if url is not None:
+            pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
+    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]:
+        """
+        A header to send with the request
+        """
+        return pulumi.get(self, "headers")
+
+    @headers.setter
+    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]):
+        pulumi.set(self, "headers", value)
+
+    @property
+    @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
+    @property
+    @pulumi.getter(name="sharedSecret")
+    def shared_secret(self) -> Optional[pulumi.Input[str]]:
+        return pulumi.get(self, "shared_secret")
+
+    @shared_secret.setter
+    def shared_secret(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "shared_secret", value)
+
+    @property
+    @pulumi.getter
+    def url(self) -> Optional[pulumi.Input[str]]:
+        """
+        The URL to request
+        """
+        return pulumi.get(self, "url")
+
+    @url.setter
+    def url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "url", value)
 
-class Integration(pulumi.CustomResource):
+
+class WebhookIntegration(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 api_key: Optional[pulumi.Input[str]] = None,
-                 api_url: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
+                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]]] = None,
                  name: Optional[pulumi.Input[str]] = None,
+                 shared_secret: Optional[pulumi.Input[str]] = None,
+                 url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Splunk Observability Cloud Opsgenie integration.
+        Splunk Observability Cloud webhook integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `api_key` - (Required) The API key
-        * `api_url` - (Optional) Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] api_key: Opsgenie API key
-        :param pulumi.Input[str] api_url: Opsgenie API URL for integration
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]] headers: A header to send with the request
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] url: The URL to request
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: IntegrationArgs,
+                 args: WebhookIntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Splunk Observability Cloud Opsgenie integration.
+        Splunk Observability Cloud webhook integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `api_key` - (Required) The API key
-        * `api_url` - (Optional) Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
-        :param IntegrationArgs args: The arguments to use to populate this resource's properties.
+        :param WebhookIntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(WebhookIntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 api_key: Optional[pulumi.Input[str]] = None,
-                 api_url: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
+                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]]] = None,
                  name: Optional[pulumi.Input[str]] = None,
+                 shared_secret: Optional[pulumi.Input[str]] = None,
+                 url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = IntegrationArgs.__new__(IntegrationArgs)
+            __props__ = WebhookIntegrationArgs.__new__(WebhookIntegrationArgs)
 
-            if api_key is None and not opts.urn:
-                raise TypeError("Missing required property 'api_key'")
-            __props__.__dict__["api_key"] = None if api_key is None else pulumi.Output.secret(api_key)
-            __props__.__dict__["api_url"] = api_url
             if enabled is None and not opts.urn:
                 raise TypeError("Missing required property 'enabled'")
             __props__.__dict__["enabled"] = enabled
+            __props__.__dict__["headers"] = None if headers is None else pulumi.Output.secret(headers)
             __props__.__dict__["name"] = name
-        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["apiKey"])
+            __props__.__dict__["shared_secret"] = None if shared_secret is None else pulumi.Output.secret(shared_secret)
+            __props__.__dict__["url"] = url
+        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["headers", "sharedSecret"])
         opts = pulumi.ResourceOptions.merge(opts, secret_opts)
-        super(Integration, __self__).__init__(
-            'signalfx:opsgenie/integration:Integration',
+        super(WebhookIntegration, __self__).__init__(
+            'signalfx:index/webhookIntegration:WebhookIntegration',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            api_key: Optional[pulumi.Input[str]] = None,
-            api_url: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
-            name: Optional[pulumi.Input[str]] = None) -> 'Integration':
+            headers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]]] = None,
+            name: Optional[pulumi.Input[str]] = None,
+            shared_secret: Optional[pulumi.Input[str]] = None,
+            url: Optional[pulumi.Input[str]] = None) -> 'WebhookIntegration':
         """
-        Get an existing Integration resource's state with the given name, id, and optional extra
+        Get an existing WebhookIntegration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] api_key: Opsgenie API key
-        :param pulumi.Input[str] api_url: Opsgenie API URL for integration
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]] headers: A header to send with the request
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] url: The URL to request
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _IntegrationState.__new__(_IntegrationState)
+        __props__ = _WebhookIntegrationState.__new__(_WebhookIntegrationState)
 
-        __props__.__dict__["api_key"] = api_key
-        __props__.__dict__["api_url"] = api_url
         __props__.__dict__["enabled"] = enabled
+        __props__.__dict__["headers"] = headers
         __props__.__dict__["name"] = name
-        return Integration(resource_name, opts=opts, __props__=__props__)
+        __props__.__dict__["shared_secret"] = shared_secret
+        __props__.__dict__["url"] = url
+        return WebhookIntegration(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="apiKey")
-    def api_key(self) -> pulumi.Output[str]:
+    @pulumi.getter
+    def enabled(self) -> pulumi.Output[bool]:
         """
-        Opsgenie API key
+        Whether the integration is enabled.
         """
-        return pulumi.get(self, "api_key")
+        return pulumi.get(self, "enabled")
 
     @property
-    @pulumi.getter(name="apiUrl")
-    def api_url(self) -> pulumi.Output[Optional[str]]:
+    @pulumi.getter
+    def headers(self) -> pulumi.Output[Optional[Sequence['outputs.WebhookIntegrationHeader']]]:
         """
-        Opsgenie API URL for integration
+        A header to send with the request
         """
-        return pulumi.get(self, "api_url")
+        return pulumi.get(self, "headers")
 
     @property
     @pulumi.getter
-    def enabled(self) -> pulumi.Output[bool]:
+    def name(self) -> pulumi.Output[str]:
         """
-        Whether the integration is enabled or not
+        Name of the integration.
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "name")
+
+    @property
+    @pulumi.getter(name="sharedSecret")
+    def shared_secret(self) -> pulumi.Output[Optional[str]]:
+        return pulumi.get(self, "shared_secret")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
+    def url(self) -> pulumi.Output[Optional[str]]:
         """
-        Name of the integration
+        The URL to request
         """
-        return pulumi.get(self, "name")
+        return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/org_token.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/org_token.py`

 * *Files 15% similar despite different names*

```diff
@@ -22,20 +22,20 @@
                  dpm_limits: Optional[pulumi.Input['OrgTokenDpmLimitsArgs']] = None,
                  host_or_usage_limits: Optional[pulumi.Input['OrgTokenHostOrUsageLimitsArgs']] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
         The set of arguments for constructing a OrgToken resource.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] auth_scopes: Authentication scope, ex: INGEST, API, RUM ... (Optional)
-        :param pulumi.Input[str] description: Description of the token (Optional)
-        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-               Defaults to `false`
-        :param pulumi.Input[str] name: Name of the token
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See
-               https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        :param pulumi.Input[str] description: Description of the token.
+        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
+        :param pulumi.Input['OrgTokenDpmLimitsArgs'] dpm_limits: Specify DPM-based limits for this token.
+        :param pulumi.Input['OrgTokenHostOrUsageLimitsArgs'] host_or_usage_limits: Specify Usage-based limits for this token.
+        :param pulumi.Input[str] name: Name of the token.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
         """
         if auth_scopes is not None:
             pulumi.set(__self__, "auth_scopes", auth_scopes)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if disabled is not None:
             pulumi.set(__self__, "disabled", disabled)
@@ -60,71 +60,75 @@
     def auth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "auth_scopes", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the token (Optional)
+        Description of the token.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def disabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-        Defaults to `false`
+        Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
         """
         return pulumi.get(self, "disabled")
 
     @disabled.setter
     def disabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disabled", value)
 
     @property
     @pulumi.getter(name="dpmLimits")
     def dpm_limits(self) -> Optional[pulumi.Input['OrgTokenDpmLimitsArgs']]:
+        """
+        Specify DPM-based limits for this token.
+        """
         return pulumi.get(self, "dpm_limits")
 
     @dpm_limits.setter
     def dpm_limits(self, value: Optional[pulumi.Input['OrgTokenDpmLimitsArgs']]):
         pulumi.set(self, "dpm_limits", value)
 
     @property
     @pulumi.getter(name="hostOrUsageLimits")
     def host_or_usage_limits(self) -> Optional[pulumi.Input['OrgTokenHostOrUsageLimitsArgs']]:
+        """
+        Specify Usage-based limits for this token.
+        """
         return pulumi.get(self, "host_or_usage_limits")
 
     @host_or_usage_limits.setter
     def host_or_usage_limits(self, value: Optional[pulumi.Input['OrgTokenHostOrUsageLimitsArgs']]):
         pulumi.set(self, "host_or_usage_limits", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the token
+        Name of the token.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See
-        https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
         """
         return pulumi.get(self, "notifications")
 
     @notifications.setter
     def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications", value)
 
@@ -139,20 +143,21 @@
                  host_or_usage_limits: Optional[pulumi.Input['OrgTokenHostOrUsageLimitsArgs']] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  notifications: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  secret: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering OrgToken resources.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] auth_scopes: Authentication scope, ex: INGEST, API, RUM ... (Optional)
-        :param pulumi.Input[str] description: Description of the token (Optional)
-        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-               Defaults to `false`
-        :param pulumi.Input[str] name: Name of the token
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See
-               https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        :param pulumi.Input[str] description: Description of the token.
+        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
+        :param pulumi.Input['OrgTokenDpmLimitsArgs'] dpm_limits: Specify DPM-based limits for this token.
+        :param pulumi.Input['OrgTokenHostOrUsageLimitsArgs'] host_or_usage_limits: Specify Usage-based limits for this token.
+        :param pulumi.Input[str] name: Name of the token.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
+        :param pulumi.Input[str] secret: The secret token created by the API. You cannot set this value.
         """
         if auth_scopes is not None:
             pulumi.set(__self__, "auth_scopes", auth_scopes)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if disabled is not None:
             pulumi.set(__self__, "disabled", disabled)
@@ -179,81 +184,88 @@
     def auth_scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "auth_scopes", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the token (Optional)
+        Description of the token.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def disabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-        Defaults to `false`
+        Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
         """
         return pulumi.get(self, "disabled")
 
     @disabled.setter
     def disabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disabled", value)
 
     @property
     @pulumi.getter(name="dpmLimits")
     def dpm_limits(self) -> Optional[pulumi.Input['OrgTokenDpmLimitsArgs']]:
+        """
+        Specify DPM-based limits for this token.
+        """
         return pulumi.get(self, "dpm_limits")
 
     @dpm_limits.setter
     def dpm_limits(self, value: Optional[pulumi.Input['OrgTokenDpmLimitsArgs']]):
         pulumi.set(self, "dpm_limits", value)
 
     @property
     @pulumi.getter(name="hostOrUsageLimits")
     def host_or_usage_limits(self) -> Optional[pulumi.Input['OrgTokenHostOrUsageLimitsArgs']]:
+        """
+        Specify Usage-based limits for this token.
+        """
         return pulumi.get(self, "host_or_usage_limits")
 
     @host_or_usage_limits.setter
     def host_or_usage_limits(self, value: Optional[pulumi.Input['OrgTokenHostOrUsageLimitsArgs']]):
         pulumi.set(self, "host_or_usage_limits", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the token
+        Name of the token.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def notifications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See
-        https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
         """
         return pulumi.get(self, "notifications")
 
     @notifications.setter
     def notifications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications", value)
 
     @property
     @pulumi.getter
     def secret(self) -> Optional[pulumi.Input[str]]:
+        """
+        The secret token created by the API. You cannot set this value.
+        """
         return pulumi.get(self, "secret")
 
     @secret.setter
     def secret(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "secret", value)
 
 
@@ -273,95 +285,37 @@
         """
         Manage Splunk Observability Cloud org tokens.
 
         > **NOTE** When managing Org tokens, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the token.
-        * `description` - (Optional) Description of the token.
-        * `disabled` - (Optional) Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
-        * `secret` - The secret token created by the API. You cannot set this value.
-        * `notifications` - (Optional) Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
-        * `host_or_usage_limits` - (Optional) Specify Usage-based limits for this token.
-          * `host_limit` - (Optional) Max number of hosts that can use this token
-          * `host_notification_threshold` - (Optional) Notification threshold for hosts
-          * `container_limit` - (Optional) Max number of Docker containers that can use this token
-          * `container_notification_threshold` - (Optional) Notification threshold for Docker containers
-          * `custom_metrics_limit` - (Optional) Max number of custom metrics that can be sent with this token
-          * `custom_metrics_notification_threshold` - (Optional) Notification threshold for custom metrics
-          * `high_res_metrics_limit` - (Optional) Max number of hi-res metrics that can be sent with this toke
-          * `high_res_metrics_notification_threshold` - (Optional) Notification threshold for hi-res metrics
-        * `dpm_limits` (Optional) Specify DPM-based limits for this token.
-          * `dpm_notification_threshold` - (Optional) DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
-          * `dpm_limit` - (Required) The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the token.
-        * `secret` - The assigned token.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] auth_scopes: Authentication scope, ex: INGEST, API, RUM ... (Optional)
-        :param pulumi.Input[str] description: Description of the token (Optional)
-        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-               Defaults to `false`
-        :param pulumi.Input[str] name: Name of the token
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See
-               https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        :param pulumi.Input[str] description: Description of the token.
+        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
+        :param pulumi.Input[pulumi.InputType['OrgTokenDpmLimitsArgs']] dpm_limits: Specify DPM-based limits for this token.
+        :param pulumi.Input[pulumi.InputType['OrgTokenHostOrUsageLimitsArgs']] host_or_usage_limits: Specify Usage-based limits for this token.
+        :param pulumi.Input[str] name: Name of the token.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: Optional[OrgTokenArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Manage Splunk Observability Cloud org tokens.
 
         > **NOTE** When managing Org tokens, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the token.
-        * `description` - (Optional) Description of the token.
-        * `disabled` - (Optional) Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
-        * `secret` - The secret token created by the API. You cannot set this value.
-        * `notifications` - (Optional) Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
-        * `host_or_usage_limits` - (Optional) Specify Usage-based limits for this token.
-          * `host_limit` - (Optional) Max number of hosts that can use this token
-          * `host_notification_threshold` - (Optional) Notification threshold for hosts
-          * `container_limit` - (Optional) Max number of Docker containers that can use this token
-          * `container_notification_threshold` - (Optional) Notification threshold for Docker containers
-          * `custom_metrics_limit` - (Optional) Max number of custom metrics that can be sent with this token
-          * `custom_metrics_notification_threshold` - (Optional) Notification threshold for custom metrics
-          * `high_res_metrics_limit` - (Optional) Max number of hi-res metrics that can be sent with this toke
-          * `high_res_metrics_notification_threshold` - (Optional) Notification threshold for hi-res metrics
-        * `dpm_limits` (Optional) Specify DPM-based limits for this token.
-          * `dpm_notification_threshold` - (Optional) DPM level at which Splunk Observability Cloud sends the notification for this token. If you don't specify a notification, Splunk Observability Cloud sends the generic notification.
-          * `dpm_limit` - (Required) The datapoints per minute (dpm) limit for this token. If you exceed this limit, Splunk Observability Cloud sends out an alert.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the token.
-        * `secret` - The assigned token.
-
         :param str resource_name: The name of the resource.
         :param OrgTokenArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(OrgTokenArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -421,20 +375,21 @@
         Get an existing OrgToken resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] auth_scopes: Authentication scope, ex: INGEST, API, RUM ... (Optional)
-        :param pulumi.Input[str] description: Description of the token (Optional)
-        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-               Defaults to `false`
-        :param pulumi.Input[str] name: Name of the token
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: List of strings specifying where notifications will be sent when an incident occurs. See
-               https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        :param pulumi.Input[str] description: Description of the token.
+        :param pulumi.Input[bool] disabled: Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
+        :param pulumi.Input[pulumi.InputType['OrgTokenDpmLimitsArgs']] dpm_limits: Specify DPM-based limits for this token.
+        :param pulumi.Input[pulumi.InputType['OrgTokenHostOrUsageLimitsArgs']] host_or_usage_limits: Specify Usage-based limits for this token.
+        :param pulumi.Input[str] name: Name of the token.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications: Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
+        :param pulumi.Input[str] secret: The secret token created by the API. You cannot set this value.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _OrgTokenState.__new__(_OrgTokenState)
 
         __props__.__dict__["auth_scopes"] = auth_scopes
         __props__.__dict__["description"] = description
@@ -454,52 +409,59 @@
         """
         return pulumi.get(self, "auth_scopes")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the token (Optional)
+        Description of the token.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def disabled(self) -> pulumi.Output[Optional[bool]]:
         """
-        Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication.
-        Defaults to `false`
+        Flag that controls enabling the token. If set to `true`, the token is disabled, and you can't use it for authentication. Defaults to `false`.
         """
         return pulumi.get(self, "disabled")
 
     @property
     @pulumi.getter(name="dpmLimits")
     def dpm_limits(self) -> pulumi.Output[Optional['outputs.OrgTokenDpmLimits']]:
+        """
+        Specify DPM-based limits for this token.
+        """
         return pulumi.get(self, "dpm_limits")
 
     @property
     @pulumi.getter(name="hostOrUsageLimits")
     def host_or_usage_limits(self) -> pulumi.Output[Optional['outputs.OrgTokenHostOrUsageLimits']]:
+        """
+        Specify Usage-based limits for this token.
+        """
         return pulumi.get(self, "host_or_usage_limits")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the token
+        Name of the token.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def notifications(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See
-        https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        Where to send notifications about this token's limits. See the Notification Format laid out in detectors.
         """
         return pulumi.get(self, "notifications")
 
     @property
     @pulumi.getter
     def secret(self) -> pulumi.Output[str]:
+        """
+        The secret token created by the API. You cannot set this value.
+        """
         return pulumi.get(self, "secret")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/outputs.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/outputs.py`

 * *Files 16% similar despite different names*

```diff
@@ -85,44 +85,44 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  property: str,
                  property_value: str,
                  negated: Optional[bool] = None):
         """
-        :param str property: the property to filter by
-        :param str property_value: the value of the property to filter by
-        :param bool negated: (false by default) whether this filter should be a "not" filter
+        :param str property: The property to filter.
+        :param str property_value: The property value to filter.
+        :param bool negated: Determines if this is a "not" filter. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "property_value", property_value)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter(name="propertyValue")
     def property_value(self) -> str:
         """
-        the value of the property to filter by
+        The property value to filter.
         """
         return pulumi.get(self, "property_value")
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[bool]:
         """
-        (false by default) whether this filter should be a "not" filter
+        Determines if this is a "not" filter. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        the property to filter by
+        The property to filter.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class DashboardChart(dict):
     @staticmethod
@@ -145,19 +145,19 @@
     def __init__(__self__, *,
                  chart_id: str,
                  column: Optional[int] = None,
                  height: Optional[int] = None,
                  row: Optional[int] = None,
                  width: Optional[int] = None):
         """
-        :param str chart_id: ID of the chart to display
-        :param int column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
-        :param int height: How many rows the chart should take up. (greater than or equal to 1)
-        :param int row: The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
-        :param int width: How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
+        :param str chart_id: ID of the chart to display.
+        :param int column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
+        :param int height: How many rows the chart should take up (greater than or equal to `1`). `1` by default.
+        :param int row: The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
+        :param int width: How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
         """
         pulumi.set(__self__, "chart_id", chart_id)
         if column is not None:
             pulumi.set(__self__, "column", column)
         if height is not None:
             pulumi.set(__self__, "height", height)
         if row is not None:
@@ -165,47 +165,47 @@
         if width is not None:
             pulumi.set(__self__, "width", width)
 
     @property
     @pulumi.getter(name="chartId")
     def chart_id(self) -> str:
         """
-        ID of the chart to display
+        ID of the chart to display.
         """
         return pulumi.get(self, "chart_id")
 
     @property
     @pulumi.getter
     def column(self) -> Optional[int]:
         """
-        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
+        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart (between `0` and `11`).
         """
         return pulumi.get(self, "column")
 
     @property
     @pulumi.getter
     def height(self) -> Optional[int]:
         """
-        How many rows the chart should take up. (greater than or equal to 1)
+        How many rows the chart should take up (greater than or equal to `1`). `1` by default.
         """
         return pulumi.get(self, "height")
 
     @property
     @pulumi.getter
     def row(self) -> Optional[int]:
         """
-        The row to show the chart in (zero-based); if height > 1, this value represents the topmost row of the chart. (greater than or equal to 0)
+        The row to show the chart in (zero-based); if `height > 1`, this value represents the topmost row of the chart (greater than or equal to `0`).
         """
         return pulumi.get(self, "row")
 
     @property
     @pulumi.getter
     def width(self) -> Optional[int]:
         """
-        How many columns (out of a total of 12, one-based) the chart should take up. (between 1 and 12)
+        How many columns (out of a total of 12) the chart should take up (between `1` and `12`). `12` by default.
         """
         return pulumi.get(self, "width")
 
 
 @pulumi.output_type
 class DashboardColumn(dict):
     @staticmethod
@@ -227,75 +227,76 @@
 
     def __init__(__self__, *,
                  chart_ids: Sequence[str],
                  column: Optional[int] = None,
                  height: Optional[int] = None,
                  width: Optional[int] = None):
         """
-        :param Sequence[str] chart_ids: Charts to use for the column
-        :param int column: The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
-        :param int height: How many rows each chart should take up. (greater than or equal to 1)
-        :param int width: Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
+        :param Sequence[str] chart_ids: List of IDs of the charts to display.
+        :param int column: Column number for the layout.
+        :param int height: How many rows every chart should take up (greater than or equal to 1). 1 by default.
+        :param int width: How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
         """
         pulumi.set(__self__, "chart_ids", chart_ids)
         if column is not None:
             pulumi.set(__self__, "column", column)
         if height is not None:
             pulumi.set(__self__, "height", height)
         if width is not None:
             pulumi.set(__self__, "width", width)
 
     @property
     @pulumi.getter(name="chartIds")
     def chart_ids(self) -> Sequence[str]:
         """
-        Charts to use for the column
+        List of IDs of the charts to display.
         """
         return pulumi.get(self, "chart_ids")
 
     @property
     @pulumi.getter
     def column(self) -> Optional[int]:
         """
-        The column to show the chart in (zero-based); this value always represents the leftmost column of the chart. (between 0 and 11)
+        Column number for the layout.
         """
         return pulumi.get(self, "column")
 
     @property
     @pulumi.getter
     def height(self) -> Optional[int]:
         """
-        How many rows each chart should take up. (greater than or equal to 1)
+        How many rows every chart should take up (greater than or equal to 1). 1 by default.
         """
         return pulumi.get(self, "height")
 
     @property
     @pulumi.getter
     def width(self) -> Optional[int]:
         """
-        Number of columns (out of a total of 12) each chart should take up. (between 1 and 12)
+        How many columns (out of a total of `12`) every chart should take up (between `1` and `12`). `12` by default.
         """
         return pulumi.get(self, "width")
 
 
 @pulumi.output_type
 class DashboardEventOverlay(dict):
     def __init__(__self__, *,
                  signal: str,
                  color: Optional[str] = None,
                  label: Optional[str] = None,
                  line: Optional[bool] = None,
                  sources: Optional[Sequence['outputs.DashboardEventOverlaySource']] = None,
                  type: Optional[str] = None):
         """
-        :param str signal: Search term used to define events
-        :param str color: Color to use
-        :param str label: The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
-        :param bool line: (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
-        :param str type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        :param str signal: Search term used to choose the events shown in the overlay.
+        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
+        :param str label: Text shown in the dropdown when selecting this overlay from the menu.
+        :param bool line: Show a vertical line for the event. `false` by default.
+        :param Sequence['DashboardEventOverlaySourceArgs'] sources: Each element specifies a filter to use against the signal specified in the `signal`.
+        :param str type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         pulumi.set(__self__, "signal", signal)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if label is not None:
             pulumi.set(__self__, "label", label)
         if line is not None:
@@ -305,93 +306,96 @@
         if type is not None:
             pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def signal(self) -> str:
         """
-        Search term used to define events
+        Search term used to choose the events shown in the overlay.
         """
         return pulumi.get(self, "signal")
 
     @property
     @pulumi.getter
     def color(self) -> Optional[str]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter
     def label(self) -> Optional[str]:
         """
-        The text displaying in the dropdown menu used to select this event overlay as an active overlay for the dashboard.
+        Text shown in the dropdown when selecting this overlay from the menu.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter
     def line(self) -> Optional[bool]:
         """
-        (false by default) Whether a vertical line should be displayed in the plot at the time the event occurs
+        Show a vertical line for the event. `false` by default.
         """
         return pulumi.get(self, "line")
 
     @property
     @pulumi.getter
     def sources(self) -> Optional[Sequence['outputs.DashboardEventOverlaySource']]:
+        """
+        Each element specifies a filter to use against the signal specified in the `signal`.
+        """
         return pulumi.get(self, "sources")
 
     @property
     @pulumi.getter
     def type(self) -> Optional[str]:
         """
-        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         return pulumi.get(self, "type")
 
 
 @pulumi.output_type
 class DashboardEventOverlaySource(dict):
     def __init__(__self__, *,
                  property: str,
                  values: Sequence[str],
                  negated: Optional[bool] = None):
         """
-        :param str property: A metric time series dimension or property name
-        :param Sequence[str] values: List of strings (which will be treated as an OR filter on the property)
-        :param bool negated: (false by default) Whether this filter should be a "not" filter
+        :param str property: The name of a dimension to filter against.
+        :param Sequence[str] values: A list of values to be used with the `property`, they will be combined via `OR`.
+        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> Sequence[str]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        A list of values to be used with the `property`, they will be combined via `OR`.
         """
         return pulumi.get(self, "values")
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[bool]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        A metric time series dimension or property name
+        The name of a dimension to filter against.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class DashboardFilter(dict):
     @staticmethod
@@ -413,55 +417,55 @@
 
     def __init__(__self__, *,
                  property: str,
                  values: Sequence[str],
                  apply_if_exist: Optional[bool] = None,
                  negated: Optional[bool] = None):
         """
-        :param str property: A metric time series dimension or property name
-        :param Sequence[str] values: List of strings (which will be treated as an OR filter on the property)
-        :param bool apply_if_exist: If true, this filter will also match data that does not have the specified property
-        :param bool negated: (false by default) Whether this filter should be a "not" filter
+        :param str property: A metric time series dimension or property name.
+        :param Sequence[str] values: List of of strings (which will be treated as an OR filter on the property).
+        :param bool apply_if_exist: If true, this filter will also match data that doesn't have this property at all.
+        :param bool negated: Whether this filter should be a not filter. `false` by default.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if apply_if_exist is not None:
             pulumi.set(__self__, "apply_if_exist", apply_if_exist)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> Sequence[str]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        List of of strings (which will be treated as an OR filter on the property).
         """
         return pulumi.get(self, "values")
 
     @property
     @pulumi.getter(name="applyIfExist")
     def apply_if_exist(self) -> Optional[bool]:
         """
-        If true, this filter will also match data that does not have the specified property
+        If true, this filter will also match data that doesn't have this property at all.
         """
         return pulumi.get(self, "apply_if_exist")
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[bool]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        Whether this filter should be a not filter. `false` by default.
         """
         return pulumi.get(self, "negated")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        A metric time series dimension or property name
+        A metric time series dimension or property name.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class DashboardGrid(dict):
     @staticmethod
@@ -482,45 +486,45 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  chart_ids: Sequence[str],
                  height: Optional[int] = None,
                  width: Optional[int] = None):
         """
-        :param Sequence[str] chart_ids: Charts to use for the grid
-        :param int height: How many rows each chart should take up. (greater than or equal to 1)
-        :param int width: Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
+        :param Sequence[str] chart_ids: List of IDs of the charts to display.
+        :param int height: How many rows every chart should take up (greater than or equal to `1`). `1` by default.
+        :param int width: How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
         """
         pulumi.set(__self__, "chart_ids", chart_ids)
         if height is not None:
             pulumi.set(__self__, "height", height)
         if width is not None:
             pulumi.set(__self__, "width", width)
 
     @property
     @pulumi.getter(name="chartIds")
     def chart_ids(self) -> Sequence[str]:
         """
-        Charts to use for the grid
+        List of IDs of the charts to display.
         """
         return pulumi.get(self, "chart_ids")
 
     @property
     @pulumi.getter
     def height(self) -> Optional[int]:
         """
-        How many rows each chart should take up. (greater than or equal to 1)
+        How many rows every chart should take up (greater than or equal to `1`). `1` by default.
         """
         return pulumi.get(self, "height")
 
     @property
     @pulumi.getter
     def width(self) -> Optional[int]:
         """
-        Number of columns (out of a total of 12, one-based) each chart should take up. (between 1 and 12)
+        How many columns (out of a total of 12) every chart should take up (between `1` and `12`). `12` by default.
         """
         return pulumi.get(self, "width")
 
 
 @pulumi.output_type
 class DashboardGroupDashboard(dict):
     @staticmethod
@@ -554,19 +558,19 @@
                  dashboard_id: str,
                  config_id: Optional[str] = None,
                  description_override: Optional[str] = None,
                  filter_overrides: Optional[Sequence['outputs.DashboardGroupDashboardFilterOverride']] = None,
                  name_override: Optional[str] = None,
                  variable_overrides: Optional[Sequence['outputs.DashboardGroupDashboardVariableOverride']] = None):
         """
-        :param str dashboard_id: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param str config_id: Unique identifier of an association between a dashboard group and a dashboard
-        :param str description_override: String that provides a description override for a mirrored dashboard
-        :param Sequence['DashboardGroupDashboardFilterOverrideArgs'] filter_overrides: Filter to apply to each chart in the dashboard
-        :param str name_override: String that provides a name override for a mirrored dashboard
+        :param str dashboard_id: The dashboard id to mirror
+        :param str config_id: The ID of the association between the dashboard group and the dashboard
+        :param str description_override: The description that will override the original dashboards's description.
+        :param Sequence['DashboardGroupDashboardFilterOverrideArgs'] filter_overrides: The description that will override the original dashboards's description.
+        :param str name_override: The name that will override the original dashboards's name.
         :param Sequence['DashboardGroupDashboardVariableOverrideArgs'] variable_overrides: Dashboard variable to apply to each chart in the dashboard
         """
         pulumi.set(__self__, "dashboard_id", dashboard_id)
         if config_id is not None:
             pulumi.set(__self__, "config_id", config_id)
         if description_override is not None:
             pulumi.set(__self__, "description_override", description_override)
@@ -577,47 +581,47 @@
         if variable_overrides is not None:
             pulumi.set(__self__, "variable_overrides", variable_overrides)
 
     @property
     @pulumi.getter(name="dashboardId")
     def dashboard_id(self) -> str:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        The dashboard id to mirror
         """
         return pulumi.get(self, "dashboard_id")
 
     @property
     @pulumi.getter(name="configId")
     def config_id(self) -> Optional[str]:
         """
-        Unique identifier of an association between a dashboard group and a dashboard
+        The ID of the association between the dashboard group and the dashboard
         """
         return pulumi.get(self, "config_id")
 
     @property
     @pulumi.getter(name="descriptionOverride")
     def description_override(self) -> Optional[str]:
         """
-        String that provides a description override for a mirrored dashboard
+        The description that will override the original dashboards's description.
         """
         return pulumi.get(self, "description_override")
 
     @property
     @pulumi.getter(name="filterOverrides")
     def filter_overrides(self) -> Optional[Sequence['outputs.DashboardGroupDashboardFilterOverride']]:
         """
-        Filter to apply to each chart in the dashboard
+        The description that will override the original dashboards's description.
         """
         return pulumi.get(self, "filter_overrides")
 
     @property
     @pulumi.getter(name="nameOverride")
     def name_override(self) -> Optional[str]:
         """
-        String that provides a name override for a mirrored dashboard
+        The name that will override the original dashboards's name.
         """
         return pulumi.get(self, "name_override")
 
     @property
     @pulumi.getter(name="variableOverrides")
     def variable_overrides(self) -> Optional[Sequence['outputs.DashboardGroupDashboardVariableOverride']]:
         """
@@ -629,44 +633,44 @@
 @pulumi.output_type
 class DashboardGroupDashboardFilterOverride(dict):
     def __init__(__self__, *,
                  property: str,
                  values: Sequence[str],
                  negated: Optional[bool] = None):
         """
-        :param str property: A metric time series dimension or property name
-        :param Sequence[str] values: List of strings (which will be treated as an OR filter on the property)
-        :param bool negated: (false by default) Whether this filter should be a "not" filter
+        :param str property: A metric time series dimension or property name.
+        :param Sequence[str] values: (Optional) List of of strings (which will be treated as an OR filter on the property).
+        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> Sequence[str]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        (Optional) List of of strings (which will be treated as an OR filter on the property).
         """
         return pulumi.get(self, "values")
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[bool]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        A metric time series dimension or property name
+        A metric time series dimension or property name.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class DashboardGroupDashboardVariableOverride(dict):
     @staticmethod
@@ -816,75 +820,75 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  principal_id: str,
                  principal_type: str,
                  actions: Optional[Sequence[str]] = None):
         """
-        :param str principal_id: ID of the principal with access
-        :param str principal_type: Type of principal, possible values: ORG, TEAM, USER
-        :param Sequence[str] actions: Actions level, possible values: READ, WRITE
+        :param str principal_id: ID of the user, team, or organization for which you're granting permissions.
+        :param str principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
+        :param Sequence[str] actions: Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
         """
         pulumi.set(__self__, "principal_id", principal_id)
         pulumi.set(__self__, "principal_type", principal_type)
         if actions is not None:
             pulumi.set(__self__, "actions", actions)
 
     @property
     @pulumi.getter(name="principalId")
     def principal_id(self) -> str:
         """
-        ID of the principal with access
+        ID of the user, team, or organization for which you're granting permissions.
         """
         return pulumi.get(self, "principal_id")
 
     @property
     @pulumi.getter(name="principalType")
     def principal_type(self) -> str:
         """
-        Type of principal, possible values: ORG, TEAM, USER
+        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
         """
         return pulumi.get(self, "principal_type")
 
     @property
     @pulumi.getter
     def actions(self) -> Optional[Sequence[str]]:
         """
-        Actions level, possible values: READ, WRITE
+        Action the user, team, or organization can take with the dashboard group. List of values (value can be "READ" or "WRITE").
         """
         return pulumi.get(self, "actions")
 
 
 @pulumi.output_type
 class DashboardPermissions(dict):
     def __init__(__self__, *,
                  acls: Optional[Sequence['outputs.DashboardPermissionsAcl']] = None,
                  parent: Optional[str] = None):
         """
-        :param Sequence['DashboardPermissionsAclArgs'] acls: The custom access control list for this dashboard
-        :param str parent: The ID of the dashboard group that this dashboard inherits permissions from
+        :param Sequence['DashboardPermissionsAclArgs'] acls: List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
+        :param str parent: ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
         """
         if acls is not None:
             pulumi.set(__self__, "acls", acls)
         if parent is not None:
             pulumi.set(__self__, "parent", parent)
 
     @property
     @pulumi.getter
     def acls(self) -> Optional[Sequence['outputs.DashboardPermissionsAcl']]:
         """
-        The custom access control list for this dashboard
+        List of read and write permission configurations to specify which user, team, and organization can view and/or edit your dashboard. Use the `permissions.parent` instead if you want to inherit permissions.
         """
         return pulumi.get(self, "acls")
 
     @property
     @pulumi.getter
     def parent(self) -> Optional[str]:
         """
-        The ID of the dashboard group that this dashboard inherits permissions from
+        ID of the dashboard group you want your dashboard to inherit permissions from. Use the `permissions.acl` instead if you want to specify various read and write permission configurations.
         """
         return pulumi.get(self, "parent")
 
 
 @pulumi.output_type
 class DashboardPermissionsAcl(dict):
     @staticmethod
@@ -907,123 +911,127 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  principal_id: str,
                  principal_type: str,
                  actions: Optional[Sequence[str]] = None):
         """
-        :param str principal_id: ID of the principal with access
-        :param str principal_type: Type of principal, possible values: ORG, TEAM, USER
-        :param Sequence[str] actions: Actions level, possible values: READ, WRITE
+        :param str principal_id: ID of the user, team, or organization for which you're granting permissions.
+        :param str principal_type: Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
+        :param Sequence[str] actions: Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
         """
         pulumi.set(__self__, "principal_id", principal_id)
         pulumi.set(__self__, "principal_type", principal_type)
         if actions is not None:
             pulumi.set(__self__, "actions", actions)
 
     @property
     @pulumi.getter(name="principalId")
     def principal_id(self) -> str:
         """
-        ID of the principal with access
+        ID of the user, team, or organization for which you're granting permissions.
         """
         return pulumi.get(self, "principal_id")
 
     @property
     @pulumi.getter(name="principalType")
     def principal_type(self) -> str:
         """
-        Type of principal, possible values: ORG, TEAM, USER
+        Clarify whether this permission configuration is for a user, a team, or an organization. Value can be one of "USER", "TEAM", or "ORG".
         """
         return pulumi.get(self, "principal_type")
 
     @property
     @pulumi.getter
     def actions(self) -> Optional[Sequence[str]]:
         """
-        Actions level, possible values: READ, WRITE
+        Action the user, team, or organization can take with the dashboard. List of values (value can be "READ" or "WRITE").
         """
         return pulumi.get(self, "actions")
 
 
 @pulumi.output_type
 class DashboardSelectedEventOverlay(dict):
     def __init__(__self__, *,
                  signal: str,
                  sources: Optional[Sequence['outputs.DashboardSelectedEventOverlaySource']] = None,
                  type: Optional[str] = None):
         """
-        :param str signal: Search term used to define events
-        :param str type: Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        :param str signal: Search term used to choose the events shown in the overlay.
+        :param Sequence['DashboardSelectedEventOverlaySourceArgs'] sources: Each element specifies a filter to use against the signal specified in the `signal`.
+        :param str type: Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         pulumi.set(__self__, "signal", signal)
         if sources is not None:
             pulumi.set(__self__, "sources", sources)
         if type is not None:
             pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def signal(self) -> str:
         """
-        Search term used to define events
+        Search term used to choose the events shown in the overlay.
         """
         return pulumi.get(self, "signal")
 
     @property
     @pulumi.getter
     def sources(self) -> Optional[Sequence['outputs.DashboardSelectedEventOverlaySource']]:
+        """
+        Each element specifies a filter to use against the signal specified in the `signal`.
+        """
         return pulumi.get(self, "sources")
 
     @property
     @pulumi.getter
     def type(self) -> Optional[str]:
         """
-        Source for this event's data. Can be "eventTimeSeries" (default) or "detectorEvents".
+        Can be set to `eventTimeSeries` (the default) to refer to externally reported events, or `detectorEvents` to refer to events from detector triggers.
         """
         return pulumi.get(self, "type")
 
 
 @pulumi.output_type
 class DashboardSelectedEventOverlaySource(dict):
     def __init__(__self__, *,
                  property: str,
                  values: Sequence[str],
                  negated: Optional[bool] = None):
         """
-        :param str property: A metric time series dimension or property name
-        :param Sequence[str] values: List of strings (which will be treated as an OR filter on the property)
-        :param bool negated: (false by default) Whether this filter should be a "not" filter
+        :param str property: The name of a dimension to filter against.
+        :param Sequence[str] values: A list of values to be used with the `property`, they will be combined via `OR`.
+        :param bool negated: If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "values", values)
         if negated is not None:
             pulumi.set(__self__, "negated", negated)
 
     @property
     @pulumi.getter
     def values(self) -> Sequence[str]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        A list of values to be used with the `property`, they will be combined via `OR`.
         """
         return pulumi.get(self, "values")
 
     @property
     @pulumi.getter
     def negated(self) -> Optional[bool]:
         """
-        (false by default) Whether this filter should be a "not" filter
+        If true,  only data that does not match the specified value of the specified property appear in the event overlay. Defaults to `false`.
         """
         return pulumi.get(self, "negated")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        A metric time series dimension or property name
+        The name of a dimension to filter against.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class DashboardVariable(dict):
     @staticmethod
@@ -1058,23 +1066,23 @@
                  description: Optional[str] = None,
                  replace_only: Optional[bool] = None,
                  restricted_suggestions: Optional[bool] = None,
                  value_required: Optional[bool] = None,
                  values: Optional[Sequence[str]] = None,
                  values_suggesteds: Optional[Sequence[str]] = None):
         """
-        :param str alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
-        :param str property: A metric time series dimension or property name
-        :param bool apply_if_exist: If true, this variable will also match data that does not have the specified property
-        :param str description: Variable description
-        :param bool replace_only: If true, this variable will only apply to charts with a filter on the named property.
-        :param bool restricted_suggestions: If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
-        :param bool value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
-        :param Sequence[str] values: List of strings (which will be treated as an OR filter on the property)
-        :param Sequence[str] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
+        :param str alias: An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
+        :param str property: A metric time series dimension or property name.
+        :param bool apply_if_exist: If true, this variable will also match data that doesn't have this property at all.
+        :param str description: Variable description.
+        :param bool replace_only: If `true`, this variable will only apply to charts that have a filter for the property.
+        :param bool restricted_suggestions: If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
+        :param bool value_required: Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
+        :param Sequence[str] values: List of of strings (which will be treated as an OR filter on the property).
+        :param Sequence[str] values_suggesteds: A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
         """
         pulumi.set(__self__, "alias", alias)
         pulumi.set(__self__, "property", property)
         if apply_if_exist is not None:
             pulumi.set(__self__, "apply_if_exist", apply_if_exist)
         if description is not None:
             pulumi.set(__self__, "description", description)
@@ -1089,79 +1097,79 @@
         if values_suggesteds is not None:
             pulumi.set(__self__, "values_suggesteds", values_suggesteds)
 
     @property
     @pulumi.getter
     def alias(self) -> str:
         """
-        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard
+        An alias for the dashboard variable. This text will appear as the label for the dropdown field on the dashboard.
         """
         return pulumi.get(self, "alias")
 
     @property
     @pulumi.getter(name="applyIfExist")
     def apply_if_exist(self) -> Optional[bool]:
         """
-        If true, this variable will also match data that does not have the specified property
+        If true, this variable will also match data that doesn't have this property at all.
         """
         return pulumi.get(self, "apply_if_exist")
 
     @property
     @pulumi.getter
     def description(self) -> Optional[str]:
         """
-        Variable description
+        Variable description.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="replaceOnly")
     def replace_only(self) -> Optional[bool]:
         """
-        If true, this variable will only apply to charts with a filter on the named property.
+        If `true`, this variable will only apply to charts that have a filter for the property.
         """
         return pulumi.get(self, "replace_only")
 
     @property
     @pulumi.getter(name="restrictedSuggestions")
     def restricted_suggestions(self) -> Optional[bool]:
         """
-        If true, this variable may only be set to the values listed in preferredSuggestions. and only these values will appear in autosuggestion menus. false by default
+        If `true`, this variable may only be set to the values listed in `values_suggested` and only these values will appear in autosuggestion menus. `false` by default.
         """
         return pulumi.get(self, "restricted_suggestions")
 
     @property
     @pulumi.getter(name="valueRequired")
     def value_required(self) -> Optional[bool]:
         """
-        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). false by default
+        Determines whether a value is required for this variable (and therefore whether it will be possible to view this dashboard without this filter applied). `false` by default.
         """
         return pulumi.get(self, "value_required")
 
     @property
     @pulumi.getter
     def values(self) -> Optional[Sequence[str]]:
         """
-        List of strings (which will be treated as an OR filter on the property)
+        List of of strings (which will be treated as an OR filter on the property).
         """
         return pulumi.get(self, "values")
 
     @property
     @pulumi.getter(name="valuesSuggesteds")
     def values_suggesteds(self) -> Optional[Sequence[str]]:
         """
-        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable
+        A list of strings of suggested values for this variable; these suggestions will receive priority when values are autosuggested for this variable.
         """
         return pulumi.get(self, "values_suggesteds")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        A metric time series dimension or property name
+        A metric time series dimension or property name.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class DataLinkTargetExternalUrl(dict):
     @staticmethod
@@ -1189,18 +1197,18 @@
                  name: str,
                  url: str,
                  minimum_time_window: Optional[str] = None,
                  property_key_mapping: Optional[Mapping[str, str]] = None,
                  time_format: Optional[str] = None):
         """
         :param str name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-        :param str url: URL string for a Splunk instance or external system data link target.
-        :param str minimum_time_window: The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
-        :param Mapping[str, str] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
-        :param str time_format: Designates the format of minimumTimeWindow in the same data link target object.
+        :param str url: URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
+        :param str minimum_time_window: The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
+        :param Mapping[str, str] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
+        :param str time_format: [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
         """
         pulumi.set(__self__, "name", name)
         pulumi.set(__self__, "url", url)
         if minimum_time_window is not None:
             pulumi.set(__self__, "minimum_time_window", minimum_time_window)
         if property_key_mapping is not None:
             pulumi.set(__self__, "property_key_mapping", property_key_mapping)
@@ -1215,39 +1223,39 @@
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def url(self) -> str:
         """
-        URL string for a Splunk instance or external system data link target.
+        URL string for a Splunk instance or external system data link target. [See the supported template variables](https://dev.splunk.com/observability/docs/administration/datalinks/).
         """
         return pulumi.get(self, "url")
 
     @property
     @pulumi.getter(name="minimumTimeWindow")
     def minimum_time_window(self) -> Optional[str]:
         """
-        The minimum time window for a search sent to an external site. Depends on the value set for `time_format`.
+        The [minimum time window](https://dev.splunk.com/observability/docs/administration/datalinks/) for a search sent to an external site. Defaults to `6000`
         """
         return pulumi.get(self, "minimum_time_window")
 
     @property
     @pulumi.getter(name="propertyKeyMapping")
     def property_key_mapping(self) -> Optional[Mapping[str, str]]:
         """
-        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
+        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
         """
         return pulumi.get(self, "property_key_mapping")
 
     @property
     @pulumi.getter(name="timeFormat")
     def time_format(self) -> Optional[str]:
         """
-        Designates the format of minimumTimeWindow in the same data link target object.
+        [Designates the format](https://dev.splunk.com/observability/docs/administration/datalinks/) of `minimum_time_window` in the same data link target object. Must be one of `"ISO8601"`, `"EpochSeconds"` or `"Epoch"` (which is milliseconds). Defaults to `"ISO8601"`.
         """
         return pulumi.get(self, "time_format")
 
 
 @pulumi.output_type
 class DataLinkTargetSignalfxDashboard(dict):
     @staticmethod
@@ -1276,15 +1284,15 @@
                  dashboard_id: str,
                  name: str,
                  is_default: Optional[bool] = None):
         """
         :param str dashboard_group_id: SignalFx-assigned ID of the dashboard link target's dashboard group
         :param str dashboard_id: SignalFx-assigned ID of the dashboard link target
         :param str name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-        :param bool is_default: Flag that designates a target as the default for a data link object.
+        :param bool is_default: Flag that designates a target as the default for a data link object. `true` by default
         """
         pulumi.set(__self__, "dashboard_group_id", dashboard_group_id)
         pulumi.set(__self__, "dashboard_id", dashboard_id)
         pulumi.set(__self__, "name", name)
         if is_default is not None:
             pulumi.set(__self__, "is_default", is_default)
 
@@ -1312,15 +1320,15 @@
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="isDefault")
     def is_default(self) -> Optional[bool]:
         """
-        Flag that designates a target as the default for a data link object.
+        Flag that designates a target as the default for a data link object. `true` by default
         """
         return pulumi.get(self, "is_default")
 
 
 @pulumi.output_type
 class DataLinkTargetSplunk(dict):
     @staticmethod
@@ -1341,15 +1349,15 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  name: str,
                  property_key_mapping: Optional[Mapping[str, str]] = None):
         """
         :param str name: User-assigned target name. Use this value to differentiate between the link targets for a data link object.
-        :param Mapping[str, str] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
+        :param Mapping[str, str] property_key_mapping: Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
         """
         pulumi.set(__self__, "name", name)
         if property_key_mapping is not None:
             pulumi.set(__self__, "property_key_mapping", property_key_mapping)
 
     @property
     @pulumi.getter
@@ -1359,15 +1367,15 @@
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="propertyKeyMapping")
     def property_key_mapping(self) -> Optional[Mapping[str, str]]:
         """
-        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different
+        Describes the relationship between Splunk Observability Cloud metadata keys and external system properties when the key names are different.
         """
         return pulumi.get(self, "property_key_mapping")
 
 
 @pulumi.output_type
 class DetectorRule(dict):
     @staticmethod
@@ -1400,23 +1408,23 @@
                  disabled: Optional[bool] = None,
                  notifications: Optional[Sequence[str]] = None,
                  parameterized_body: Optional[str] = None,
                  parameterized_subject: Optional[str] = None,
                  runbook_url: Optional[str] = None,
                  tip: Optional[str] = None):
         """
-        :param str detect_label: A detect label which matches a detect label within the program text
-        :param str severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
-        :param str description: Description of the rule
-        :param bool disabled: (default: false) When true, notifications and events will not be generated for the detect label
-        :param Sequence[str] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
-        :param str parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
-        :param str parameterized_subject: Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
-        :param str runbook_url: URL of page to consult when an alert is triggered
-        :param str tip: Plain text suggested first course of action, such as a command to execute.
+        :param str detect_label: A detect label which matches a detect label within `program_text`.
+        :param str severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
+        :param str description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
+        :param bool disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
+        :param Sequence[str] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
+        :param str parameterized_body: Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
+        :param str parameterized_subject: Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
+        :param str runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
+        :param str tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         pulumi.set(__self__, "detect_label", detect_label)
         pulumi.set(__self__, "severity", severity)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if disabled is not None:
             pulumi.set(__self__, "disabled", disabled)
@@ -1431,79 +1439,79 @@
         if tip is not None:
             pulumi.set(__self__, "tip", tip)
 
     @property
     @pulumi.getter(name="detectLabel")
     def detect_label(self) -> str:
         """
-        A detect label which matches a detect label within the program text
+        A detect label which matches a detect label within `program_text`.
         """
         return pulumi.get(self, "detect_label")
 
     @property
     @pulumi.getter
     def severity(self) -> str:
         """
-        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
+        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
         """
         return pulumi.get(self, "severity")
 
     @property
     @pulumi.getter
     def description(self) -> Optional[str]:
         """
-        Description of the rule
+        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def disabled(self) -> Optional[bool]:
         """
-        (default: false) When true, notifications and events will not be generated for the detect label
+        When true, notifications and events will not be generated for the detect label. `false` by default.
         """
         return pulumi.get(self, "disabled")
 
     @property
     @pulumi.getter
     def notifications(self) -> Optional[Sequence[str]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        List of strings specifying where notifications will be sent when an incident occurs. See [Create A Single Detector](https://dev.splunk.com/observability/reference/api/detectors/latest) for more info.
         """
         return pulumi.get(self, "notifications")
 
     @property
     @pulumi.getter(name="parameterizedBody")
     def parameterized_body(self) -> Optional[str]:
         """
-        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message body when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
         """
         return pulumi.get(self, "parameterized_body")
 
     @property
     @pulumi.getter(name="parameterizedSubject")
     def parameterized_subject(self) -> Optional[str]:
         """
-        Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message subject when an alert is triggered. See [Set Up Detectors to Trigger Alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html) for more info.
         """
         return pulumi.get(self, "parameterized_subject")
 
     @property
     @pulumi.getter(name="runbookUrl")
     def runbook_url(self) -> Optional[str]:
         """
-        URL of page to consult when an alert is triggered
+        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
         """
         return pulumi.get(self, "runbook_url")
 
     @property
     @pulumi.getter
     def tip(self) -> Optional[str]:
         """
-        Plain text suggested first course of action, such as a command to execute.
+        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         return pulumi.get(self, "tip")
 
 
 @pulumi.output_type
 class DetectorVizOption(dict):
     @staticmethod
@@ -1533,20 +1541,24 @@
                  label: str,
                  color: Optional[str] = None,
                  display_name: Optional[str] = None,
                  value_prefix: Optional[str] = None,
                  value_suffix: Optional[str] = None,
                  value_unit: Optional[str] = None):
         """
-        :param str label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param str color: Color to use
+        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param str value_prefix: An arbitrary prefix to display with the value of this plot
+        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
+               
+               **Notes**
+               
+               Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
         :param str value_suffix: An arbitrary suffix to display with the value of this plot
-        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
         if value_prefix is not None:
@@ -1556,23 +1568,23 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> str:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter
     def color(self) -> Optional[str]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter(name="displayName")
     def display_name(self) -> Optional[str]:
         """
@@ -1580,15 +1592,19 @@
         """
         return pulumi.get(self, "display_name")
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[str]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
+
+        **Notes**
+
+        Use both `max_delay` in your detector configuration and an `extrapolation` policy in your program text to reduce false positives and false negatives.
         """
         return pulumi.get(self, "value_prefix")
 
     @property
     @pulumi.getter(name="valueSuffix")
     def value_suffix(self) -> Optional[str]:
         """
@@ -1596,15 +1612,15 @@
         """
         return pulumi.get(self, "value_suffix")
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[str]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
 
 @pulumi.output_type
 class HeatmapChartColorRange(dict):
     @staticmethod
@@ -1628,16 +1644,16 @@
 
     def __init__(__self__, *,
                  color: str,
                  max_value: Optional[float] = None,
                  min_value: Optional[float] = None):
         """
         :param str color: The color range to use. The starting hex color value for data values in a heatmap chart. Specify the value as a 6-character hexadecimal value preceded by the '#' character, for example "#ea1849" (grass green).
-        :param float max_value: The maximum value within the coloring range
-        :param float min_value: The minimum value within the coloring range
+        :param float max_value: The maximum value within the coloring range.
+        :param float min_value: The minimum value within the coloring range.
         """
         pulumi.set(__self__, "color", color)
         if max_value is not None:
             pulumi.set(__self__, "max_value", max_value)
         if min_value is not None:
             pulumi.set(__self__, "min_value", min_value)
 
@@ -1649,41 +1665,41 @@
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter(name="maxValue")
     def max_value(self) -> Optional[float]:
         """
-        The maximum value within the coloring range
+        The maximum value within the coloring range.
         """
         return pulumi.get(self, "max_value")
 
     @property
     @pulumi.getter(name="minValue")
     def min_value(self) -> Optional[float]:
         """
-        The minimum value within the coloring range
+        The minimum value within the coloring range.
         """
         return pulumi.get(self, "min_value")
 
 
 @pulumi.output_type
 class HeatmapChartColorScale(dict):
     def __init__(__self__, *,
                  color: str,
                  gt: Optional[float] = None,
                  gte: Optional[float] = None,
                  lt: Optional[float] = None,
                  lte: Optional[float] = None):
         """
-        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        :param float gt: Indicates the lower threshold non-inclusive value for this range
-        :param float gte: Indicates the lower threshold inclusive value for this range
-        :param float lt: Indicates the upper threshold non-inculsive value for this range
-        :param float lte: Indicates the upper threshold inclusive value for this range
+        :param str color: The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
+        :param float gt: Indicates the lower threshold non-inclusive value for this range.
+        :param float gte: Indicates the lower threshold inclusive value for this range.
+        :param float lt: Indicates the upper threshold non-inclusive value for this range.
+        :param float lte: Indicates the upper threshold inclusive value for this range.
         """
         pulumi.set(__self__, "color", color)
         if gt is not None:
             pulumi.set(__self__, "gt", gt)
         if gte is not None:
             pulumi.set(__self__, "gte", gte)
         if lt is not None:
@@ -1691,65 +1707,65 @@
         if lte is not None:
             pulumi.set(__self__, "lte", lte)
 
     @property
     @pulumi.getter
     def color(self) -> str:
         """
-        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
+        The color range to use. Hex values are not supported here. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter
     def gt(self) -> Optional[float]:
         """
-        Indicates the lower threshold non-inclusive value for this range
+        Indicates the lower threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "gt")
 
     @property
     @pulumi.getter
     def gte(self) -> Optional[float]:
         """
-        Indicates the lower threshold inclusive value for this range
+        Indicates the lower threshold inclusive value for this range.
         """
         return pulumi.get(self, "gte")
 
     @property
     @pulumi.getter
     def lt(self) -> Optional[float]:
         """
-        Indicates the upper threshold non-inculsive value for this range
+        Indicates the upper threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "lt")
 
     @property
     @pulumi.getter
     def lte(self) -> Optional[float]:
         """
-        Indicates the upper threshold inclusive value for this range
+        Indicates the upper threshold inclusive value for this range.
         """
         return pulumi.get(self, "lte")
 
 
 @pulumi.output_type
 class ListChartColorScale(dict):
     def __init__(__self__, *,
                  color: str,
                  gt: Optional[float] = None,
                  gte: Optional[float] = None,
                  lt: Optional[float] = None,
                  lte: Optional[float] = None):
         """
         :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        :param float gt: Indicates the lower threshold non-inclusive value for this range
-        :param float gte: Indicates the lower threshold inclusive value for this range
-        :param float lt: Indicates the upper threshold non-inculsive value for this range
-        :param float lte: Indicates the upper threshold inclusive value for this range
+        :param float gt: Indicates the lower threshold non-inclusive value for this range.
+        :param float gte: Indicates the lower threshold inclusive value for this range.
+        :param float lt: Indicates the upper threshold non-inculsive value for this range.
+        :param float lte: Indicates the upper threshold inclusive value for this range.
         """
         pulumi.set(__self__, "color", color)
         if gt is not None:
             pulumi.set(__self__, "gt", gt)
         if gte is not None:
             pulumi.set(__self__, "gte", gte)
         if lt is not None:
@@ -1765,69 +1781,69 @@
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter
     def gt(self) -> Optional[float]:
         """
-        Indicates the lower threshold non-inclusive value for this range
+        Indicates the lower threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "gt")
 
     @property
     @pulumi.getter
     def gte(self) -> Optional[float]:
         """
-        Indicates the lower threshold inclusive value for this range
+        Indicates the lower threshold inclusive value for this range.
         """
         return pulumi.get(self, "gte")
 
     @property
     @pulumi.getter
     def lt(self) -> Optional[float]:
         """
-        Indicates the upper threshold non-inculsive value for this range
+        Indicates the upper threshold non-inculsive value for this range.
         """
         return pulumi.get(self, "lt")
 
     @property
     @pulumi.getter
     def lte(self) -> Optional[float]:
         """
-        Indicates the upper threshold inclusive value for this range
+        Indicates the upper threshold inclusive value for this range.
         """
         return pulumi.get(self, "lte")
 
 
 @pulumi.output_type
 class ListChartLegendOptionsField(dict):
     def __init__(__self__, *,
                  property: str,
                  enabled: Optional[bool] = None):
         """
-        :param str property: The name of a property to hide or show in the data table.
-        :param bool enabled: (true by default) Determines if this property is displayed in the data table.
+        :param str property: The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
+        :param bool enabled: True or False depending on if you want the property to be shown or hidden.
         """
         pulumi.set(__self__, "property", property)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[bool]:
         """
-        (true by default) Determines if this property is displayed in the data table.
+        True or False depending on if you want the property to be shown or hidden.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        The name of a property to hide or show in the data table.
+        The name of the property to display. Note the special values of `sf_metric` (corresponding with the API's `Plot Name`) which shows the label of the time series `publish()` and `sf_originatingMetric` (corresponding with the API's `metric (sf metric)`) that shows the [name of the metric](https://dev.splunk.com/observability/docs/signalflow/functions/data_function/) for the time series being displayed.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class ListChartVizOption(dict):
     @staticmethod
@@ -1857,20 +1873,20 @@
                  label: str,
                  color: Optional[str] = None,
                  display_name: Optional[str] = None,
                  value_prefix: Optional[str] = None,
                  value_suffix: Optional[str] = None,
                  value_unit: Optional[str] = None):
         """
-        :param str label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param str color: Color to use
+        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param str value_prefix: An arbitrary prefix to display with the value of this plot
+        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         :param str value_suffix: An arbitrary suffix to display with the value of this plot
-        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
         if value_prefix is not None:
@@ -1880,23 +1896,23 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> str:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter
     def color(self) -> Optional[str]:
         """
-        Color to use
+        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter(name="displayName")
     def display_name(self) -> Optional[str]:
         """
@@ -1904,15 +1920,15 @@
         """
         return pulumi.get(self, "display_name")
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[str]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         """
         return pulumi.get(self, "value_prefix")
 
     @property
     @pulumi.getter(name="valueSuffix")
     def value_suffix(self) -> Optional[str]:
         """
@@ -1920,67 +1936,67 @@
         """
         return pulumi.get(self, "value_suffix")
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[str]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
 
 @pulumi.output_type
 class MetricRulesetAggregationRule(dict):
     def __init__(__self__, *,
                  aggregators: Sequence['outputs.MetricRulesetAggregationRuleAggregator'],
                  enabled: bool,
                  matchers: Sequence['outputs.MetricRulesetAggregationRuleMatcher'],
                  name: Optional[str] = None):
         """
-        :param Sequence['MetricRulesetAggregationRuleAggregatorArgs'] aggregators: The aggregator for this rule
-        :param bool enabled: Status of this aggregation rule
-        :param Sequence['MetricRulesetAggregationRuleMatcherArgs'] matchers: The matcher for this rule
-        :param str name: Name of this aggregation rule
+        :param Sequence['MetricRulesetAggregationRuleAggregatorArgs'] aggregators: Aggregator object
+        :param bool enabled: When false, this rule will not generate aggregated MTSs
+        :param Sequence['MetricRulesetAggregationRuleMatcherArgs'] matchers: Matcher object
+        :param str name: name of the aggregation rule
         """
         pulumi.set(__self__, "aggregators", aggregators)
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "matchers", matchers)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def aggregators(self) -> Sequence['outputs.MetricRulesetAggregationRuleAggregator']:
         """
-        The aggregator for this rule
+        Aggregator object
         """
         return pulumi.get(self, "aggregators")
 
     @property
     @pulumi.getter
     def enabled(self) -> bool:
         """
-        Status of this aggregation rule
+        When false, this rule will not generate aggregated MTSs
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def matchers(self) -> Sequence['outputs.MetricRulesetAggregationRuleMatcher']:
         """
-        The matcher for this rule
+        Matcher object
         """
         return pulumi.get(self, "matchers")
 
     @property
     @pulumi.getter
     def name(self) -> Optional[str]:
         """
-        Name of this aggregation rule
+        name of the aggregation rule
         """
         return pulumi.get(self, "name")
 
 
 @pulumi.output_type
 class MetricRulesetAggregationRuleAggregator(dict):
     @staticmethod
@@ -2004,83 +2020,83 @@
 
     def __init__(__self__, *,
                  dimensions: Sequence[str],
                  drop_dimensions: bool,
                  output_name: str,
                  type: str):
         """
-        :param Sequence[str] dimensions: List of dimensions to keep or drop in aggregated metric
-        :param bool drop_dimensions: Flag specifying to keep or drop given dimensions
-        :param str output_name: The aggregated metric name
-        :param str type: The type of the aggregator
+        :param Sequence[str] dimensions: List of dimensions to either be kept or dropped in the new aggregated MTSs
+        :param bool drop_dimensions: when true, the specified dimensions will be dropped from the aggregated MTSs
+        :param str output_name: name of the new aggregated metric
+        :param str type: Type of aggregator. Must always be "rollup"
         """
         pulumi.set(__self__, "dimensions", dimensions)
         pulumi.set(__self__, "drop_dimensions", drop_dimensions)
         pulumi.set(__self__, "output_name", output_name)
         pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def dimensions(self) -> Sequence[str]:
         """
-        List of dimensions to keep or drop in aggregated metric
+        List of dimensions to either be kept or dropped in the new aggregated MTSs
         """
         return pulumi.get(self, "dimensions")
 
     @property
     @pulumi.getter(name="dropDimensions")
     def drop_dimensions(self) -> bool:
         """
-        Flag specifying to keep or drop given dimensions
+        when true, the specified dimensions will be dropped from the aggregated MTSs
         """
         return pulumi.get(self, "drop_dimensions")
 
     @property
     @pulumi.getter(name="outputName")
     def output_name(self) -> str:
         """
-        The aggregated metric name
+        name of the new aggregated metric
         """
         return pulumi.get(self, "output_name")
 
     @property
     @pulumi.getter
     def type(self) -> str:
         """
-        The type of the aggregator
+        Type of aggregator. Must always be "rollup"
         """
         return pulumi.get(self, "type")
 
 
 @pulumi.output_type
 class MetricRulesetAggregationRuleMatcher(dict):
     def __init__(__self__, *,
                  type: str,
                  filters: Optional[Sequence['outputs.MetricRulesetAggregationRuleMatcherFilter']] = None):
         """
-        :param str type: The type of the matcher
-        :param Sequence['MetricRulesetAggregationRuleMatcherFilterArgs'] filters: List of filters to match on
+        :param str type: Type of matcher. Must always be "dimension"
+        :param Sequence['MetricRulesetAggregationRuleMatcherFilterArgs'] filters: List of filters to filter the set of input MTSs
         """
         pulumi.set(__self__, "type", type)
         if filters is not None:
             pulumi.set(__self__, "filters", filters)
 
     @property
     @pulumi.getter
     def type(self) -> str:
         """
-        The type of the matcher
+        Type of matcher. Must always be "dimension"
         """
         return pulumi.get(self, "type")
 
     @property
     @pulumi.getter
     def filters(self) -> Optional[Sequence['outputs.MetricRulesetAggregationRuleMatcherFilter']]:
         """
-        List of filters to match on
+        List of filters to filter the set of input MTSs
         """
         return pulumi.get(self, "filters")
 
 
 @pulumi.output_type
 class MetricRulesetAggregationRuleMatcherFilter(dict):
     @staticmethod
@@ -2103,61 +2119,61 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  not_: bool,
                  property: str,
                  property_values: Sequence[str]):
         """
-        :param bool not_: Flag specifying equals or not equals
-        :param str property: Name of dimension to match
-        :param Sequence[str] property_values: List of property values to match
+        :param bool not_: When true, this filter will match all values not matching the property_values
+        :param str property: Name of the dimension
+        :param Sequence[str] property_values: Value of the dimension
         """
         pulumi.set(__self__, "not_", not_)
         pulumi.set(__self__, "property", property)
         pulumi.set(__self__, "property_values", property_values)
 
     @property
     @pulumi.getter(name="not")
     def not_(self) -> bool:
         """
-        Flag specifying equals or not equals
+        When true, this filter will match all values not matching the property_values
         """
         return pulumi.get(self, "not_")
 
     @property
     @pulumi.getter(name="propertyValues")
     def property_values(self) -> Sequence[str]:
         """
-        List of property values to match
+        Value of the dimension
         """
         return pulumi.get(self, "property_values")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        Name of dimension to match
+        Name of the dimension
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class MetricRulesetRoutingRule(dict):
     def __init__(__self__, *,
                  destination: str):
         """
-        :param str destination: Destination to send the input metric
+        :param str destination: end destination of the input metric. Must be `RealTime` or `Drop`
         """
         pulumi.set(__self__, "destination", destination)
 
     @property
     @pulumi.getter
     def destination(self) -> str:
         """
-        Destination to send the input metric
+        end destination of the input metric. Must be `RealTime` or `Drop`
         """
         return pulumi.get(self, "destination")
 
 
 @pulumi.output_type
 class OrgTokenDpmLimits(dict):
     @staticmethod
@@ -2246,20 +2262,20 @@
                  custom_metrics_limit: Optional[int] = None,
                  custom_metrics_notification_threshold: Optional[int] = None,
                  high_res_metrics_limit: Optional[int] = None,
                  high_res_metrics_notification_threshold: Optional[int] = None,
                  host_limit: Optional[int] = None,
                  host_notification_threshold: Optional[int] = None):
         """
-        :param int container_limit: Max number of containers that can use this token
-        :param int container_notification_threshold: Notification threshold for containers
+        :param int container_limit: Max number of Docker containers that can use this token
+        :param int container_notification_threshold: Notification threshold for Docker containers
         :param int custom_metrics_limit: Max number of custom metrics that can be sent with this token
         :param int custom_metrics_notification_threshold: Notification threshold for custom metrics
-        :param int high_res_metrics_limit: Max number of high-res metrics that can be sent with this token
-        :param int high_res_metrics_notification_threshold: Notification threshold for high-res metrics
+        :param int high_res_metrics_limit: Max number of hi-res metrics that can be sent with this toke
+        :param int high_res_metrics_notification_threshold: Notification threshold for hi-res metrics
         :param int host_limit: Max number of hosts that can use this token
         :param int host_notification_threshold: Notification threshold for hosts
         """
         if container_limit is not None:
             pulumi.set(__self__, "container_limit", container_limit)
         if container_notification_threshold is not None:
             pulumi.set(__self__, "container_notification_threshold", container_notification_threshold)
@@ -2276,23 +2292,23 @@
         if host_notification_threshold is not None:
             pulumi.set(__self__, "host_notification_threshold", host_notification_threshold)
 
     @property
     @pulumi.getter(name="containerLimit")
     def container_limit(self) -> Optional[int]:
         """
-        Max number of containers that can use this token
+        Max number of Docker containers that can use this token
         """
         return pulumi.get(self, "container_limit")
 
     @property
     @pulumi.getter(name="containerNotificationThreshold")
     def container_notification_threshold(self) -> Optional[int]:
         """
-        Notification threshold for containers
+        Notification threshold for Docker containers
         """
         return pulumi.get(self, "container_notification_threshold")
 
     @property
     @pulumi.getter(name="customMetricsLimit")
     def custom_metrics_limit(self) -> Optional[int]:
         """
@@ -2308,23 +2324,23 @@
         """
         return pulumi.get(self, "custom_metrics_notification_threshold")
 
     @property
     @pulumi.getter(name="highResMetricsLimit")
     def high_res_metrics_limit(self) -> Optional[int]:
         """
-        Max number of high-res metrics that can be sent with this token
+        Max number of hi-res metrics that can be sent with this toke
         """
         return pulumi.get(self, "high_res_metrics_limit")
 
     @property
     @pulumi.getter(name="highResMetricsNotificationThreshold")
     def high_res_metrics_notification_threshold(self) -> Optional[int]:
         """
-        Notification threshold for high-res metrics
+        Notification threshold for hi-res metrics
         """
         return pulumi.get(self, "high_res_metrics_notification_threshold")
 
     @property
     @pulumi.getter(name="hostLimit")
     def host_limit(self) -> Optional[int]:
         """
@@ -2347,18 +2363,18 @@
                  color: str,
                  gt: Optional[float] = None,
                  gte: Optional[float] = None,
                  lt: Optional[float] = None,
                  lte: Optional[float] = None):
         """
         :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        :param float gt: Indicates the lower threshold non-inclusive value for this range
-        :param float gte: Indicates the lower threshold inclusive value for this range
-        :param float lt: Indicates the upper threshold non-inculsive value for this range
-        :param float lte: Indicates the upper threshold inclusive value for this range
+        :param float gt: Indicates the lower threshold non-inclusive value for this range.
+        :param float gte: Indicates the lower threshold inclusive value for this range.
+        :param float lt: Indicates the upper threshold non-inculsive value for this range.
+        :param float lte: Indicates the upper threshold inclusive value for this range.
         """
         pulumi.set(__self__, "color", color)
         if gt is not None:
             pulumi.set(__self__, "gt", gt)
         if gte is not None:
             pulumi.set(__self__, "gte", gte)
         if lt is not None:
@@ -2374,39 +2390,39 @@
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter
     def gt(self) -> Optional[float]:
         """
-        Indicates the lower threshold non-inclusive value for this range
+        Indicates the lower threshold non-inclusive value for this range.
         """
         return pulumi.get(self, "gt")
 
     @property
     @pulumi.getter
     def gte(self) -> Optional[float]:
         """
-        Indicates the lower threshold inclusive value for this range
+        Indicates the lower threshold inclusive value for this range.
         """
         return pulumi.get(self, "gte")
 
     @property
     @pulumi.getter
     def lt(self) -> Optional[float]:
         """
-        Indicates the upper threshold non-inculsive value for this range
+        Indicates the upper threshold non-inculsive value for this range.
         """
         return pulumi.get(self, "lt")
 
     @property
     @pulumi.getter
     def lte(self) -> Optional[float]:
         """
-        Indicates the upper threshold inclusive value for this range
+        Indicates the upper threshold inclusive value for this range.
         """
         return pulumi.get(self, "lte")
 
 
 @pulumi.output_type
 class SingleValueChartVizOption(dict):
     @staticmethod
@@ -2436,20 +2452,20 @@
                  label: str,
                  color: Optional[str] = None,
                  display_name: Optional[str] = None,
                  value_prefix: Optional[str] = None,
                  value_suffix: Optional[str] = None,
                  value_unit: Optional[str] = None):
         """
-        :param str label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param str color: Color to use
+        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param str color: The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param str value_prefix: An arbitrary prefix to display with the value of this plot
+        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         :param str value_suffix: An arbitrary suffix to display with the value of this plot
-        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
         if value_prefix is not None:
@@ -2459,23 +2475,23 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> str:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter
     def color(self) -> Optional[str]:
         """
-        Color to use
+        The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter(name="displayName")
     def display_name(self) -> Optional[str]:
         """
@@ -2483,15 +2499,15 @@
         """
         return pulumi.get(self, "display_name")
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[str]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         """
         return pulumi.get(self, "value_prefix")
 
     @property
     @pulumi.getter(name="valueSuffix")
     def value_suffix(self) -> Optional[str]:
         """
@@ -2499,15 +2515,15 @@
         """
         return pulumi.get(self, "value_suffix")
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[str]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
 
 @pulumi.output_type
 class SloInput(dict):
     @staticmethod
@@ -2532,45 +2548,45 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  program_text: str,
                  good_events_label: Optional[str] = None,
                  total_events_label: Optional[str] = None):
         """
-        :param str program_text: Signalflow program text for the SLO. More info at "https://dev.splunk.com/observability/docs/signalflow". We require this Signalflow program text to contain at least 2 data blocks - one for the total stream and one for the good stream, whose labels are specified by goodEventsLabel and totalEventsLabel
-        :param str good_events_label: Label used in `program_text` that refers to the data block which contains the stream of successful events
-        :param str total_events_label: Label used in `program_text` that refers to the data block which contains the stream of total events
+        :param str program_text: SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
+        :param str good_events_label: Label used in `"program_text"` that refers to the data block which contains the stream of successful events
+        :param str total_events_label: Label used in `"program_text"` that refers to the data block which contains the stream of total events
         """
         pulumi.set(__self__, "program_text", program_text)
         if good_events_label is not None:
             pulumi.set(__self__, "good_events_label", good_events_label)
         if total_events_label is not None:
             pulumi.set(__self__, "total_events_label", total_events_label)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> str:
         """
-        Signalflow program text for the SLO. More info at "https://dev.splunk.com/observability/docs/signalflow". We require this Signalflow program text to contain at least 2 data blocks - one for the total stream and one for the good stream, whose labels are specified by goodEventsLabel and totalEventsLabel
+        SignalFlow program and arguments text strings that define the streams used as successful event count and total event count
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="goodEventsLabel")
     def good_events_label(self) -> Optional[str]:
         """
-        Label used in `program_text` that refers to the data block which contains the stream of successful events
+        Label used in `"program_text"` that refers to the data block which contains the stream of successful events
         """
         return pulumi.get(self, "good_events_label")
 
     @property
     @pulumi.getter(name="totalEventsLabel")
     def total_events_label(self) -> Optional[str]:
         """
-        Label used in `program_text` that refers to the data block which contains the stream of total events
+        Label used in `"program_text"` that refers to the data block which contains the stream of total events
         """
         return pulumi.get(self, "total_events_label")
 
 
 @pulumi.output_type
 class SloTarget(dict):
     @staticmethod
@@ -2600,20 +2616,20 @@
                  alert_rules: Sequence['outputs.SloTargetAlertRule'],
                  slo: float,
                  type: str,
                  compliance_period: Optional[str] = None,
                  cycle_start: Optional[str] = None,
                  cycle_type: Optional[str] = None):
         """
-        :param Sequence['SloTargetAlertRuleArgs'] alert_rules: SLO alert rules
+        :param Sequence['SloTargetAlertRuleArgs'] alert_rules: List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
         :param float slo: Target value in the form of a percentage
-        :param str type: SLO target type can be the following type: `RollingWindow`
-        :param str compliance_period: (Required for `RollingWindow` type) Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
-        :param str cycle_start: (Optional for `CalendarWindow` type)  It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
-        :param str cycle_type: (Required for `CalendarWindow` type) The cycle type of the calendar window, e.g. week, month.
+        :param str type: SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
+        :param str compliance_period: Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
+        :param str cycle_start: It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
+        :param str cycle_type: The cycle type of the calendar window, e.g. week, month.
         """
         pulumi.set(__self__, "alert_rules", alert_rules)
         pulumi.set(__self__, "slo", slo)
         pulumi.set(__self__, "type", type)
         if compliance_period is not None:
             pulumi.set(__self__, "compliance_period", compliance_period)
         if cycle_start is not None:
@@ -2621,15 +2637,15 @@
         if cycle_type is not None:
             pulumi.set(__self__, "cycle_type", cycle_type)
 
     @property
     @pulumi.getter(name="alertRules")
     def alert_rules(self) -> Sequence['outputs.SloTargetAlertRule']:
         """
-        SLO alert rules
+        List of alert rules you want to set for this SLO target. An SLO alert rule of type BREACH is always required.
         """
         return pulumi.get(self, "alert_rules")
 
     @property
     @pulumi.getter
     def slo(self) -> float:
         """
@@ -2637,68 +2653,68 @@
         """
         return pulumi.get(self, "slo")
 
     @property
     @pulumi.getter
     def type(self) -> str:
         """
-        SLO target type can be the following type: `RollingWindow`
+        SLO target type can be the following type: `"RollingWindow"`, `"CalendarWindow"`
         """
         return pulumi.get(self, "type")
 
     @property
     @pulumi.getter(name="compliancePeriod")
     def compliance_period(self) -> Optional[str]:
         """
-        (Required for `RollingWindow` type) Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
+        Compliance period of this SLO. This value must be within the range of 1d (1 days) to 30d (30 days), inclusive.
         """
         return pulumi.get(self, "compliance_period")
 
     @property
     @pulumi.getter(name="cycleStart")
     def cycle_start(self) -> Optional[str]:
         """
-        (Optional for `CalendarWindow` type)  It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
+        It can be used to change the cycle start time. For example, you can specify sunday as the start of the week (instead of the default monday)
         """
         return pulumi.get(self, "cycle_start")
 
     @property
     @pulumi.getter(name="cycleType")
     def cycle_type(self) -> Optional[str]:
         """
-        (Required for `CalendarWindow` type) The cycle type of the calendar window, e.g. week, month.
+        The cycle type of the calendar window, e.g. week, month.
         """
         return pulumi.get(self, "cycle_type")
 
 
 @pulumi.output_type
 class SloTargetAlertRule(dict):
     def __init__(__self__, *,
                  rules: Sequence['outputs.SloTargetAlertRuleRule'],
                  type: str):
         """
-        :param Sequence['SloTargetAlertRuleRuleArgs'] rules: Set of rules used for alerting
-        :param str type: SLO alert rule type
+        :param Sequence['SloTargetAlertRuleRuleArgs'] rules: Set of rules used for alerting.
+        :param str type: SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alert_rule per type. For example, you can't specify two alert_rule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         pulumi.set(__self__, "rules", rules)
         pulumi.set(__self__, "type", type)
 
     @property
     @pulumi.getter
     def rules(self) -> Sequence['outputs.SloTargetAlertRuleRule']:
         """
-        Set of rules used for alerting
+        Set of rules used for alerting.
         """
         return pulumi.get(self, "rules")
 
     @property
     @pulumi.getter
     def type(self) -> str:
         """
-        SLO alert rule type
+        SLO alert rule can be one of the following types: BREACH, ERROR_BUDGET_LEFT, BURN_RATE. Within an SLO object, you can only specify one SLO alert_rule per type. For example, you can't specify two alert_rule of type BREACH. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "type")
 
 
 @pulumi.output_type
 class SloTargetAlertRuleRule(dict):
     @staticmethod
@@ -2729,23 +2745,23 @@
                  notifications: Optional[Sequence[str]] = None,
                  parameterized_body: Optional[str] = None,
                  parameterized_subject: Optional[str] = None,
                  parameters: Optional['outputs.SloTargetAlertRuleRuleParameters'] = None,
                  runbook_url: Optional[str] = None,
                  tip: Optional[str] = None):
         """
-        :param str severity: The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
-        :param str description: Description of the rule
-        :param bool disabled: (default: false) When true, notifications and events will not be generated for the detect label
-        :param Sequence[str] notifications: List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
-        :param str parameterized_body: Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
-        :param str parameterized_subject: Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        :param str severity: The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
+        :param str description: Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
+        :param bool disabled: When true, notifications and events will not be generated for the detect label. `false` by default.
+        :param Sequence[str] notifications: List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
+        :param str parameterized_body: Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
+        :param str parameterized_subject: Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
         :param 'SloTargetAlertRuleRuleParametersArgs' parameters: Parameters for the SLO alert rule. Each SLO alert rule type accepts different parameters. If not specified, default parameters are used.
-        :param str runbook_url: URL of page to consult when an alert is triggered
-        :param str tip: Plain text suggested first course of action, such as a command to execute.
+        :param str runbook_url: URL of page to consult when an alert is triggered. This can be used with custom notification messages.
+        :param str tip: Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         pulumi.set(__self__, "severity", severity)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if disabled is not None:
             pulumi.set(__self__, "disabled", disabled)
         if notifications is not None:
@@ -2761,55 +2777,55 @@
         if tip is not None:
             pulumi.set(__self__, "tip", tip)
 
     @property
     @pulumi.getter
     def severity(self) -> str:
         """
-        The severity of the rule, must be one of: Critical, Warning, Major, Minor, Info
+        The severity of the rule, must be one of: `"Critical"`, `"Major"`, `"Minor"`, `"Warning"`, `"Info"`.
         """
         return pulumi.get(self, "severity")
 
     @property
     @pulumi.getter
     def description(self) -> Optional[str]:
         """
-        Description of the rule
+        Description for the rule. Displays as the alert condition in the Alert Rules tab of the detector editor in the web UI.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def disabled(self) -> Optional[bool]:
         """
-        (default: false) When true, notifications and events will not be generated for the detect label
+        When true, notifications and events will not be generated for the detect label. `false` by default.
         """
         return pulumi.get(self, "disabled")
 
     @property
     @pulumi.getter
     def notifications(self) -> Optional[Sequence[str]]:
         """
-        List of strings specifying where notifications will be sent when an incident occurs. See https://developers.signalfx.com/v2/docs/detector-model#notifications-models for more info
+        List of strings specifying where notifications will be sent when an incident occurs. See [Create SLO](https://dev.splunk.com/observability/reference/api/slo/latest#endpoint-create-new-slo) for more info.
         """
         return pulumi.get(self, "notifications")
 
     @property
     @pulumi.getter(name="parameterizedBody")
     def parameterized_body(self) -> Optional[str]:
         """
-        Custom notification message body when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message body when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
         """
         return pulumi.get(self, "parameterized_body")
 
     @property
     @pulumi.getter(name="parameterizedSubject")
     def parameterized_subject(self) -> Optional[str]:
         """
-        Custom notification message subject when an alert is triggered. See https://developers.signalfx.com/v2/reference#detector-model for more info
+        Custom notification message subject when an alert is triggered. See [Alert message](https://docs.splunk.com/observability/en/alerts-detectors-notifications/create-detectors-for-alerts.html#alert-messages) for more info.
         """
         return pulumi.get(self, "parameterized_subject")
 
     @property
     @pulumi.getter
     def parameters(self) -> Optional['outputs.SloTargetAlertRuleRuleParameters']:
         """
@@ -2817,23 +2833,23 @@
         """
         return pulumi.get(self, "parameters")
 
     @property
     @pulumi.getter(name="runbookUrl")
     def runbook_url(self) -> Optional[str]:
         """
-        URL of page to consult when an alert is triggered
+        URL of page to consult when an alert is triggered. This can be used with custom notification messages.
         """
         return pulumi.get(self, "runbook_url")
 
     @property
     @pulumi.getter
     def tip(self) -> Optional[str]:
         """
-        Plain text suggested first course of action, such as a command to execute.
+        Plain text suggested first course of action, such as a command line to execute. This can be used with custom notification messages.
         """
         return pulumi.get(self, "tip")
 
 
 @pulumi.output_type
 class SloTargetAlertRuleRuleParameters(dict):
     @staticmethod
@@ -2876,23 +2892,23 @@
                  long_window1: Optional[str] = None,
                  long_window2: Optional[str] = None,
                  percent_error_budget_left: Optional[float] = None,
                  percent_of_lasting: Optional[float] = None,
                  short_window1: Optional[str] = None,
                  short_window2: Optional[str] = None):
         """
-        :param float burn_rate_threshold1: Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_1 parameter.
-        :param float burn_rate_threshold2: Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_2 parameter.
-        :param str fire_lasting: Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the fire_lasting parameter
-        :param str long_window1: Long window 1 used in burn rate alert calculation. This value must be longer than short_window_1` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_1 parameter.
-        :param str long_window2: Long window 2 used in burn rate alert calculation. This value must be longer than short_window_2` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_2 parameter.
-        :param float percent_error_budget_left: Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: ERROR_BUDGET_LEFT alert rules use the percent_error_budget_left parameter.
-        :param float percent_of_lasting: Percentage of the fire_lasting duration that the alert condition is met before the alert is triggered. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the percent_of_lasting parameter
-        :param str short_window1: Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_1. Note: BURN_RATE alert rules use the short_window_1 parameter.
-        :param str short_window2: Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_2. Note: BURN_RATE alert rules use the short_window_2 parameter.
+        :param float burn_rate_threshold1: Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param float burn_rate_threshold2: Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param str fire_lasting: Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
+        :param str long_window1: Long window 1 used in burn rate alert calculation. This value must be longer than `"short_window_1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param str long_window2: Long window 2 used in burn rate alert calculation. This value must be longer than `"short_window_2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param float percent_error_budget_left: Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_error_budget_left"` parameter. Default: `100`
+        :param float percent_of_lasting: Percentage of the `"fire_lasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_of_lasting"` parameter. Default: `100`
+        :param str short_window1: Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_1"`. Note: `"BURN_RATE"` alert rules use the `"short_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
+        :param str short_window2: Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_2"`. Note: `"BURN_RATE"` alert rules use the `"short_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         if burn_rate_threshold1 is not None:
             pulumi.set(__self__, "burn_rate_threshold1", burn_rate_threshold1)
         if burn_rate_threshold2 is not None:
             pulumi.set(__self__, "burn_rate_threshold2", burn_rate_threshold2)
         if fire_lasting is not None:
             pulumi.set(__self__, "fire_lasting", fire_lasting)
@@ -2909,79 +2925,79 @@
         if short_window2 is not None:
             pulumi.set(__self__, "short_window2", short_window2)
 
     @property
     @pulumi.getter(name="burnRateThreshold1")
     def burn_rate_threshold1(self) -> Optional[float]:
         """
-        Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_1 parameter.
+        Burn rate threshold 1 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "burn_rate_threshold1")
 
     @property
     @pulumi.getter(name="burnRateThreshold2")
     def burn_rate_threshold2(self) -> Optional[float]:
         """
-        Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: BURN_RATE alert rules use the burn_rate_threshold_2 parameter.
+        Burn rate threshold 2 used in burn rate alert calculation. This value must be between 0 and 100/(100-SLO target). Note: `"BURN_RATE"` alert rules use the `"burn_rate_threshold_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "burn_rate_threshold2")
 
     @property
     @pulumi.getter(name="fireLasting")
     def fire_lasting(self) -> Optional[str]:
         """
-        Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the fire_lasting parameter
+        Duration that indicates how long the alert condition is met before the alert is triggered. The value must be positive and smaller than the compliance period of the SLO target. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the fireLasting parameter. Default: `"5m"`
         """
         return pulumi.get(self, "fire_lasting")
 
     @property
     @pulumi.getter(name="longWindow1")
     def long_window1(self) -> Optional[str]:
         """
-        Long window 1 used in burn rate alert calculation. This value must be longer than short_window_1` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_1 parameter.
+        Long window 1 used in burn rate alert calculation. This value must be longer than `"short_window_1"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "long_window1")
 
     @property
     @pulumi.getter(name="longWindow2")
     def long_window2(self) -> Optional[str]:
         """
-        Long window 2 used in burn rate alert calculation. This value must be longer than short_window_2` and shorter than 90 days. Note: BURN_RATE alert rules use the long_window_2 parameter.
+        Long window 2 used in burn rate alert calculation. This value must be longer than `"short_window_2"` and shorter than 90 days. Note: `"BURN_RATE"` alert rules use the `"long_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "long_window2")
 
     @property
     @pulumi.getter(name="percentErrorBudgetLeft")
     def percent_error_budget_left(self) -> Optional[float]:
         """
-        Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: ERROR_BUDGET_LEFT alert rules use the percent_error_budget_left parameter.
+        Error budget must be equal to or smaller than this percentage for the alert to be triggered. Note: `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_error_budget_left"` parameter. Default: `100`
         """
         return pulumi.get(self, "percent_error_budget_left")
 
     @property
     @pulumi.getter(name="percentOfLasting")
     def percent_of_lasting(self) -> Optional[float]:
         """
-        Percentage of the fire_lasting duration that the alert condition is met before the alert is triggered. Note: BREACH and ERROR_BUDGET_LEFT alert rules use the percent_of_lasting parameter
+        Percentage of the `"fire_lasting"` duration that the alert condition is met before the alert is triggered. Note: `"BREACH"` and `"ERROR_BUDGET_LEFT"` alert rules use the `"percent_of_lasting"` parameter. Default: `100`
         """
         return pulumi.get(self, "percent_of_lasting")
 
     @property
     @pulumi.getter(name="shortWindow1")
     def short_window1(self) -> Optional[str]:
         """
-        Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_1. Note: BURN_RATE alert rules use the short_window_1 parameter.
+        Short window 1 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_1"`. Note: `"BURN_RATE"` alert rules use the `"short_window_1"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "short_window1")
 
     @property
     @pulumi.getter(name="shortWindow2")
     def short_window2(self) -> Optional[str]:
         """
-        Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of long_window_2. Note: BURN_RATE alert rules use the short_window_2 parameter.
+        Short window 2 used in burn rate alert calculation. This value must be longer than 1/30 of `"long_window_2"`. Note: `"BURN_RATE"` alert rules use the `"short_window_2"` parameter. See [SLO alerts](https://docs.splunk.com/observability/en/alerts-detectors-notifications/slo/burn-rate-alerts.html) for more info.
         """
         return pulumi.get(self, "short_window2")
 
 
 @pulumi.output_type
 class TableChartVizOption(dict):
     @staticmethod
@@ -3118,21 +3134,21 @@
                  label: Optional[str] = None,
                  low_watermark: Optional[float] = None,
                  low_watermark_label: Optional[str] = None,
                  max_value: Optional[float] = None,
                  min_value: Optional[float] = None,
                  watermarks: Optional[Sequence['outputs.TimeChartAxisLeftWatermark']] = None):
         """
-        :param float high_watermark: A line to draw as a high watermark
-        :param str high_watermark_label: A label to attach to the high watermark line
-        :param str label: Label of the left axis
-        :param float low_watermark: A line to draw as a low watermark
-        :param str low_watermark_label: A label to attach to the low watermark line
-        :param float max_value: The maximum value for the left axis
-        :param float min_value: The minimum value for the left axis
+        :param float high_watermark: A line to draw as a high watermark.
+        :param str high_watermark_label: A label to attach to the high watermark line.
+        :param str label: Label of the left axis.
+        :param float low_watermark: A line to draw as a low watermark.
+        :param str low_watermark_label: A label to attach to the low watermark line.
+        :param float max_value: The maximum value for the left axis.
+        :param float min_value: The minimum value for the left axis.
         """
         if high_watermark is not None:
             pulumi.set(__self__, "high_watermark", high_watermark)
         if high_watermark_label is not None:
             pulumi.set(__self__, "high_watermark_label", high_watermark_label)
         if label is not None:
             pulumi.set(__self__, "label", label)
@@ -3147,63 +3163,63 @@
         if watermarks is not None:
             pulumi.set(__self__, "watermarks", watermarks)
 
     @property
     @pulumi.getter(name="highWatermark")
     def high_watermark(self) -> Optional[float]:
         """
-        A line to draw as a high watermark
+        A line to draw as a high watermark.
         """
         return pulumi.get(self, "high_watermark")
 
     @property
     @pulumi.getter(name="highWatermarkLabel")
     def high_watermark_label(self) -> Optional[str]:
         """
-        A label to attach to the high watermark line
+        A label to attach to the high watermark line.
         """
         return pulumi.get(self, "high_watermark_label")
 
     @property
     @pulumi.getter
     def label(self) -> Optional[str]:
         """
-        Label of the left axis
+        Label of the left axis.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter(name="lowWatermark")
     def low_watermark(self) -> Optional[float]:
         """
-        A line to draw as a low watermark
+        A line to draw as a low watermark.
         """
         return pulumi.get(self, "low_watermark")
 
     @property
     @pulumi.getter(name="lowWatermarkLabel")
     def low_watermark_label(self) -> Optional[str]:
         """
-        A label to attach to the low watermark line
+        A label to attach to the low watermark line.
         """
         return pulumi.get(self, "low_watermark_label")
 
     @property
     @pulumi.getter(name="maxValue")
     def max_value(self) -> Optional[float]:
         """
-        The maximum value for the left axis
+        The maximum value for the left axis.
         """
         return pulumi.get(self, "max_value")
 
     @property
     @pulumi.getter(name="minValue")
     def min_value(self) -> Optional[float]:
         """
-        The minimum value for the left axis
+        The minimum value for the left axis.
         """
         return pulumi.get(self, "min_value")
 
     @property
     @pulumi.getter
     def watermarks(self) -> Optional[Sequence['outputs.TimeChartAxisLeftWatermark']]:
         return pulumi.get(self, "watermarks")
@@ -3274,21 +3290,21 @@
                  label: Optional[str] = None,
                  low_watermark: Optional[float] = None,
                  low_watermark_label: Optional[str] = None,
                  max_value: Optional[float] = None,
                  min_value: Optional[float] = None,
                  watermarks: Optional[Sequence['outputs.TimeChartAxisRightWatermark']] = None):
         """
-        :param float high_watermark: A line to draw as a high watermark
-        :param str high_watermark_label: A label to attach to the high watermark line
-        :param str label: Label of the right axis
-        :param float low_watermark: A line to draw as a low watermark
-        :param str low_watermark_label: A label to attach to the low watermark line
-        :param float max_value: The maximum value for the right axis
-        :param float min_value: The minimum value for the right axis
+        :param float high_watermark: A line to draw as a high watermark.
+        :param str high_watermark_label: A label to attach to the high watermark line.
+        :param str label: Label of the right axis.
+        :param float low_watermark: A line to draw as a low watermark.
+        :param str low_watermark_label: A label to attach to the low watermark line.
+        :param float max_value: The maximum value for the right axis.
+        :param float min_value: The minimum value for the right axis.
         """
         if high_watermark is not None:
             pulumi.set(__self__, "high_watermark", high_watermark)
         if high_watermark_label is not None:
             pulumi.set(__self__, "high_watermark_label", high_watermark_label)
         if label is not None:
             pulumi.set(__self__, "label", label)
@@ -3303,63 +3319,63 @@
         if watermarks is not None:
             pulumi.set(__self__, "watermarks", watermarks)
 
     @property
     @pulumi.getter(name="highWatermark")
     def high_watermark(self) -> Optional[float]:
         """
-        A line to draw as a high watermark
+        A line to draw as a high watermark.
         """
         return pulumi.get(self, "high_watermark")
 
     @property
     @pulumi.getter(name="highWatermarkLabel")
     def high_watermark_label(self) -> Optional[str]:
         """
-        A label to attach to the high watermark line
+        A label to attach to the high watermark line.
         """
         return pulumi.get(self, "high_watermark_label")
 
     @property
     @pulumi.getter
     def label(self) -> Optional[str]:
         """
-        Label of the right axis
+        Label of the right axis.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter(name="lowWatermark")
     def low_watermark(self) -> Optional[float]:
         """
-        A line to draw as a low watermark
+        A line to draw as a low watermark.
         """
         return pulumi.get(self, "low_watermark")
 
     @property
     @pulumi.getter(name="lowWatermarkLabel")
     def low_watermark_label(self) -> Optional[str]:
         """
-        A label to attach to the low watermark line
+        A label to attach to the low watermark line.
         """
         return pulumi.get(self, "low_watermark_label")
 
     @property
     @pulumi.getter(name="maxValue")
     def max_value(self) -> Optional[float]:
         """
-        The maximum value for the right axis
+        The maximum value for the right axis.
         """
         return pulumi.get(self, "max_value")
 
     @property
     @pulumi.getter(name="minValue")
     def min_value(self) -> Optional[float]:
         """
-        The minimum value for the right axis
+        The minimum value for the right axis.
         """
         return pulumi.get(self, "min_value")
 
     @property
     @pulumi.getter
     def watermarks(self) -> Optional[Sequence['outputs.TimeChartAxisRightWatermark']]:
         return pulumi.get(self, "watermarks")
@@ -3415,37 +3431,37 @@
         return super().get(key, default)
 
     def __init__(__self__, *,
                  label: str,
                  color: Optional[str] = None,
                  display_name: Optional[str] = None):
         """
-        :param str label: The label used in the publish statement that displays the events you want to customize
-        :param str color: Color to use
+        :param str label: Label used in the publish statement that displays the event query you want to customize.
+        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
         """
         pulumi.set(__self__, "label", label)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
             pulumi.set(__self__, "display_name", display_name)
 
     @property
     @pulumi.getter
     def label(self) -> str:
         """
-        The label used in the publish statement that displays the events you want to customize
+        Label used in the publish statement that displays the event query you want to customize.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter
     def color(self) -> Optional[str]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter(name="displayName")
     def display_name(self) -> Optional[str]:
         """
@@ -3472,54 +3488,54 @@
     def get(self, key: str, default = None) -> Any:
         TimeChartHistogramOption.__key_warning(key)
         return super().get(key, default)
 
     def __init__(__self__, *,
                  color_theme: Optional[str] = None):
         """
-        :param str color_theme: Base color theme to use for the graph.
+        :param str color_theme: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
         """
         if color_theme is not None:
             pulumi.set(__self__, "color_theme", color_theme)
 
     @property
     @pulumi.getter(name="colorTheme")
     def color_theme(self) -> Optional[str]:
         """
-        Base color theme to use for the graph.
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
         """
         return pulumi.get(self, "color_theme")
 
 
 @pulumi.output_type
 class TimeChartLegendOptionsField(dict):
     def __init__(__self__, *,
                  property: str,
                  enabled: Optional[bool] = None):
         """
-        :param str property: The name of a property to hide or show in the data table.
-        :param bool enabled: (true by default) Determines if this property is displayed in the data table.
+        :param str property: The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
+        :param bool enabled: True or False depending on if you want the property to be shown or hidden.
         """
         pulumi.set(__self__, "property", property)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[bool]:
         """
-        (true by default) Determines if this property is displayed in the data table.
+        True or False depending on if you want the property to be shown or hidden.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def property(self) -> str:
         """
-        The name of a property to hide or show in the data table.
+        The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
         """
         return pulumi.get(self, "property")
 
 
 @pulumi.output_type
 class TimeChartVizOption(dict):
     @staticmethod
@@ -3553,22 +3569,22 @@
                  color: Optional[str] = None,
                  display_name: Optional[str] = None,
                  plot_type: Optional[str] = None,
                  value_prefix: Optional[str] = None,
                  value_suffix: Optional[str] = None,
                  value_unit: Optional[str] = None):
         """
-        :param str label: The label used in the publish statement that displays the plot (metric time series data) you want to customize
-        :param str axis: The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
-        :param str color: Color to use
+        :param str label: Label used in the publish statement that displays the plot (metric time series data) you want to customize.
+        :param str axis: Y-axis associated with values for this plot. Must be either `right` or `left`.
+        :param str color: Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         :param str display_name: Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-        :param str plot_type: (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
-        :param str value_prefix: An arbitrary prefix to display with the value of this plot
+        :param str plot_type: The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
+        :param str value_prefix: , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         :param str value_suffix: An arbitrary suffix to display with the value of this plot
-        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        :param str value_unit: A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         pulumi.set(__self__, "label", label)
         if axis is not None:
             pulumi.set(__self__, "axis", axis)
         if color is not None:
             pulumi.set(__self__, "color", color)
         if display_name is not None:
@@ -3582,31 +3598,31 @@
         if value_unit is not None:
             pulumi.set(__self__, "value_unit", value_unit)
 
     @property
     @pulumi.getter
     def label(self) -> str:
         """
-        The label used in the publish statement that displays the plot (metric time series data) you want to customize
+        Label used in the publish statement that displays the plot (metric time series data) you want to customize.
         """
         return pulumi.get(self, "label")
 
     @property
     @pulumi.getter
     def axis(self) -> Optional[str]:
         """
-        The Y-axis associated with values for this plot. Must be either "right" or "left". Defaults to "left".
+        Y-axis associated with values for this plot. Must be either `right` or `left`.
         """
         return pulumi.get(self, "axis")
 
     @property
     @pulumi.getter
     def color(self) -> Optional[str]:
         """
-        Color to use
+        Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
         """
         return pulumi.get(self, "color")
 
     @property
     @pulumi.getter(name="displayName")
     def display_name(self) -> Optional[str]:
         """
@@ -3614,23 +3630,23 @@
         """
         return pulumi.get(self, "display_name")
 
     @property
     @pulumi.getter(name="plotType")
     def plot_type(self) -> Optional[str]:
         """
-        (Chart plot_type by default) The visualization style to use. Must be "LineChart", "AreaChart", "ColumnChart", or "Histogram"
+        The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
         """
         return pulumi.get(self, "plot_type")
 
     @property
     @pulumi.getter(name="valuePrefix")
     def value_prefix(self) -> Optional[str]:
         """
-        An arbitrary prefix to display with the value of this plot
+        , `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
         """
         return pulumi.get(self, "value_prefix")
 
     @property
     @pulumi.getter(name="valueSuffix")
     def value_suffix(self) -> Optional[str]:
         """
@@ -3638,15 +3654,15 @@
         """
         return pulumi.get(self, "value_suffix")
 
     @property
     @pulumi.getter(name="valueUnit")
     def value_unit(self) -> Optional[str]:
         """
-        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes)
+        A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
         """
         return pulumi.get(self, "value_unit")
 
 
 @pulumi.output_type
 class WebhookIntegrationHeader(dict):
     @staticmethod
@@ -3667,21 +3683,31 @@
     def get(self, key: str, default = None) -> Any:
         WebhookIntegrationHeader.__key_warning(key)
         return super().get(key, default)
 
     def __init__(__self__, *,
                  header_key: str,
                  header_value: str):
+        """
+        :param str header_key: The key of the header to send
+        :param str header_value: The value of the header to send
+        """
         pulumi.set(__self__, "header_key", header_key)
         pulumi.set(__self__, "header_value", header_value)
 
     @property
     @pulumi.getter(name="headerKey")
     def header_key(self) -> str:
+        """
+        The key of the header to send
+        """
         return pulumi.get(self, "header_key")
 
     @property
     @pulumi.getter(name="headerValue")
     def header_value(self) -> str:
+        """
+        The value of the header to send
+        """
         return pulumi.get(self, "header_value")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pagerduty/get_integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pagerduty/get_integration.py`

 * *Files 11% similar despite different names*

```diff
@@ -31,27 +31,33 @@
         if name and not isinstance(name, str):
             raise TypeError("Expected argument 'name' to be a str")
         pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def enabled(self) -> bool:
+        """
+        Whether the integration is enabled.
+        """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def id(self) -> str:
         """
         The provider-assigned unique ID for this managed resource.
         """
         return pulumi.get(self, "id")
 
     @property
     @pulumi.getter
     def name(self) -> str:
+        """
+        The name of the integration.
+        """
         return pulumi.get(self, "name")
 
 
 class AwaitableGetIntegrationResult(GetIntegrationResult):
     # pylint: disable=using-constant-test
     def __await__(self):
         if False:
@@ -72,23 +78,16 @@
     ```python
     import pulumi
     import pulumi_signalfx as signalfx
 
     pd_integration = signalfx.pagerduty.get_integration(name="PD-Integration")
     ```
 
-    ## Arguments
 
-    * `name` - Specify the exact name of the desired PagerDuty integration
-
-    ## Attributes
-
-    * `id` - The ID of the integration.
-    * `name` - The name of the integration.
-    * `enabled` - Whether the integration is enabled.
+    :param str name: Specify the exact name of the desired PagerDuty integration
     """
     __args__ = dict()
     __args__['name'] = name
     opts = pulumi.InvokeOptions.merge(_utilities.get_invoke_opts_defaults(), opts)
     __ret__ = pulumi.runtime.invoke('signalfx:pagerduty/getIntegration:getIntegration', __args__, opts=opts, typ=GetIntegrationResult).value
 
     return AwaitableGetIntegrationResult(
@@ -108,18 +107,11 @@
     ```python
     import pulumi
     import pulumi_signalfx as signalfx
 
     pd_integration = signalfx.pagerduty.get_integration(name="PD-Integration")
     ```
 
-    ## Arguments
-
-    * `name` - Specify the exact name of the desired PagerDuty integration
-
-    ## Attributes
 
-    * `id` - The ID of the integration.
-    * `name` - The name of the integration.
-    * `enabled` - Whether the integration is enabled.
+    :param str name: Specify the exact name of the desired PagerDuty integration
     """
     ...
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/pagerduty/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/victorops/integration.py`

 * *Files 7% similar despite different names*

```diff
@@ -11,177 +11,155 @@
 
 __all__ = ['IntegrationArgs', 'Integration']
 
 @pulumi.input_type
 class IntegrationArgs:
     def __init__(__self__, *,
                  enabled: pulumi.Input[bool],
-                 api_key: Optional[pulumi.Input[str]] = None,
-                 name: Optional[pulumi.Input[str]] = None):
+                 name: Optional[pulumi.Input[str]] = None,
+                 post_url: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] api_key: PagerDuty API key
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] post_url: Splunk On-Call REST API URL.
         """
         pulumi.set(__self__, "enabled", enabled)
-        if api_key is not None:
-            pulumi.set(__self__, "api_key", api_key)
         if name is not None:
             pulumi.set(__self__, "name", name)
+        if post_url is not None:
+            pulumi.set(__self__, "post_url", post_url)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
-    @pulumi.getter(name="apiKey")
-    def api_key(self) -> Optional[pulumi.Input[str]]:
-        """
-        PagerDuty API key
-        """
-        return pulumi.get(self, "api_key")
-
-    @api_key.setter
-    def api_key(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "api_key", value)
-
-    @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
+    @property
+    @pulumi.getter(name="postUrl")
+    def post_url(self) -> Optional[pulumi.Input[str]]:
+        """
+        Splunk On-Call REST API URL.
+        """
+        return pulumi.get(self, "post_url")
+
+    @post_url.setter
+    def post_url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "post_url", value)
+
 
 @pulumi.input_type
 class _IntegrationState:
     def __init__(__self__, *,
-                 api_key: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
-                 name: Optional[pulumi.Input[str]] = None):
+                 name: Optional[pulumi.Input[str]] = None,
+                 post_url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
-        :param pulumi.Input[str] api_key: PagerDuty API key
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] post_url: Splunk On-Call REST API URL.
         """
-        if api_key is not None:
-            pulumi.set(__self__, "api_key", api_key)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
         if name is not None:
             pulumi.set(__self__, "name", name)
-
-    @property
-    @pulumi.getter(name="apiKey")
-    def api_key(self) -> Optional[pulumi.Input[str]]:
-        """
-        PagerDuty API key
-        """
-        return pulumi.get(self, "api_key")
-
-    @api_key.setter
-    def api_key(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "api_key", value)
+        if post_url is not None:
+            pulumi.set(__self__, "post_url", post_url)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
+    @property
+    @pulumi.getter(name="postUrl")
+    def post_url(self) -> Optional[pulumi.Input[str]]:
+        """
+        Splunk On-Call REST API URL.
+        """
+        return pulumi.get(self, "post_url")
+
+    @post_url.setter
+    def post_url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "post_url", value)
+
 
 class Integration(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 api_key: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  name: Optional[pulumi.Input[str]] = None,
+                 post_url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Splunk Observability Cloud PagerDuty integrations.
+        Splunk On-Call integrations.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `api_key` - (Required) PagerDuty API key.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
 
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] api_key: PagerDuty API key
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] post_url: Splunk On-Call REST API URL.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Splunk Observability Cloud PagerDuty integrations.
+        Splunk On-Call integrations.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `api_key` - (Required) PagerDuty API key.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
 
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
@@ -190,83 +168,81 @@
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
-                 api_key: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  name: Optional[pulumi.Input[str]] = None,
+                 post_url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
             __props__ = IntegrationArgs.__new__(IntegrationArgs)
 
-            __props__.__dict__["api_key"] = None if api_key is None else pulumi.Output.secret(api_key)
             if enabled is None and not opts.urn:
                 raise TypeError("Missing required property 'enabled'")
             __props__.__dict__["enabled"] = enabled
             __props__.__dict__["name"] = name
-        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["apiKey"])
-        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
+            __props__.__dict__["post_url"] = post_url
         super(Integration, __self__).__init__(
-            'signalfx:pagerduty/integration:Integration',
+            'signalfx:victorops/integration:Integration',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
-            api_key: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
-            name: Optional[pulumi.Input[str]] = None) -> 'Integration':
+            name: Optional[pulumi.Input[str]] = None,
+            post_url: Optional[pulumi.Input[str]] = None) -> 'Integration':
         """
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] api_key: PagerDuty API key
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] post_url: Splunk On-Call REST API URL.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
-        __props__.__dict__["api_key"] = api_key
         __props__.__dict__["enabled"] = enabled
         __props__.__dict__["name"] = name
+        __props__.__dict__["post_url"] = post_url
         return Integration(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter(name="apiKey")
-    def api_key(self) -> pulumi.Output[Optional[str]]:
-        """
-        PagerDuty API key
-        """
-        return pulumi.get(self, "api_key")
-
-    @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
+    @property
+    @pulumi.getter(name="postUrl")
+    def post_url(self) -> pulumi.Output[Optional[str]]:
+        """
+        Splunk On-Call REST API URL.
+        """
+        return pulumi.get(self, "post_url")
+
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/provider.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/provider.py`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/servicenow/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/servicenow/integration.py`

 * *Files 5% similar despite different names*

```diff
@@ -20,26 +20,22 @@
                  password: pulumi.Input[str],
                  username: pulumi.Input[str],
                  alert_resolved_payload_template: Optional[pulumi.Input[str]] = None,
                  alert_triggered_payload_template: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled
-        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myinst.service-now.com`.
         :param pulumi.Input[str] issue_type: The type of issue in standard ITIL terminology. The allowed values are `Incident` and `Problem`.
         :param pulumi.Input[str] password: Password used to authenticate the ServiceNow integration.
         :param pulumi.Input[str] username: User name used to authenticate the ServiceNow integration.
-        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-               ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-               to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "instance_name", instance_name)
         pulumi.set(__self__, "issue_type", issue_type)
         pulumi.set(__self__, "password", password)
         pulumi.set(__self__, "username", username)
         if alert_resolved_payload_template is not None:
@@ -49,27 +45,27 @@
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="instanceName")
     def instance_name(self) -> pulumi.Input[str]:
         """
-        Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        Name of the ServiceNow instance, for example `myinst.service-now.com`.
         """
         return pulumi.get(self, "instance_name")
 
     @instance_name.setter
     def instance_name(self, value: pulumi.Input[str]):
         pulumi.set(self, "instance_name", value)
 
@@ -109,43 +105,39 @@
     def username(self, value: pulumi.Input[str]):
         pulumi.set(self, "username", value)
 
     @property
     @pulumi.getter(name="alertResolvedPayloadTemplate")
     def alert_resolved_payload_template(self) -> Optional[pulumi.Input[str]]:
         """
-        A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-        ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-        ServiceNow. See API reference for details.
+        A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
         """
         return pulumi.get(self, "alert_resolved_payload_template")
 
     @alert_resolved_payload_template.setter
     def alert_resolved_payload_template(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "alert_resolved_payload_template", value)
 
     @property
     @pulumi.getter(name="alertTriggeredPayloadTemplate")
     def alert_triggered_payload_template(self) -> Optional[pulumi.Input[str]]:
         """
-        A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-        to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-        ServiceNow. See API reference for details.
+        A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
         """
         return pulumi.get(self, "alert_triggered_payload_template")
 
     @alert_triggered_payload_template.setter
     def alert_triggered_payload_template(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "alert_triggered_payload_template", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -159,24 +151,20 @@
                  instance_name: Optional[pulumi.Input[str]] = None,
                  issue_type: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  password: Optional[pulumi.Input[str]] = None,
                  username: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
-        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-               ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-               to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled
-        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myinst.service-now.com`.
         :param pulumi.Input[str] issue_type: The type of issue in standard ITIL terminology. The allowed values are `Incident` and `Problem`.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the ServiceNow integration.
         :param pulumi.Input[str] username: User name used to authenticate the ServiceNow integration.
         """
         if alert_resolved_payload_template is not None:
             pulumi.set(__self__, "alert_resolved_payload_template", alert_resolved_payload_template)
         if alert_triggered_payload_template is not None:
             pulumi.set(__self__, "alert_triggered_payload_template", alert_triggered_payload_template)
@@ -193,55 +181,51 @@
         if username is not None:
             pulumi.set(__self__, "username", username)
 
     @property
     @pulumi.getter(name="alertResolvedPayloadTemplate")
     def alert_resolved_payload_template(self) -> Optional[pulumi.Input[str]]:
         """
-        A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-        ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-        ServiceNow. See API reference for details.
+        A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
         """
         return pulumi.get(self, "alert_resolved_payload_template")
 
     @alert_resolved_payload_template.setter
     def alert_resolved_payload_template(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "alert_resolved_payload_template", value)
 
     @property
     @pulumi.getter(name="alertTriggeredPayloadTemplate")
     def alert_triggered_payload_template(self) -> Optional[pulumi.Input[str]]:
         """
-        A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-        to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-        ServiceNow. See API reference for details.
+        A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
         """
         return pulumi.get(self, "alert_triggered_payload_template")
 
     @alert_triggered_payload_template.setter
     def alert_triggered_payload_template(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "alert_triggered_payload_template", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="instanceName")
     def instance_name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        Name of the ServiceNow instance, for example `myinst.service-now.com`.
         """
         return pulumi.get(self, "instance_name")
 
     @instance_name.setter
     def instance_name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "instance_name", value)
 
@@ -257,15 +241,15 @@
     def issue_type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "issue_type", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -311,43 +295,22 @@
         """
         ServiceNow integrations. For help with this integration see [Integration with ServiceNow](https://docs.splunk.com/observability/en/admin/notif-services/servicenow.html).
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `username` - (Required) User name used to authenticate the ServiceNow integration.
-        * `password` - (Required) Password used to authenticate the ServiceNow integration.
-        * `instance_name` - (Required) Name of the ServiceNow instance, for example `myinst.service-now.com`.
-        * `issue_type` - (Required) The type of issue in standard ITIL terminology. The allowed values are `Incident` and `Problem`.
-        * `alert_triggered_payload_template` - (Optional) A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
-        * `alert_resolved_payload_template` - (Optional) A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-               ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-               to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled
-        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myinst.service-now.com`.
         :param pulumi.Input[str] issue_type: The type of issue in standard ITIL terminology. The allowed values are `Incident` and `Problem`.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the ServiceNow integration.
         :param pulumi.Input[str] username: User name used to authenticate the ServiceNow integration.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
@@ -356,31 +319,14 @@
         """
         ServiceNow integrations. For help with this integration see [Integration with ServiceNow](https://docs.splunk.com/observability/en/admin/notif-services/servicenow.html).
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `username` - (Required) User name used to authenticate the ServiceNow integration.
-        * `password` - (Required) Password used to authenticate the ServiceNow integration.
-        * `instance_name` - (Required) Name of the ServiceNow instance, for example `myinst.service-now.com`.
-        * `issue_type` - (Required) The type of issue in standard ITIL terminology. The allowed values are `Incident` and `Problem`.
-        * `alert_triggered_payload_template` - (Optional) A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
-        * `alert_resolved_payload_template` - (Optional) A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -450,24 +396,20 @@
         """
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-               ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-               to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-               ServiceNow. See API reference for details.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled
-        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        :param pulumi.Input[str] alert_resolved_payload_template: A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[str] alert_triggered_payload_template: A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] instance_name: Name of the ServiceNow instance, for example `myinst.service-now.com`.
         :param pulumi.Input[str] issue_type: The type of issue in standard ITIL terminology. The allowed values are `Incident` and `Problem`.
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[str] name: Name of the integration.
         :param pulumi.Input[str] password: Password used to authenticate the ServiceNow integration.
         :param pulumi.Input[str] username: User name used to authenticate the ServiceNow integration.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
@@ -481,43 +423,39 @@
         __props__.__dict__["username"] = username
         return Integration(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="alertResolvedPayloadTemplate")
     def alert_resolved_payload_template(self) -> pulumi.Output[Optional[str]]:
         """
-        A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in
-        ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-        ServiceNow. See API reference for details.
+        A template that Observability Cloud uses to create the ServiceNow PUT JSON payloads when an alert is cleared in ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
         """
         return pulumi.get(self, "alert_resolved_payload_template")
 
     @property
     @pulumi.getter(name="alertTriggeredPayloadTemplate")
     def alert_triggered_payload_template(self) -> pulumi.Output[Optional[str]]:
         """
-        A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification
-        to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in
-        ServiceNow. See API reference for details.
+        A template that Observability Cloud uses to create the ServiceNow POST JSON payloads when an alert sends a notification to ServiceNow. Use this optional field to send the values of Observability Cloud alert properties to specific fields in ServiceNow. See [API reference](https://dev.splunk.com/observability/reference/api/integrations/latest) for details.
         """
         return pulumi.get(self, "alert_triggered_payload_template")
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter(name="instanceName")
     def instance_name(self) -> pulumi.Output[str]:
         """
-        Name of the ServiceNow instance, for example `myInstances.service-now.com`.
+        Name of the ServiceNow instance, for example `myinst.service-now.com`.
         """
         return pulumi.get(self, "instance_name")
 
     @property
     @pulumi.getter(name="issueType")
     def issue_type(self) -> pulumi.Output[str]:
         """
@@ -525,15 +463,15 @@
         """
         return pulumi.get(self, "issue_type")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def password(self) -> pulumi.Output[str]:
         """
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/single_value_chart.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/single_value_chart.py`

 * *Files 5% similar despite different names*

```diff
@@ -28,28 +28,28 @@
                  secondary_visualization: Optional[pulumi.Input[str]] = None,
                  show_spark_line: Optional[pulumi.Input[bool]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]]] = None):
         """
         The set of arguments for constructing a SingleValueChart resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
-        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] is_timestamp_hidden: (false by default) Whether to hide the timestamp in the chart
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[str] color_by: Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] is_timestamp_hidden: Whether to hide the timestamp in the chart. `false` by default.
         :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: The maximum precision to for values displayed in the list
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[bool] show_spark_line: (false by default) Whether to show a trend line below the current value
+        :param pulumi.Input[int] max_precision: The maximum precision to for value displayed.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the value.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
+        :param pulumi.Input[bool] show_spark_line: Whether to show a trend line below the current value. `false` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         pulumi.set(__self__, "program_text", program_text)
         if color_by is not None:
             pulumi.set(__self__, "color_by", color_by)
         if color_scales is not None:
             pulumi.set(__self__, "color_scales", color_scales)
         if description is not None:
@@ -75,63 +75,63 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
+        Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @color_by.setter
     def color_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_by", value)
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
         """
         return pulumi.get(self, "color_scales")
 
     @color_scales.setter
     def color_scales(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]]]):
         pulumi.set(self, "color_scales", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="isTimestampHidden")
     def is_timestamp_hidden(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether to hide the timestamp in the chart
+        Whether to hide the timestamp in the chart. `false` by default.
         """
         return pulumi.get(self, "is_timestamp_hidden")
 
     @is_timestamp_hidden.setter
     def is_timestamp_hidden(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "is_timestamp_hidden", value)
 
@@ -147,63 +147,63 @@
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="maxPrecision")
     def max_precision(self) -> Optional[pulumi.Input[int]]:
         """
-        The maximum precision to for values displayed in the list
+        The maximum precision to for value displayed.
         """
         return pulumi.get(self, "max_precision")
 
     @max_precision.setter
     def max_precision(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_precision", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        How often (in seconds) to refresh the values of the list
+        How often (in seconds) to refresh the value.
         """
         return pulumi.get(self, "refresh_interval")
 
     @refresh_interval.setter
     def refresh_interval(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "refresh_interval", value)
 
     @property
     @pulumi.getter(name="secondaryVisualization")
     def secondary_visualization(self) -> Optional[pulumi.Input[str]]:
         """
-        (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
+        The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
         """
         return pulumi.get(self, "secondary_visualization")
 
     @secondary_visualization.setter
     def secondary_visualization(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "secondary_visualization", value)
 
     @property
     @pulumi.getter(name="showSparkLine")
     def show_spark_line(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether to show a trend line below the current value
+        Whether to show a trend line below the current value. `false` by default.
         """
         return pulumi.get(self, "show_spark_line")
 
     @show_spark_line.setter
     def show_spark_line(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_spark_line", value)
 
@@ -219,27 +219,27 @@
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -260,29 +260,29 @@
                  show_spark_line: Optional[pulumi.Input[bool]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  url: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]]] = None):
         """
         Input properties used for looking up and filtering SingleValueChart resources.
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
-        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] is_timestamp_hidden: (false by default) Whether to hide the timestamp in the chart
+        :param pulumi.Input[str] color_by: Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] is_timestamp_hidden: Whether to hide the timestamp in the chart. `false` by default.
         :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: The maximum precision to for values displayed in the list
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[bool] show_spark_line: (false by default) Whether to show a trend line below the current value
+        :param pulumi.Input[int] max_precision: The maximum precision to for value displayed.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the value.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
+        :param pulumi.Input[bool] show_spark_line: Whether to show a trend line below the current value. `false` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
-        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         if color_by is not None:
             pulumi.set(__self__, "color_by", color_by)
         if color_scales is not None:
             pulumi.set(__self__, "color_scales", color_scales)
         if description is not None:
             pulumi.set(__self__, "description", description)
@@ -311,51 +311,51 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
+        Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @color_by.setter
     def color_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_by", value)
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
         """
         return pulumi.get(self, "color_scales")
 
     @color_scales.setter
     def color_scales(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartColorScaleArgs']]]]):
         pulumi.set(self, "color_scales", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="isTimestampHidden")
     def is_timestamp_hidden(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether to hide the timestamp in the chart
+        Whether to hide the timestamp in the chart. `false` by default.
         """
         return pulumi.get(self, "is_timestamp_hidden")
 
     @is_timestamp_hidden.setter
     def is_timestamp_hidden(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "is_timestamp_hidden", value)
 
@@ -371,75 +371,75 @@
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="maxPrecision")
     def max_precision(self) -> Optional[pulumi.Input[int]]:
         """
-        The maximum precision to for values displayed in the list
+        The maximum precision to for value displayed.
         """
         return pulumi.get(self, "max_precision")
 
     @max_precision.setter
     def max_precision(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_precision", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> Optional[pulumi.Input[int]]:
         """
-        How often (in seconds) to refresh the values of the list
+        How often (in seconds) to refresh the value.
         """
         return pulumi.get(self, "refresh_interval")
 
     @refresh_interval.setter
     def refresh_interval(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "refresh_interval", value)
 
     @property
     @pulumi.getter(name="secondaryVisualization")
     def secondary_visualization(self) -> Optional[pulumi.Input[str]]:
         """
-        (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
+        The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
         """
         return pulumi.get(self, "secondary_visualization")
 
     @secondary_visualization.setter
     def secondary_visualization(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "secondary_visualization", value)
 
     @property
     @pulumi.getter(name="showSparkLine")
     def show_spark_line(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether to show a trend line below the current value
+        Whether to show a trend line below the current value. `false` by default.
         """
         return pulumi.get(self, "show_spark_line")
 
     @show_spark_line.setter
     def show_spark_line(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_spark_line", value)
 
@@ -455,39 +455,39 @@
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SingleValueChartVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -515,114 +515,44 @@
         """
         This chart type displays a single number in a large font, representing the current value of a single metric on a plot line.
 
         If the time period is in the past, the number represents the value of the metric near the end of the time period.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `description` - (Optional) Description of the chart.
-        * `color_by` - (Optional) Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
-        * `color_scale` - (Optional. `color_by` must be `"Scale"`) Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
-            * `gt` - (Optional) Indicates the lower threshold non-inclusive value for this range.
-            * `gte` - (Optional) Indicates the lower threshold inclusive value for this range.
-            * `lt` - (Optional) Indicates the upper threshold non-inculsive value for this range.
-            * `lte` - (Optional) Indicates the upper threshold inclusive value for this range.
-            * `color` - (Required) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints
-        * `refresh_interval` - (Optional) How often (in seconds) to refresh the value.
-        * `max_precision` - (Optional) The maximum precision to for value displayed.
-        * `is_timestamp_hidden` - (Optional) Whether to hide the timestamp in the chart. `false` by default.
-        * `secondary_visualization` - (Optional) The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
-        * `show_spark_line` - (Optional) Whether to show a trend line below the current value. `false` by default.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] is_timestamp_hidden: (false by default) Whether to hide the timestamp in the chart
+        :param pulumi.Input[str] color_by: Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] is_timestamp_hidden: Whether to hide the timestamp in the chart. `false` by default.
         :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: The maximum precision to for values displayed in the list
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[bool] show_spark_line: (false by default) Whether to show a trend line below the current value
+        :param pulumi.Input[int] max_precision: The maximum precision to for value displayed.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the value.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
+        :param pulumi.Input[bool] show_spark_line: Whether to show a trend line below the current value. `false` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: SingleValueChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         This chart type displays a single number in a large font, representing the current value of a single metric on a plot line.
 
         If the time period is in the past, the number represents the value of the metric near the end of the time period.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `description` - (Optional) Description of the chart.
-        * `color_by` - (Optional) Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
-        * `color_scale` - (Optional. `color_by` must be `"Scale"`) Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
-            * `gt` - (Optional) Indicates the lower threshold non-inclusive value for this range.
-            * `gte` - (Optional) Indicates the lower threshold inclusive value for this range.
-            * `lt` - (Optional) Indicates the upper threshold non-inculsive value for this range.
-            * `lte` - (Optional) Indicates the upper threshold inclusive value for this range.
-            * `color` - (Required) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) The color to use. Must be one of gray, blue, light_blue, navy, dark_orange, orange, dark_yellow, magenta, cerise, pink, violet, purple, gray_blue, dark_green, green, aquamarine, red, yellow, vivid_yellow, light_green, or lime_green.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints
-        * `refresh_interval` - (Optional) How often (in seconds) to refresh the value.
-        * `max_precision` - (Optional) The maximum precision to for value displayed.
-        * `is_timestamp_hidden` - (Optional) Whether to hide the timestamp in the chart. `false` by default.
-        * `secondary_visualization` - (Optional) The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
-        * `show_spark_line` - (Optional) Whether to show a trend line below the current value. `false` by default.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param SingleValueChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(SingleValueChartArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -702,29 +632,29 @@
         """
         Get an existing SingleValueChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] color_by: (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[bool] is_timestamp_hidden: (false by default) Whether to hide the timestamp in the chart
+        :param pulumi.Input[str] color_by: Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartColorScaleArgs']]]] color_scales: Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] is_timestamp_hidden: Whether to hide the timestamp in the chart. `false` by default.
         :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] max_precision: The maximum precision to for values displayed in the list
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the values of the list
-        :param pulumi.Input[str] secondary_visualization: (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
-        :param pulumi.Input[bool] show_spark_line: (false by default) Whether to show a trend line below the current value
+        :param pulumi.Input[int] max_precision: The maximum precision to for value displayed.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[int] refresh_interval: How often (in seconds) to refresh the value.
+        :param pulumi.Input[str] secondary_visualization: The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
+        :param pulumi.Input[bool] show_spark_line: Whether to show a trend line below the current value. `false` by default.
         :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['SingleValueChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _SingleValueChartState.__new__(_SingleValueChartState)
 
         __props__.__dict__["color_by"] = color_by
         __props__.__dict__["color_scales"] = color_scales
@@ -743,39 +673,39 @@
         __props__.__dict__["viz_options"] = viz_options
         return SingleValueChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> pulumi.Output[Optional[str]]:
         """
-        (Metric by default) Must be "Metric", "Dimension", or "Scale". "Scale" maps to Color by Value in the UI
+        Must be `"Dimension"`, `"Scale"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @property
     @pulumi.getter(name="colorScales")
     def color_scales(self) -> pulumi.Output[Optional[Sequence['outputs.SingleValueChartColorScale']]]:
         """
-        Single color range including both the color to display for that range and the borders of the range
+        Single color range including both the color to display for that range and the borders of the range. Example: `[{ gt = 60, color = "blue" }, { lte = 60, color = "yellow" }]`. Look at this [link](https://docs.signalfx.com/en/latest/charts/chart-options-tab.html).
         """
         return pulumi.get(self, "color_scales")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart (Optional)
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="isTimestampHidden")
     def is_timestamp_hidden(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) Whether to hide the timestamp in the chart
+        Whether to hide the timestamp in the chart. `false` by default.
         """
         return pulumi.get(self, "is_timestamp_hidden")
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> pulumi.Output[Optional[int]]:
         """
@@ -783,55 +713,55 @@
         """
         return pulumi.get(self, "max_delay")
 
     @property
     @pulumi.getter(name="maxPrecision")
     def max_precision(self) -> pulumi.Output[Optional[int]]:
         """
-        The maximum precision to for values displayed in the list
+        The maximum precision to for value displayed.
         """
         return pulumi.get(self, "max_precision")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="refreshInterval")
     def refresh_interval(self) -> pulumi.Output[Optional[int]]:
         """
-        How often (in seconds) to refresh the values of the list
+        How often (in seconds) to refresh the value.
         """
         return pulumi.get(self, "refresh_interval")
 
     @property
     @pulumi.getter(name="secondaryVisualization")
     def secondary_visualization(self) -> pulumi.Output[Optional[str]]:
         """
-        (false by default) What kind of secondary visualization to show (None, Radial, Linear, Sparkline)
+        The type of secondary visualization. Can be `None`, `Radial`, `Linear`, or `Sparkline`. If unset, the Splunk Observability Cloud default is used (`None`).
         """
         return pulumi.get(self, "secondary_visualization")
 
     @property
     @pulumi.getter(name="showSparkLine")
     def show_spark_line(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) Whether to show a trend line below the current value
+        Whether to show a trend line below the current value. `false` by default.
         """
         return pulumi.get(self, "show_spark_line")
 
     @property
     @pulumi.getter
     def timezone(self) -> pulumi.Output[Optional[str]]:
         """
@@ -839,27 +769,27 @@
         """
         return pulumi.get(self, "timezone")
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> pulumi.Output[Optional[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary"`. `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> pulumi.Output[Optional[Sequence['outputs.SingleValueChartVizOption']]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/slack/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/slack/integration.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,52 +15,52 @@
 class IntegrationArgs:
     def __init__(__self__, *,
                  enabled: pulumi.Input[bool],
                  webhook_url: pulumi.Input[str],
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] webhook_url: Slack Webhook URL for integration
-        :param pulumi.Input[str] name: Name of the integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] webhook_url: Slack incoming webhook URL.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         pulumi.set(__self__, "enabled", enabled)
         pulumi.set(__self__, "webhook_url", webhook_url)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter(name="webhookUrl")
     def webhook_url(self) -> pulumi.Input[str]:
         """
-        Slack Webhook URL for integration
+        Slack incoming webhook URL.
         """
         return pulumi.get(self, "webhook_url")
 
     @webhook_url.setter
     def webhook_url(self, value: pulumi.Input[str]):
         pulumi.set(self, "webhook_url", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -69,54 +69,54 @@
 class _IntegrationState:
     def __init__(__self__, *,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  webhook_url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] webhook_url: Slack Webhook URL for integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] webhook_url: Slack incoming webhook URL.
         """
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
         if name is not None:
             pulumi.set(__self__, "name", name)
         if webhook_url is not None:
             pulumi.set(__self__, "webhook_url", webhook_url)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="webhookUrl")
     def webhook_url(self) -> Optional[pulumi.Input[str]]:
         """
-        Slack Webhook URL for integration
+        Slack incoming webhook URL.
         """
         return pulumi.get(self, "webhook_url")
 
     @webhook_url.setter
     def webhook_url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "webhook_url", value)
 
@@ -133,57 +133,33 @@
         """
         Slack integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `webhook_url` - (Required) Slack incoming webhook URL.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] webhook_url: Slack Webhook URL for integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] webhook_url: Slack incoming webhook URL.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Slack integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `webhook_url` - (Required) Slack incoming webhook URL.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -232,44 +208,44 @@
         """
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] webhook_url: Slack Webhook URL for integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        :param pulumi.Input[str] webhook_url: Slack incoming webhook URL.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
         __props__.__dict__["enabled"] = enabled
         __props__.__dict__["name"] = name
         __props__.__dict__["webhook_url"] = webhook_url
         return Integration(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="webhookUrl")
     def webhook_url(self) -> pulumi.Output[str]:
         """
-        Slack Webhook URL for integration
+        Slack incoming webhook URL.
         """
         return pulumi.get(self, "webhook_url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/team.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/team.py`

 * *Files 18% similar despite different names*

```diff
@@ -21,23 +21,23 @@
                  notifications_defaults: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_infos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_majors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_minors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
         """
         The set of arguments for constructing a Team resource.
-        :param pulumi.Input[str] description: Description of the team (Optional)
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Members of team
-        :param pulumi.Input[str] name: Name of the team
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: List of notification destinations to use for the critical alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: List of notification destinations to use for the default alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: List of notification destinations to use for the info alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: List of notification destinations to use for the major alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: List of notification destinations to use for the minor alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: List of notification destinations to use for the warning alerts category.
+        :param pulumi.Input[str] description: Description of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: List of user IDs to include in the team.
+        :param pulumi.Input[str] name: Name of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: Where to send notifications for critical alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: Where to send notifications for default alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: Where to send notifications for info alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: Where to send notifications for major alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: Where to send notifications for minor alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: Where to send notifications for warning alerts
         """
         if description is not None:
             pulumi.set(__self__, "description", description)
         if members is not None:
             pulumi.set(__self__, "members", members)
         if name is not None:
             pulumi.set(__self__, "name", name)
@@ -54,111 +54,111 @@
         if notifications_warnings is not None:
             pulumi.set(__self__, "notifications_warnings", notifications_warnings)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the team (Optional)
+        Description of the team.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Members of team
+        List of user IDs to include in the team.
         """
         return pulumi.get(self, "members")
 
     @members.setter
     def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "members", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the team
+        Name of the team.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="notificationsCriticals")
     def notifications_criticals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the critical alerts category.
+        Where to send notifications for critical alerts
         """
         return pulumi.get(self, "notifications_criticals")
 
     @notifications_criticals.setter
     def notifications_criticals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_criticals", value)
 
     @property
     @pulumi.getter(name="notificationsDefaults")
     def notifications_defaults(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the default alerts category.
+        Where to send notifications for default alerts
         """
         return pulumi.get(self, "notifications_defaults")
 
     @notifications_defaults.setter
     def notifications_defaults(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_defaults", value)
 
     @property
     @pulumi.getter(name="notificationsInfos")
     def notifications_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the info alerts category.
+        Where to send notifications for info alerts
         """
         return pulumi.get(self, "notifications_infos")
 
     @notifications_infos.setter
     def notifications_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_infos", value)
 
     @property
     @pulumi.getter(name="notificationsMajors")
     def notifications_majors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the major alerts category.
+        Where to send notifications for major alerts
         """
         return pulumi.get(self, "notifications_majors")
 
     @notifications_majors.setter
     def notifications_majors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_majors", value)
 
     @property
     @pulumi.getter(name="notificationsMinors")
     def notifications_minors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the minor alerts category.
+        Where to send notifications for minor alerts
         """
         return pulumi.get(self, "notifications_minors")
 
     @notifications_minors.setter
     def notifications_minors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_minors", value)
 
     @property
     @pulumi.getter(name="notificationsWarnings")
     def notifications_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the warning alerts category.
+        Where to send notifications for warning alerts
         """
         return pulumi.get(self, "notifications_warnings")
 
     @notifications_warnings.setter
     def notifications_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_warnings", value)
 
@@ -174,24 +174,24 @@
                  notifications_infos: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_majors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_minors: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  notifications_warnings: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Team resources.
-        :param pulumi.Input[str] description: Description of the team (Optional)
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Members of team
-        :param pulumi.Input[str] name: Name of the team
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: List of notification destinations to use for the critical alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: List of notification destinations to use for the default alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: List of notification destinations to use for the info alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: List of notification destinations to use for the major alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: List of notification destinations to use for the minor alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: List of notification destinations to use for the warning alerts category.
-        :param pulumi.Input[str] url: URL of the team
+        :param pulumi.Input[str] description: Description of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: List of user IDs to include in the team.
+        :param pulumi.Input[str] name: Name of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: Where to send notifications for critical alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: Where to send notifications for default alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: Where to send notifications for info alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: Where to send notifications for major alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: Where to send notifications for minor alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: Where to send notifications for warning alerts
+        :param pulumi.Input[str] url: The URL of the team.
         """
         if description is not None:
             pulumi.set(__self__, "description", description)
         if members is not None:
             pulumi.set(__self__, "members", members)
         if name is not None:
             pulumi.set(__self__, "name", name)
@@ -210,123 +210,123 @@
         if url is not None:
             pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the team (Optional)
+        Description of the team.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def members(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        Members of team
+        List of user IDs to include in the team.
         """
         return pulumi.get(self, "members")
 
     @members.setter
     def members(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "members", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the team
+        Name of the team.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="notificationsCriticals")
     def notifications_criticals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the critical alerts category.
+        Where to send notifications for critical alerts
         """
         return pulumi.get(self, "notifications_criticals")
 
     @notifications_criticals.setter
     def notifications_criticals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_criticals", value)
 
     @property
     @pulumi.getter(name="notificationsDefaults")
     def notifications_defaults(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the default alerts category.
+        Where to send notifications for default alerts
         """
         return pulumi.get(self, "notifications_defaults")
 
     @notifications_defaults.setter
     def notifications_defaults(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_defaults", value)
 
     @property
     @pulumi.getter(name="notificationsInfos")
     def notifications_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the info alerts category.
+        Where to send notifications for info alerts
         """
         return pulumi.get(self, "notifications_infos")
 
     @notifications_infos.setter
     def notifications_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_infos", value)
 
     @property
     @pulumi.getter(name="notificationsMajors")
     def notifications_majors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the major alerts category.
+        Where to send notifications for major alerts
         """
         return pulumi.get(self, "notifications_majors")
 
     @notifications_majors.setter
     def notifications_majors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_majors", value)
 
     @property
     @pulumi.getter(name="notificationsMinors")
     def notifications_minors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the minor alerts category.
+        Where to send notifications for minor alerts
         """
         return pulumi.get(self, "notifications_minors")
 
     @notifications_minors.setter
     def notifications_minors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_minors", value)
 
     @property
     @pulumi.getter(name="notificationsWarnings")
     def notifications_warnings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of notification destinations to use for the warning alerts category.
+        Where to send notifications for warning alerts
         """
         return pulumi.get(self, "notifications_warnings")
 
     @notifications_warnings.setter
     def notifications_warnings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "notifications_warnings", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the team
+        The URL of the team.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
@@ -351,46 +351,25 @@
 
         You can configure [team notification policies](https://docs.splunk.com/observability/en/admin/user-management/teams/team-notifications.html) using this resource and the various `notifications_*` properties.
 
         > **NOTE** When managing teams, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the team.
-        * `description` - (Optional) Description of the team.
-        * `members` - (Optional) List of user IDs to include in the team.
-        * `notifications_critical` - (Optional) Where to send notifications for critical alerts
-        * `notifications_default` - (Optional) Where to send notifications for default alerts
-        * `notifications_info` - (Optional) Where to send notifications for info alerts
-        * `notifications_major` - (Optional) Where to send notifications for major alerts
-        * `notifications_minor` - (Optional) Where to send notifications for minor alerts
-        * `notifications_warning` - (Optional) Where to send notifications for warning alerts
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the team.
-        * `url` - The URL of the team.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: Description of the team (Optional)
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Members of team
-        :param pulumi.Input[str] name: Name of the team
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: List of notification destinations to use for the critical alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: List of notification destinations to use for the default alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: List of notification destinations to use for the info alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: List of notification destinations to use for the major alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: List of notification destinations to use for the minor alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: List of notification destinations to use for the warning alerts category.
+        :param pulumi.Input[str] description: Description of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: List of user IDs to include in the team.
+        :param pulumi.Input[str] name: Name of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: Where to send notifications for critical alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: Where to send notifications for default alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: Where to send notifications for info alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: Where to send notifications for major alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: Where to send notifications for minor alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: Where to send notifications for warning alerts
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: Optional[TeamArgs] = None,
                  opts: Optional[pulumi.ResourceOptions] = None):
@@ -399,35 +378,14 @@
 
         You can configure [team notification policies](https://docs.splunk.com/observability/en/admin/user-management/teams/team-notifications.html) using this resource and the various `notifications_*` properties.
 
         > **NOTE** When managing teams, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator).
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the team.
-        * `description` - (Optional) Description of the team.
-        * `members` - (Optional) List of user IDs to include in the team.
-        * `notifications_critical` - (Optional) Where to send notifications for critical alerts
-        * `notifications_default` - (Optional) Where to send notifications for default alerts
-        * `notifications_info` - (Optional) Where to send notifications for info alerts
-        * `notifications_major` - (Optional) Where to send notifications for major alerts
-        * `notifications_minor` - (Optional) Where to send notifications for minor alerts
-        * `notifications_warning` - (Optional) Where to send notifications for warning alerts
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the team.
-        * `url` - The URL of the team.
-
         :param str resource_name: The name of the resource.
         :param TeamArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(TeamArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -490,24 +448,24 @@
         """
         Get an existing Team resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: Description of the team (Optional)
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: Members of team
-        :param pulumi.Input[str] name: Name of the team
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: List of notification destinations to use for the critical alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: List of notification destinations to use for the default alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: List of notification destinations to use for the info alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: List of notification destinations to use for the major alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: List of notification destinations to use for the minor alerts category.
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: List of notification destinations to use for the warning alerts category.
-        :param pulumi.Input[str] url: URL of the team
+        :param pulumi.Input[str] description: Description of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] members: List of user IDs to include in the team.
+        :param pulumi.Input[str] name: Name of the team.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_criticals: Where to send notifications for critical alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_defaults: Where to send notifications for default alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_infos: Where to send notifications for info alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_majors: Where to send notifications for major alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_minors: Where to send notifications for minor alerts
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] notifications_warnings: Where to send notifications for warning alerts
+        :param pulumi.Input[str] url: The URL of the team.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _TeamState.__new__(_TeamState)
 
         __props__.__dict__["description"] = description
         __props__.__dict__["members"] = members
@@ -521,83 +479,83 @@
         __props__.__dict__["url"] = url
         return Team(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the team (Optional)
+        Description of the team.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def members(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        Members of team
+        List of user IDs to include in the team.
         """
         return pulumi.get(self, "members")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the team
+        Name of the team.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="notificationsCriticals")
     def notifications_criticals(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of notification destinations to use for the critical alerts category.
+        Where to send notifications for critical alerts
         """
         return pulumi.get(self, "notifications_criticals")
 
     @property
     @pulumi.getter(name="notificationsDefaults")
     def notifications_defaults(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of notification destinations to use for the default alerts category.
+        Where to send notifications for default alerts
         """
         return pulumi.get(self, "notifications_defaults")
 
     @property
     @pulumi.getter(name="notificationsInfos")
     def notifications_infos(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of notification destinations to use for the info alerts category.
+        Where to send notifications for info alerts
         """
         return pulumi.get(self, "notifications_infos")
 
     @property
     @pulumi.getter(name="notificationsMajors")
     def notifications_majors(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of notification destinations to use for the major alerts category.
+        Where to send notifications for major alerts
         """
         return pulumi.get(self, "notifications_majors")
 
     @property
     @pulumi.getter(name="notificationsMinors")
     def notifications_minors(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of notification destinations to use for the minor alerts category.
+        Where to send notifications for minor alerts
         """
         return pulumi.get(self, "notifications_minors")
 
     @property
     @pulumi.getter(name="notificationsWarnings")
     def notifications_warnings(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of notification destinations to use for the warning alerts category.
+        Where to send notifications for warning alerts
         """
         return pulumi.get(self, "notifications_warnings")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the team
+        The URL of the team.
         """
         return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/text_chart.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/text_chart.py`

 * *Files 17% similar despite different names*

```diff
@@ -15,53 +15,53 @@
 class TextChartArgs:
     def __init__(__self__, *,
                  markdown: pulumi.Input[str],
                  description: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a TextChart resource.
-        :param pulumi.Input[str] markdown: Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[str] name: Name of the chart
+        :param pulumi.Input[str] markdown: Markdown text to display.
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[str] name: Name of the text note.
         """
         pulumi.set(__self__, "markdown", markdown)
         if description is not None:
             pulumi.set(__self__, "description", description)
         if name is not None:
             pulumi.set(__self__, "name", name)
 
     @property
     @pulumi.getter
     def markdown(self) -> pulumi.Input[str]:
         """
-        Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
+        Markdown text to display.
         """
         return pulumi.get(self, "markdown")
 
     @markdown.setter
     def markdown(self, value: pulumi.Input[str]):
         pulumi.set(self, "markdown", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the text note.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the text note.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
@@ -71,69 +71,69 @@
     def __init__(__self__, *,
                  description: Optional[pulumi.Input[str]] = None,
                  markdown: Optional[pulumi.Input[str]] = None,
                  name: Optional[pulumi.Input[str]] = None,
                  url: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering TextChart resources.
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[str] markdown: Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[str] markdown: Markdown text to display.
+        :param pulumi.Input[str] name: Name of the text note.
+        :param pulumi.Input[str] url: The URL of the chart.
         """
         if description is not None:
             pulumi.set(__self__, "description", description)
         if markdown is not None:
             pulumi.set(__self__, "markdown", markdown)
         if name is not None:
             pulumi.set(__self__, "name", name)
         if url is not None:
             pulumi.set(__self__, "url", url)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart (Optional)
+        Description of the text note.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter
     def markdown(self) -> Optional[pulumi.Input[str]]:
         """
-        Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
+        Markdown text to display.
         """
         return pulumi.get(self, "markdown")
 
     @markdown.setter
     def markdown(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "markdown", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the text note.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
@@ -148,61 +148,31 @@
                  name: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
         This special type of chart doesnt display any metric data. Rather, it lets you place a text note on the dashboard.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the text note.
-        * `markdown` - (Required) Markdown text to display.
-        * `description` - (Optional) Description of the text note.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[str] markdown: Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
-        :param pulumi.Input[str] name: Name of the chart
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[str] markdown: Markdown text to display.
+        :param pulumi.Input[str] name: Name of the text note.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: TextChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         This special type of chart doesnt display any metric data. Rather, it lets you place a text note on the dashboard.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the text note.
-        * `markdown` - (Required) Markdown text to display.
-        * `description` - (Optional) Description of the text note.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param TextChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(TextChartArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -249,18 +219,18 @@
         """
         Get an existing TextChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[str] description: Description of the chart (Optional)
-        :param pulumi.Input[str] markdown: Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] url: URL of the chart
+        :param pulumi.Input[str] description: Description of the text note.
+        :param pulumi.Input[str] markdown: Markdown text to display.
+        :param pulumi.Input[str] name: Name of the text note.
+        :param pulumi.Input[str] url: The URL of the chart.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _TextChartState.__new__(_TextChartState)
 
         __props__.__dict__["description"] = description
         __props__.__dict__["markdown"] = markdown
@@ -268,35 +238,35 @@
         __props__.__dict__["url"] = url
         return TextChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart (Optional)
+        Description of the text note.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter
     def markdown(self) -> pulumi.Output[str]:
         """
-        Markdown text to display. More info at: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet
+        Markdown text to display.
         """
         return pulumi.get(self, "markdown")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the text note.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/time_chart.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/time_chart.py`

 * *Files 11% similar despite different names*

```diff
@@ -41,41 +41,41 @@
                  tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                  time_range: Optional[pulumi.Input[int]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]]] = None):
         """
         The set of arguments for constructing a TimeChart resource.
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[bool] axes_include_zero: Force y-axes to always show zero
-        :param pulumi.Input[int] axes_precision: Force a specific number of significant digits in the y-axis
-        :param pulumi.Input[str] color_by: (Dimension by default) Must be "Dimension" or "Metric"
-        :param pulumi.Input[str] description: Description of the chart
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]] event_options: Event display customization options, associated with a publish statement
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]] histogram_options: Options specific to Histogram charts
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] on_chart_legend_dimension: Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-               'plot_label' and any dimension.
-        :param pulumi.Input[str] plot_type: (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-               "ColumnChart", or "Histogram"
-        :param pulumi.Input[bool] show_data_markers: (false by default) Show markers (circles) for each datapoint used to draw line or area charts
-        :param pulumi.Input[bool] show_event_lines: (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
-        :param pulumi.Input[bool] stacked: (false by default) Whether area and bar charts in the visualization should be stacked
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[bool] axes_include_zero: Force the chart to display zero on the y-axes, even if none of the data is near zero.
+        :param pulumi.Input[int] axes_precision: Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
+        :param pulumi.Input['TimeChartAxisLeftArgs'] axis_left: Set of axis options.
+        :param pulumi.Input['TimeChartAxisRightArgs'] axis_right: Set of axis options.
+        :param pulumi.Input[str] color_by: Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]] event_options: Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]] histogram_options: Only used when `plot_type` is `"Histogram"`. Histogram specific options.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] on_chart_legend_dimension: Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
+        :param pulumi.Input[str] plot_type: The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
+        :param pulumi.Input[bool] show_data_markers: Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
+        :param pulumi.Input[bool] show_event_lines: Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
+        :param pulumi.Input[bool] stacked: Whether area and bar charts in the visualization should be stacked. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the chart
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         pulumi.set(__self__, "program_text", program_text)
         if axes_include_zero is not None:
             pulumi.set(__self__, "axes_include_zero", axes_include_zero)
         if axes_precision is not None:
             pulumi.set(__self__, "axes_precision", axes_precision)
         if axis_left is not None:
@@ -133,266 +133,270 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Input[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: pulumi.Input[str]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="axesIncludeZero")
     def axes_include_zero(self) -> Optional[pulumi.Input[bool]]:
         """
-        Force y-axes to always show zero
+        Force the chart to display zero on the y-axes, even if none of the data is near zero.
         """
         return pulumi.get(self, "axes_include_zero")
 
     @axes_include_zero.setter
     def axes_include_zero(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "axes_include_zero", value)
 
     @property
     @pulumi.getter(name="axesPrecision")
     def axes_precision(self) -> Optional[pulumi.Input[int]]:
         """
-        Force a specific number of significant digits in the y-axis
+        Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
         """
         return pulumi.get(self, "axes_precision")
 
     @axes_precision.setter
     def axes_precision(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "axes_precision", value)
 
     @property
     @pulumi.getter(name="axisLeft")
     def axis_left(self) -> Optional[pulumi.Input['TimeChartAxisLeftArgs']]:
+        """
+        Set of axis options.
+        """
         return pulumi.get(self, "axis_left")
 
     @axis_left.setter
     def axis_left(self, value: Optional[pulumi.Input['TimeChartAxisLeftArgs']]):
         pulumi.set(self, "axis_left", value)
 
     @property
     @pulumi.getter(name="axisRight")
     def axis_right(self) -> Optional[pulumi.Input['TimeChartAxisRightArgs']]:
+        """
+        Set of axis options.
+        """
         return pulumi.get(self, "axis_right")
 
     @axis_right.setter
     def axis_right(self, value: Optional[pulumi.Input['TimeChartAxisRightArgs']]):
         pulumi.set(self, "axis_right", value)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> Optional[pulumi.Input[str]]:
         """
-        (Dimension by default) Must be "Dimension" or "Metric"
+        Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @color_by.setter
     def color_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_by", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter(name="eventOptions")
     def event_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]]]:
         """
-        Event display customization options, associated with a publish statement
+        Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
         """
         return pulumi.get(self, "event_options")
 
     @event_options.setter
     def event_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]]]):
         pulumi.set(self, "event_options", value)
 
     @property
     @pulumi.getter(name="histogramOptions")
     def histogram_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]]]:
         """
-        Options specific to Histogram charts
+        Only used when `plot_type` is `"Histogram"`. Histogram specific options.
         """
         return pulumi.get(self, "histogram_options")
 
     @histogram_options.setter
     def histogram_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]]]):
         pulumi.set(self, "histogram_options", value)
 
     @property
     @pulumi.getter(name="legendFieldsToHides")
     def legend_fields_to_hides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
+        List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
         """
         warnings.warn("""Please use legend_options_fields""", DeprecationWarning)
         pulumi.log.warn("""legend_fields_to_hides is deprecated: Please use legend_options_fields""")
 
         return pulumi.get(self, "legend_fields_to_hides")
 
     @legend_fields_to_hides.setter
     def legend_fields_to_hides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "legend_fields_to_hides", value)
 
     @property
     @pulumi.getter(name="legendOptionsFields")
     def legend_options_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]]]:
         """
-        List of property and enabled flags to control the order and presence of datatable labels in a chart.
+        List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
         """
         return pulumi.get(self, "legend_options_fields")
 
     @legend_options_fields.setter
     def legend_options_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]]]):
         pulumi.set(self, "legend_options_fields", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="minimumResolution")
     def minimum_resolution(self) -> Optional[pulumi.Input[int]]:
         """
-        The minimum resolution (in seconds) to use for computing the underlying program
+        The minimum resolution (in seconds) to use for computing the underlying program.
         """
         return pulumi.get(self, "minimum_resolution")
 
     @minimum_resolution.setter
     def minimum_resolution(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "minimum_resolution", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="onChartLegendDimension")
     def on_chart_legend_dimension(self) -> Optional[pulumi.Input[str]]:
         """
-        Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-        'plot_label' and any dimension.
+        Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
         """
         return pulumi.get(self, "on_chart_legend_dimension")
 
     @on_chart_legend_dimension.setter
     def on_chart_legend_dimension(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "on_chart_legend_dimension", value)
 
     @property
     @pulumi.getter(name="plotType")
     def plot_type(self) -> Optional[pulumi.Input[str]]:
         """
-        (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-        "ColumnChart", or "Histogram"
+        The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
         """
         return pulumi.get(self, "plot_type")
 
     @plot_type.setter
     def plot_type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "plot_type", value)
 
     @property
     @pulumi.getter(name="showDataMarkers")
     def show_data_markers(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Show markers (circles) for each datapoint used to draw line or area charts
+        Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
         """
         return pulumi.get(self, "show_data_markers")
 
     @show_data_markers.setter
     def show_data_markers(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_data_markers", value)
 
     @property
     @pulumi.getter(name="showEventLines")
     def show_event_lines(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
+        Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
         """
         return pulumi.get(self, "show_event_lines")
 
     @show_event_lines.setter
     def show_event_lines(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_event_lines", value)
 
     @property
     @pulumi.getter
     def stacked(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether area and bar charts in the visualization should be stacked
+        Whether area and bar charts in the visualization should be stacked. `false` by default.
         """
         return pulumi.get(self, "stacked")
 
     @stacked.setter
     def stacked(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "stacked", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
@@ -411,51 +415,51 @@
     def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "tags", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
     @property
     @pulumi.getter
     def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
         """
         return pulumi.get(self, "timezone")
 
     @timezone.setter
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -489,42 +493,42 @@
                  time_range: Optional[pulumi.Input[int]] = None,
                  timezone: Optional[pulumi.Input[str]] = None,
                  unit_prefix: Optional[pulumi.Input[str]] = None,
                  url: Optional[pulumi.Input[str]] = None,
                  viz_options: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]]] = None):
         """
         Input properties used for looking up and filtering TimeChart resources.
-        :param pulumi.Input[bool] axes_include_zero: Force y-axes to always show zero
-        :param pulumi.Input[int] axes_precision: Force a specific number of significant digits in the y-axis
-        :param pulumi.Input[str] color_by: (Dimension by default) Must be "Dimension" or "Metric"
-        :param pulumi.Input[str] description: Description of the chart
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]] event_options: Event display customization options, associated with a publish statement
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]] histogram_options: Options specific to Histogram charts
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] on_chart_legend_dimension: Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-               'plot_label' and any dimension.
-        :param pulumi.Input[str] plot_type: (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-               "ColumnChart", or "Histogram"
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[bool] show_data_markers: (false by default) Show markers (circles) for each datapoint used to draw line or area charts
-        :param pulumi.Input[bool] show_event_lines: (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
-        :param pulumi.Input[bool] stacked: (false by default) Whether area and bar charts in the visualization should be stacked
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
+        :param pulumi.Input[bool] axes_include_zero: Force the chart to display zero on the y-axes, even if none of the data is near zero.
+        :param pulumi.Input[int] axes_precision: Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
+        :param pulumi.Input['TimeChartAxisLeftArgs'] axis_left: Set of axis options.
+        :param pulumi.Input['TimeChartAxisRightArgs'] axis_right: Set of axis options.
+        :param pulumi.Input[str] color_by: Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]] event_options: Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]] histogram_options: Only used when `plot_type` is `"Histogram"`. Histogram specific options.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] on_chart_legend_dimension: Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
+        :param pulumi.Input[str] plot_type: The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[bool] show_data_markers: Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
+        :param pulumi.Input[bool] show_event_lines: Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
+        :param pulumi.Input[bool] stacked: Whether area and bar charts in the visualization should be stacked. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the chart
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
-        :param pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         if axes_include_zero is not None:
             pulumi.set(__self__, "axes_include_zero", axes_include_zero)
         if axes_precision is not None:
             pulumi.set(__self__, "axes_precision", axes_precision)
         if axis_left is not None:
             pulumi.set(__self__, "axis_left", axis_left)
@@ -585,266 +589,270 @@
         if viz_options is not None:
             pulumi.set(__self__, "viz_options", viz_options)
 
     @property
     @pulumi.getter(name="axesIncludeZero")
     def axes_include_zero(self) -> Optional[pulumi.Input[bool]]:
         """
-        Force y-axes to always show zero
+        Force the chart to display zero on the y-axes, even if none of the data is near zero.
         """
         return pulumi.get(self, "axes_include_zero")
 
     @axes_include_zero.setter
     def axes_include_zero(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "axes_include_zero", value)
 
     @property
     @pulumi.getter(name="axesPrecision")
     def axes_precision(self) -> Optional[pulumi.Input[int]]:
         """
-        Force a specific number of significant digits in the y-axis
+        Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
         """
         return pulumi.get(self, "axes_precision")
 
     @axes_precision.setter
     def axes_precision(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "axes_precision", value)
 
     @property
     @pulumi.getter(name="axisLeft")
     def axis_left(self) -> Optional[pulumi.Input['TimeChartAxisLeftArgs']]:
+        """
+        Set of axis options.
+        """
         return pulumi.get(self, "axis_left")
 
     @axis_left.setter
     def axis_left(self, value: Optional[pulumi.Input['TimeChartAxisLeftArgs']]):
         pulumi.set(self, "axis_left", value)
 
     @property
     @pulumi.getter(name="axisRight")
     def axis_right(self) -> Optional[pulumi.Input['TimeChartAxisRightArgs']]:
+        """
+        Set of axis options.
+        """
         return pulumi.get(self, "axis_right")
 
     @axis_right.setter
     def axis_right(self, value: Optional[pulumi.Input['TimeChartAxisRightArgs']]):
         pulumi.set(self, "axis_right", value)
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> Optional[pulumi.Input[str]]:
         """
-        (Dimension by default) Must be "Dimension" or "Metric"
+        Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @color_by.setter
     def color_by(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "color_by", value)
 
     @property
     @pulumi.getter
     def description(self) -> Optional[pulumi.Input[str]]:
         """
-        Description of the chart
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @description.setter
     def description(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "description", value)
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
         """
         return pulumi.get(self, "disable_sampling")
 
     @disable_sampling.setter
     def disable_sampling(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "disable_sampling", value)
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @end_time.setter
     def end_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "end_time", value)
 
     @property
     @pulumi.getter(name="eventOptions")
     def event_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]]]:
         """
-        Event display customization options, associated with a publish statement
+        Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
         """
         return pulumi.get(self, "event_options")
 
     @event_options.setter
     def event_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartEventOptionArgs']]]]):
         pulumi.set(self, "event_options", value)
 
     @property
     @pulumi.getter(name="histogramOptions")
     def histogram_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]]]:
         """
-        Options specific to Histogram charts
+        Only used when `plot_type` is `"Histogram"`. Histogram specific options.
         """
         return pulumi.get(self, "histogram_options")
 
     @histogram_options.setter
     def histogram_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartHistogramOptionArgs']]]]):
         pulumi.set(self, "histogram_options", value)
 
     @property
     @pulumi.getter(name="legendFieldsToHides")
     def legend_fields_to_hides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
         """
-        List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
+        List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
         """
         warnings.warn("""Please use legend_options_fields""", DeprecationWarning)
         pulumi.log.warn("""legend_fields_to_hides is deprecated: Please use legend_options_fields""")
 
         return pulumi.get(self, "legend_fields_to_hides")
 
     @legend_fields_to_hides.setter
     def legend_fields_to_hides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "legend_fields_to_hides", value)
 
     @property
     @pulumi.getter(name="legendOptionsFields")
     def legend_options_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]]]:
         """
-        List of property and enabled flags to control the order and presence of datatable labels in a chart.
+        List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
         """
         return pulumi.get(self, "legend_options_fields")
 
     @legend_options_fields.setter
     def legend_options_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartLegendOptionsFieldArgs']]]]):
         pulumi.set(self, "legend_options_fields", value)
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> Optional[pulumi.Input[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @max_delay.setter
     def max_delay(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "max_delay", value)
 
     @property
     @pulumi.getter(name="minimumResolution")
     def minimum_resolution(self) -> Optional[pulumi.Input[int]]:
         """
-        The minimum resolution (in seconds) to use for computing the underlying program
+        The minimum resolution (in seconds) to use for computing the underlying program.
         """
         return pulumi.get(self, "minimum_resolution")
 
     @minimum_resolution.setter
     def minimum_resolution(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "minimum_resolution", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
     @property
     @pulumi.getter(name="onChartLegendDimension")
     def on_chart_legend_dimension(self) -> Optional[pulumi.Input[str]]:
         """
-        Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-        'plot_label' and any dimension.
+        Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
         """
         return pulumi.get(self, "on_chart_legend_dimension")
 
     @on_chart_legend_dimension.setter
     def on_chart_legend_dimension(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "on_chart_legend_dimension", value)
 
     @property
     @pulumi.getter(name="plotType")
     def plot_type(self) -> Optional[pulumi.Input[str]]:
         """
-        (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-        "ColumnChart", or "Histogram"
+        The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
         """
         return pulumi.get(self, "plot_type")
 
     @plot_type.setter
     def plot_type(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "plot_type", value)
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> Optional[pulumi.Input[str]]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @program_text.setter
     def program_text(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "program_text", value)
 
     @property
     @pulumi.getter(name="showDataMarkers")
     def show_data_markers(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Show markers (circles) for each datapoint used to draw line or area charts
+        Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
         """
         return pulumi.get(self, "show_data_markers")
 
     @show_data_markers.setter
     def show_data_markers(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_data_markers", value)
 
     @property
     @pulumi.getter(name="showEventLines")
     def show_event_lines(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
+        Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
         """
         return pulumi.get(self, "show_event_lines")
 
     @show_event_lines.setter
     def show_event_lines(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "show_event_lines", value)
 
     @property
     @pulumi.getter
     def stacked(self) -> Optional[pulumi.Input[bool]]:
         """
-        (false by default) Whether area and bar charts in the visualization should be stacked
+        Whether area and bar charts in the visualization should be stacked. `false` by default.
         """
         return pulumi.get(self, "stacked")
 
     @stacked.setter
     def stacked(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "stacked", value)
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @start_time.setter
     def start_time(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "start_time", value)
 
@@ -863,63 +871,63 @@
     def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
         pulumi.set(self, "tags", value)
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> Optional[pulumi.Input[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @time_range.setter
     def time_range(self, value: Optional[pulumi.Input[int]]):
         pulumi.set(self, "time_range", value)
 
     @property
     @pulumi.getter
     def timezone(self) -> Optional[pulumi.Input[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
         """
         return pulumi.get(self, "timezone")
 
     @timezone.setter
     def timezone(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "timezone", value)
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> Optional[pulumi.Input[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @unit_prefix.setter
     def unit_prefix(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "unit_prefix", value)
 
     @property
     @pulumi.getter
     def url(self) -> Optional[pulumi.Input[str]]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @url.setter
     def url(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "url", value)
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
 
     @viz_options.setter
     def viz_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TimeChartVizOptionArgs']]]]):
         pulumi.set(self, "viz_options", value)
 
@@ -960,189 +968,57 @@
         """
         Provides a Splunk Observability Cloud time chart resource. This can be used to create and manage the different types of time charts.
 
         Time charts display data points over a period of time.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `plot_type` - (Optional) The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
-        * `description` - (Optional) Description of the chart.
-        * `axes_precision` - (Optional) Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary`". `"Metric"` by default.
-        * `color_by` - (Optional) Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
-        * `minimum_resolution` - (Optional) The minimum resolution (in seconds) to use for computing the underlying program.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints.
-        * `timezone` - (Optional) A string denotes the geographic region associated with the time zone.
-        * `disable_sampling` - (Optional) If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
-        * `time_range` - (Optional) How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `axes_include_zero` - (Optional) Force the chart to display zero on the y-axes, even if none of the data is near zero.
-        * `axis_left` - (Optional) Set of axis options.
-            * `label` - (Optional) Label of the left axis.
-            * `min_value` - (Optional) The minimum value for the left axis.
-            * `max_value` - (Optional) The maximum value for the left axis.
-            * `high_watermark` - (Optional) A line to draw as a high watermark.
-            * `high_watermark_label` - (Optional) A label to attach to the high watermark line.
-            * `low_watermark`  - (Optional) A line to draw as a low watermark.
-            * `low_watermark_label` - (Optional) A label to attach to the low watermark line.
-        * `axis_right` - (Optional) Set of axis options.
-            * `label` - (Optional) Label of the right axis.
-            * `min_value` - (Optional) The minimum value for the right axis.
-            * `max_value` - (Optional) The maximum value for the right axis.
-            * `high_watermark` - (Optional) A line to draw as a high watermark.
-            * `high_watermark_label` - (Optional) A label to attach to the high watermark line.
-            * `low_watermark`  - (Optional) A line to draw as a low watermark.
-            * `low_watermark_label` - (Optional) A label to attach to the low watermark line.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
-            * `axis` - (Optional) Y-axis associated with values for this plot. Must be either `right` or `left`.
-            * `plot_type` - (Optional) The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-        * `event_options` - (Optional) Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
-            * `label` - (Required) Label used in the publish statement that displays the event query you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
-        * `histogram_options` - (Optional) Only used when `plot_type` is `"Histogram"`. Histogram specific options.
-            * `color_theme` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
-        * `legend_fields_to_hide` - (Optional) List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
-        * `legend_options_fields` - (Optional) List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
-            * `property` The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
-            * `enabled` True or False depending on if you want the property to be shown or hidden.
-        * `on_chart_legend_dimension` - (Optional) Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
-        * `show_event_lines` - (Optional) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
-        * `show_data_markers` - (Optional) Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
-        * `stacked` - (Optional) Whether area and bar charts in the visualization should be stacked. `false` by default.
-        * `timezone` - (Optional) Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] axes_include_zero: Force y-axes to always show zero
-        :param pulumi.Input[int] axes_precision: Force a specific number of significant digits in the y-axis
-        :param pulumi.Input[str] color_by: (Dimension by default) Must be "Dimension" or "Metric"
-        :param pulumi.Input[str] description: Description of the chart
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartEventOptionArgs']]]] event_options: Event display customization options, associated with a publish statement
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartHistogramOptionArgs']]]] histogram_options: Options specific to Histogram charts
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] on_chart_legend_dimension: Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-               'plot_label' and any dimension.
-        :param pulumi.Input[str] plot_type: (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-               "ColumnChart", or "Histogram"
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[bool] show_data_markers: (false by default) Show markers (circles) for each datapoint used to draw line or area charts
-        :param pulumi.Input[bool] show_event_lines: (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
-        :param pulumi.Input[bool] stacked: (false by default) Whether area and bar charts in the visualization should be stacked
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
+        :param pulumi.Input[bool] axes_include_zero: Force the chart to display zero on the y-axes, even if none of the data is near zero.
+        :param pulumi.Input[int] axes_precision: Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
+        :param pulumi.Input[pulumi.InputType['TimeChartAxisLeftArgs']] axis_left: Set of axis options.
+        :param pulumi.Input[pulumi.InputType['TimeChartAxisRightArgs']] axis_right: Set of axis options.
+        :param pulumi.Input[str] color_by: Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartEventOptionArgs']]]] event_options: Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartHistogramOptionArgs']]]] histogram_options: Only used when `plot_type` is `"Histogram"`. Histogram specific options.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] on_chart_legend_dimension: Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
+        :param pulumi.Input[str] plot_type: The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[bool] show_data_markers: Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
+        :param pulumi.Input[bool] show_event_lines: Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
+        :param pulumi.Input[bool] stacked: Whether area and bar charts in the visualization should be stacked. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the chart
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: TimeChartArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
         Provides a Splunk Observability Cloud time chart resource. This can be used to create and manage the different types of time charts.
 
         Time charts display data points over a period of time.
 
         ## Example
 
-        ## Arguments
-
-        The following arguments are supported in the resource block:
-
-        * `name` - (Required) Name of the chart.
-        * `program_text` - (Required) Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
-        * `plot_type` - (Optional) The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
-        * `description` - (Optional) Description of the chart.
-        * `axes_precision` - (Optional) Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
-        * `unit_prefix` - (Optional) Must be `"Metric"` or `"Binary`". `"Metric"` by default.
-        * `color_by` - (Optional) Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
-        * `minimum_resolution` - (Optional) The minimum resolution (in seconds) to use for computing the underlying program.
-        * `max_delay` - (Optional) How long (in seconds) to wait for late datapoints.
-        * `timezone` - (Optional) A string denotes the geographic region associated with the time zone.
-        * `disable_sampling` - (Optional) If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
-        * `time_range` - (Optional) How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
-        * `start_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `end_time` - (Optional) Seconds since epoch. Used for visualization. Conflicts with `time_range`.
-        * `axes_include_zero` - (Optional) Force the chart to display zero on the y-axes, even if none of the data is near zero.
-        * `axis_left` - (Optional) Set of axis options.
-            * `label` - (Optional) Label of the left axis.
-            * `min_value` - (Optional) The minimum value for the left axis.
-            * `max_value` - (Optional) The maximum value for the left axis.
-            * `high_watermark` - (Optional) A line to draw as a high watermark.
-            * `high_watermark_label` - (Optional) A label to attach to the high watermark line.
-            * `low_watermark`  - (Optional) A line to draw as a low watermark.
-            * `low_watermark_label` - (Optional) A label to attach to the low watermark line.
-        * `axis_right` - (Optional) Set of axis options.
-            * `label` - (Optional) Label of the right axis.
-            * `min_value` - (Optional) The minimum value for the right axis.
-            * `max_value` - (Optional) The maximum value for the right axis.
-            * `high_watermark` - (Optional) A line to draw as a high watermark.
-            * `high_watermark_label` - (Optional) A label to attach to the high watermark line.
-            * `low_watermark`  - (Optional) A line to draw as a low watermark.
-            * `low_watermark_label` - (Optional) A label to attach to the low watermark line.
-        * `viz_options` - (Optional) Plot-level customization options, associated with a publish statement.
-            * `label` - (Required) Label used in the publish statement that displays the plot (metric time series data) you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
-            * `axis` - (Optional) Y-axis associated with values for this plot. Must be either `right` or `left`.
-            * `plot_type` - (Optional) The visualization style to use. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Chart level `plot_type` by default.
-            * `value_unit` - (Optional) A unit to attach to this plot. Units support automatic scaling (eg thousands of bytes will be displayed as kilobytes). Values values are `Bit, Kilobit, Megabit, Gigabit, Terabit, Petabit, Exabit, Zettabit, Yottabit, Byte, Kibibyte, Mebibyte, Gibibyte (note: this was previously typoed as Gigibyte), Tebibyte, Pebibyte, Exbibyte, Zebibyte, Yobibyte, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week`.
-            * `value_prefix`, `value_suffix` - (Optional) Arbitrary prefix/suffix to display with the value of this plot.
-        * `event_options` - (Optional) Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
-            * `label` - (Required) Label used in the publish statement that displays the event query you want to customize.
-            * `display_name` - (Optional) Specifies an alternate value for the Plot Name column of the Data Table associated with the chart.
-            * `color` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine.
-        * `histogram_options` - (Optional) Only used when `plot_type` is `"Histogram"`. Histogram specific options.
-            * `color_theme` - (Optional) Color to use : gray, blue, azure, navy, brown, orange, yellow, iris, magenta, pink, purple, violet, lilac, emerald, green, aquamarine, red, gold, greenyellow, chartreuse, jade
-        * `legend_fields_to_hide` - (Optional) List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
-        * `legend_options_fields` - (Optional) List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
-            * `property` The name of the property to display. Note the special values of `plot_label` (corresponding with the API's `sf_metric`) which shows the label of the time series `publish()` and `metric` (corresponding with the API's `sf_originatingMetric`) that shows the name of the metric for the time series being displayed.
-            * `enabled` True or False depending on if you want the property to be shown or hidden.
-        * `on_chart_legend_dimension` - (Optional) Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
-        * `show_event_lines` - (Optional) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
-        * `show_data_markers` - (Optional) Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
-        * `stacked` - (Optional) Whether area and bar charts in the visualization should be stacked. `false` by default.
-        * `timezone` - (Optional) Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the chart.
-        * `url` - The URL of the chart.
-
         :param str resource_name: The name of the resource.
         :param TimeChartArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(TimeChartArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -1261,42 +1137,42 @@
         """
         Get an existing TimeChart resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] axes_include_zero: Force y-axes to always show zero
-        :param pulumi.Input[int] axes_precision: Force a specific number of significant digits in the y-axis
-        :param pulumi.Input[str] color_by: (Dimension by default) Must be "Dimension" or "Metric"
-        :param pulumi.Input[str] description: Description of the chart
-        :param pulumi.Input[bool] disable_sampling: (false by default) If false, samples a subset of the output MTS, which improves UI performance
-        :param pulumi.Input[int] end_time: Seconds since epoch to end the visualization
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartEventOptionArgs']]]] event_options: Event display customization options, associated with a publish statement
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartHistogramOptionArgs']]]] histogram_options: Options specific to Histogram charts
-        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property and enabled flags to control the order and presence of datatable labels in a chart.
-        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints
-        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program
-        :param pulumi.Input[str] name: Name of the chart
-        :param pulumi.Input[str] on_chart_legend_dimension: Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-               'plot_label' and any dimension.
-        :param pulumi.Input[str] plot_type: (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-               "ColumnChart", or "Histogram"
-        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
-        :param pulumi.Input[bool] show_data_markers: (false by default) Show markers (circles) for each datapoint used to draw line or area charts
-        :param pulumi.Input[bool] show_event_lines: (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
-        :param pulumi.Input[bool] stacked: (false by default) Whether area and bar charts in the visualization should be stacked
-        :param pulumi.Input[int] start_time: Seconds since epoch to start the visualization
+        :param pulumi.Input[bool] axes_include_zero: Force the chart to display zero on the y-axes, even if none of the data is near zero.
+        :param pulumi.Input[int] axes_precision: Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
+        :param pulumi.Input[pulumi.InputType['TimeChartAxisLeftArgs']] axis_left: Set of axis options.
+        :param pulumi.Input[pulumi.InputType['TimeChartAxisRightArgs']] axis_right: Set of axis options.
+        :param pulumi.Input[str] color_by: Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
+        :param pulumi.Input[str] description: Description of the chart.
+        :param pulumi.Input[bool] disable_sampling: If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
+        :param pulumi.Input[int] end_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartEventOptionArgs']]]] event_options: Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartHistogramOptionArgs']]]] histogram_options: Only used when `plot_type` is `"Histogram"`. Histogram specific options.
+        :param pulumi.Input[Sequence[pulumi.Input[str]]] legend_fields_to_hides: List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartLegendOptionsFieldArgs']]]] legend_options_fields: List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
+        :param pulumi.Input[int] max_delay: How long (in seconds) to wait for late datapoints.
+        :param pulumi.Input[int] minimum_resolution: The minimum resolution (in seconds) to use for computing the underlying program.
+        :param pulumi.Input[str] name: Name of the chart.
+        :param pulumi.Input[str] on_chart_legend_dimension: Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
+        :param pulumi.Input[str] plot_type: The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
+        :param pulumi.Input[str] program_text: Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
+        :param pulumi.Input[bool] show_data_markers: Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
+        :param pulumi.Input[bool] show_event_lines: Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
+        :param pulumi.Input[bool] stacked: Whether area and bar charts in the visualization should be stacked. `false` by default.
+        :param pulumi.Input[int] start_time: Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: Tags associated with the chart
-        :param pulumi.Input[int] time_range: Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
-        :param pulumi.Input[str] timezone: The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
-        :param pulumi.Input[str] unit_prefix: (Metric by default) Must be "Metric" or "Binary"
-        :param pulumi.Input[str] url: URL of the chart
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement
+        :param pulumi.Input[int] time_range: How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
+        :param pulumi.Input[str] timezone: Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
+        :param pulumi.Input[str] unit_prefix: Must be `"Metric"` or `"Binary`". `"Metric"` by default.
+        :param pulumi.Input[str] url: The URL of the chart.
+        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['TimeChartVizOptionArgs']]]] viz_options: Plot-level customization options, associated with a publish statement.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _TimeChartState.__new__(_TimeChartState)
 
         __props__.__dict__["axes_include_zero"] = axes_include_zero
         __props__.__dict__["axes_precision"] = axes_precision
@@ -1328,182 +1204,186 @@
         __props__.__dict__["viz_options"] = viz_options
         return TimeChart(resource_name, opts=opts, __props__=__props__)
 
     @property
     @pulumi.getter(name="axesIncludeZero")
     def axes_include_zero(self) -> pulumi.Output[Optional[bool]]:
         """
-        Force y-axes to always show zero
+        Force the chart to display zero on the y-axes, even if none of the data is near zero.
         """
         return pulumi.get(self, "axes_include_zero")
 
     @property
     @pulumi.getter(name="axesPrecision")
     def axes_precision(self) -> pulumi.Output[Optional[int]]:
         """
-        Force a specific number of significant digits in the y-axis
+        Specifies the digits Splunk Observability Cloud displays for values plotted on the chart. Defaults to `3`.
         """
         return pulumi.get(self, "axes_precision")
 
     @property
     @pulumi.getter(name="axisLeft")
     def axis_left(self) -> pulumi.Output[Optional['outputs.TimeChartAxisLeft']]:
+        """
+        Set of axis options.
+        """
         return pulumi.get(self, "axis_left")
 
     @property
     @pulumi.getter(name="axisRight")
     def axis_right(self) -> pulumi.Output[Optional['outputs.TimeChartAxisRight']]:
+        """
+        Set of axis options.
+        """
         return pulumi.get(self, "axis_right")
 
     @property
     @pulumi.getter(name="colorBy")
     def color_by(self) -> pulumi.Output[Optional[str]]:
         """
-        (Dimension by default) Must be "Dimension" or "Metric"
+        Must be `"Dimension"` or `"Metric"`. `"Dimension"` by default.
         """
         return pulumi.get(self, "color_by")
 
     @property
     @pulumi.getter
     def description(self) -> pulumi.Output[Optional[str]]:
         """
-        Description of the chart
+        Description of the chart.
         """
         return pulumi.get(self, "description")
 
     @property
     @pulumi.getter(name="disableSampling")
     def disable_sampling(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) If false, samples a subset of the output MTS, which improves UI performance
+        If `false`, samples a subset of the output MTS, which improves UI performance. `false` by default
         """
         return pulumi.get(self, "disable_sampling")
 
     @property
     @pulumi.getter(name="endTime")
     def end_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to end the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "end_time")
 
     @property
     @pulumi.getter(name="eventOptions")
     def event_options(self) -> pulumi.Output[Optional[Sequence['outputs.TimeChartEventOption']]]:
         """
-        Event display customization options, associated with a publish statement
+        Event customization options, associated with a publish statement. You will need to use this to change settings for any `events()` statements you use.
         """
         return pulumi.get(self, "event_options")
 
     @property
     @pulumi.getter(name="histogramOptions")
     def histogram_options(self) -> pulumi.Output[Optional[Sequence['outputs.TimeChartHistogramOption']]]:
         """
-        Options specific to Histogram charts
+        Only used when `plot_type` is `"Histogram"`. Histogram specific options.
         """
         return pulumi.get(self, "histogram_options")
 
     @property
     @pulumi.getter(name="legendFieldsToHides")
     def legend_fields_to_hides(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
-        List of properties that shouldn't be displayed in the chart legend (i.e. dimension names)
+        List of properties that should not be displayed in the chart legend (i.e. dimension names). All the properties are visible by default. Deprecated, please use `legend_options_fields`.
         """
         warnings.warn("""Please use legend_options_fields""", DeprecationWarning)
         pulumi.log.warn("""legend_fields_to_hides is deprecated: Please use legend_options_fields""")
 
         return pulumi.get(self, "legend_fields_to_hides")
 
     @property
     @pulumi.getter(name="legendOptionsFields")
     def legend_options_fields(self) -> pulumi.Output[Optional[Sequence['outputs.TimeChartLegendOptionsField']]]:
         """
-        List of property and enabled flags to control the order and presence of datatable labels in a chart.
+        List of property names and enabled flags that should be displayed in the data table for the chart, in the order provided. This option cannot be used with `legend_fields_to_hide`.
         """
         return pulumi.get(self, "legend_options_fields")
 
     @property
     @pulumi.getter(name="maxDelay")
     def max_delay(self) -> pulumi.Output[Optional[int]]:
         """
-        How long (in seconds) to wait for late datapoints
+        How long (in seconds) to wait for late datapoints.
         """
         return pulumi.get(self, "max_delay")
 
     @property
     @pulumi.getter(name="minimumResolution")
     def minimum_resolution(self) -> pulumi.Output[Optional[int]]:
         """
-        The minimum resolution (in seconds) to use for computing the underlying program
+        The minimum resolution (in seconds) to use for computing the underlying program.
         """
         return pulumi.get(self, "minimum_resolution")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the chart
+        Name of the chart.
         """
         return pulumi.get(self, "name")
 
     @property
     @pulumi.getter(name="onChartLegendDimension")
     def on_chart_legend_dimension(self) -> pulumi.Output[Optional[str]]:
         """
-        Dimension to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: 'metric',
-        'plot_label' and any dimension.
+        Dimensions to show in the on-chart legend. On-chart legend is off unless a dimension is specified. Allowed: `"metric"`, `"plot_label"` and any dimension.
         """
         return pulumi.get(self, "on_chart_legend_dimension")
 
     @property
     @pulumi.getter(name="plotType")
     def plot_type(self) -> pulumi.Output[Optional[str]]:
         """
-        (LineChart by default) The default plot display style for the visualization. Must be "LineChart", "AreaChart",
-        "ColumnChart", or "Histogram"
+        The default plot display style for the visualization. Must be `"LineChart"`, `"AreaChart"`, `"ColumnChart"`, or `"Histogram"`. Default: `"LineChart"`.
         """
         return pulumi.get(self, "plot_type")
 
     @property
     @pulumi.getter(name="programText")
     def program_text(self) -> pulumi.Output[str]:
         """
-        Signalflow program text for the chart. More info at "https://developers.signalfx.com/docs/signalflow-overview"
+        Signalflow program text for the chart. More info [in the Splunk Observability Cloud docs](https://dev.splunk.com/observability/docs/signalflow/).
         """
         return pulumi.get(self, "program_text")
 
     @property
     @pulumi.getter(name="showDataMarkers")
     def show_data_markers(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) Show markers (circles) for each datapoint used to draw line or area charts
+        Show markers (circles) for each datapoint used to draw line or area charts. `false` by default.
         """
         return pulumi.get(self, "show_data_markers")
 
     @property
     @pulumi.getter(name="showEventLines")
     def show_event_lines(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) Whether vertical highlight lines should be drawn in the visualizations at times when events occurred
+        Whether vertical highlight lines should be drawn in the visualizations at times when events occurred. `false` by default.
         """
         return pulumi.get(self, "show_event_lines")
 
     @property
     @pulumi.getter
     def stacked(self) -> pulumi.Output[Optional[bool]]:
         """
-        (false by default) Whether area and bar charts in the visualization should be stacked
+        Whether area and bar charts in the visualization should be stacked. `false` by default.
         """
         return pulumi.get(self, "stacked")
 
     @property
     @pulumi.getter(name="startTime")
     def start_time(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds since epoch to start the visualization
+        Seconds since epoch. Used for visualization. Conflicts with `time_range`.
         """
         return pulumi.get(self, "start_time")
 
     @property
     @pulumi.getter
     def tags(self) -> pulumi.Output[Optional[Sequence[str]]]:
         """
@@ -1514,43 +1394,43 @@
 
         return pulumi.get(self, "tags")
 
     @property
     @pulumi.getter(name="timeRange")
     def time_range(self) -> pulumi.Output[Optional[int]]:
         """
-        Seconds to display in the visualization. This is a rolling range from the current time. Example: 3600 = `-1h`
+        How many seconds ago from which to display data. For example, the last hour would be `3600`, etc. Conflicts with `start_time` and `end_time`.
         """
         return pulumi.get(self, "time_range")
 
     @property
     @pulumi.getter
     def timezone(self) -> pulumi.Output[Optional[str]]:
         """
-        The property value is a string that denotes the geographic region associated with the time zone, (e.g. Australia/Sydney)
+        Time zone that SignalFlow uses as the basis of calendar window transformation methods. For example, if you set "timezone": "Europe/Paris" and then use the transformation sum(cycle="week", cycle_start="Monday") in your chart's SignalFlow program, the calendar window starts on Monday, Paris time. See the [full list of timezones for more](https://dev.splunk.com/observability/docs/signalflow/). `"UTC"` by default.
         """
         return pulumi.get(self, "timezone")
 
     @property
     @pulumi.getter(name="unitPrefix")
     def unit_prefix(self) -> pulumi.Output[Optional[str]]:
         """
-        (Metric by default) Must be "Metric" or "Binary"
+        Must be `"Metric"` or `"Binary`". `"Metric"` by default.
         """
         return pulumi.get(self, "unit_prefix")
 
     @property
     @pulumi.getter
     def url(self) -> pulumi.Output[str]:
         """
-        URL of the chart
+        The URL of the chart.
         """
         return pulumi.get(self, "url")
 
     @property
     @pulumi.getter(name="vizOptions")
     def viz_options(self) -> pulumi.Output[Optional[Sequence['outputs.TimeChartVizOption']]]:
         """
-        Plot-level customization options, associated with a publish statement
+        Plot-level customization options, associated with a publish statement.
         """
         return pulumi.get(self, "viz_options")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/victorops/integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/pagerduty/integration.py`

 * *Files 16% similar despite different names*

```diff
@@ -11,180 +11,156 @@
 
 __all__ = ['IntegrationArgs', 'Integration']
 
 @pulumi.input_type
 class IntegrationArgs:
     def __init__(__self__, *,
                  enabled: pulumi.Input[bool],
-                 name: Optional[pulumi.Input[str]] = None,
-                 post_url: Optional[pulumi.Input[str]] = None):
+                 api_key: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None):
         """
         The set of arguments for constructing a Integration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] post_url: Opsgenie API URL for integration
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] api_key: PagerDuty API key.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         pulumi.set(__self__, "enabled", enabled)
+        if api_key is not None:
+            pulumi.set(__self__, "api_key", api_key)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if post_url is not None:
-            pulumi.set(__self__, "post_url", post_url)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
+    @pulumi.getter(name="apiKey")
+    def api_key(self) -> Optional[pulumi.Input[str]]:
+        """
+        PagerDuty API key.
+        """
+        return pulumi.get(self, "api_key")
+
+    @api_key.setter
+    def api_key(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "api_key", value)
+
+    @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
-    @property
-    @pulumi.getter(name="postUrl")
-    def post_url(self) -> Optional[pulumi.Input[str]]:
-        """
-        Opsgenie API URL for integration
-        """
-        return pulumi.get(self, "post_url")
-
-    @post_url.setter
-    def post_url(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "post_url", value)
-
 
 @pulumi.input_type
 class _IntegrationState:
     def __init__(__self__, *,
+                 api_key: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 post_url: Optional[pulumi.Input[str]] = None):
+                 name: Optional[pulumi.Input[str]] = None):
         """
         Input properties used for looking up and filtering Integration resources.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] post_url: Opsgenie API URL for integration
+        :param pulumi.Input[str] api_key: PagerDuty API key.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
         """
+        if api_key is not None:
+            pulumi.set(__self__, "api_key", api_key)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if post_url is not None:
-            pulumi.set(__self__, "post_url", post_url)
+
+    @property
+    @pulumi.getter(name="apiKey")
+    def api_key(self) -> Optional[pulumi.Input[str]]:
+        """
+        PagerDuty API key.
+        """
+        return pulumi.get(self, "api_key")
+
+    @api_key.setter
+    def api_key(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "api_key", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: Optional[pulumi.Input[bool]]):
         pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
-    @property
-    @pulumi.getter(name="postUrl")
-    def post_url(self) -> Optional[pulumi.Input[str]]:
-        """
-        Opsgenie API URL for integration
-        """
-        return pulumi.get(self, "post_url")
-
-    @post_url.setter
-    def post_url(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "post_url", value)
-
 
 class Integration(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 api_key: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 post_url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Splunk On-Call integrations.
+        Splunk Observability Cloud PagerDuty integrations.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `post_url` - (Optional) Splunk On-Call REST API URL.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] post_url: Opsgenie API URL for integration
+        :param pulumi.Input[str] api_key: PagerDuty API key.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
                  args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Splunk On-Call integrations.
+        Splunk Observability Cloud PagerDuty integrations.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `post_url` - (Optional) Splunk On-Call REST API URL.
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
         resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
@@ -192,81 +168,83 @@
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 api_key: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 post_url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
             __props__ = IntegrationArgs.__new__(IntegrationArgs)
 
+            __props__.__dict__["api_key"] = None if api_key is None else pulumi.Output.secret(api_key)
             if enabled is None and not opts.urn:
                 raise TypeError("Missing required property 'enabled'")
             __props__.__dict__["enabled"] = enabled
             __props__.__dict__["name"] = name
-            __props__.__dict__["post_url"] = post_url
+        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["apiKey"])
+        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
         super(Integration, __self__).__init__(
-            'signalfx:victorops/integration:Integration',
+            'signalfx:pagerduty/integration:Integration',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            api_key: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
-            name: Optional[pulumi.Input[str]] = None,
-            post_url: Optional[pulumi.Input[str]] = None) -> 'Integration':
+            name: Optional[pulumi.Input[str]] = None) -> 'Integration':
         """
         Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] post_url: Opsgenie API URL for integration
+        :param pulumi.Input[str] api_key: PagerDuty API key.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
         __props__ = _IntegrationState.__new__(_IntegrationState)
 
+        __props__.__dict__["api_key"] = api_key
         __props__.__dict__["enabled"] = enabled
         __props__.__dict__["name"] = name
-        __props__.__dict__["post_url"] = post_url
         return Integration(resource_name, opts=opts, __props__=__props__)
 
     @property
+    @pulumi.getter(name="apiKey")
+    def api_key(self) -> pulumi.Output[Optional[str]]:
+        """
+        PagerDuty API key.
+        """
+        return pulumi.get(self, "api_key")
+
+    @property
     @pulumi.getter
     def enabled(self) -> pulumi.Output[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
     def name(self) -> pulumi.Output[str]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
-    @property
-    @pulumi.getter(name="postUrl")
-    def post_url(self) -> pulumi.Output[Optional[str]]:
-        """
-        Opsgenie API URL for integration
-        """
-        return pulumi.get(self, "post_url")
-
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx/webhook_integration.py` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx/opsgenie/integration.py`

 * *Files 26% similar despite different names*

```diff
@@ -3,363 +3,296 @@
 # *** Do not edit by hand unless you're certain you know what you are doing! ***
 
 import copy
 import warnings
 import pulumi
 import pulumi.runtime
 from typing import Any, Mapping, Optional, Sequence, Union, overload
-from . import _utilities
-from . import outputs
-from ._inputs import *
+from .. import _utilities
 
-__all__ = ['WebhookIntegrationArgs', 'WebhookIntegration']
+__all__ = ['IntegrationArgs', 'Integration']
 
 @pulumi.input_type
-class WebhookIntegrationArgs:
+class IntegrationArgs:
     def __init__(__self__, *,
+                 api_key: pulumi.Input[str],
                  enabled: pulumi.Input[bool],
-                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 shared_secret: Optional[pulumi.Input[str]] = None,
-                 url: Optional[pulumi.Input[str]] = None):
+                 api_url: Optional[pulumi.Input[str]] = None,
+                 name: Optional[pulumi.Input[str]] = None):
         """
-        The set of arguments for constructing a WebhookIntegration resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]] headers: HTTP headers to pass in the request
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] url: Webhook URL
+        The set of arguments for constructing a Integration resource.
+        :param pulumi.Input[str] api_key: The API key
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] api_url: Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
+        :param pulumi.Input[str] name: Name of the integration.
         """
+        pulumi.set(__self__, "api_key", api_key)
         pulumi.set(__self__, "enabled", enabled)
-        if headers is not None:
-            pulumi.set(__self__, "headers", headers)
+        if api_url is not None:
+            pulumi.set(__self__, "api_url", api_url)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if shared_secret is not None:
-            pulumi.set(__self__, "shared_secret", shared_secret)
-        if url is not None:
-            pulumi.set(__self__, "url", url)
+
+    @property
+    @pulumi.getter(name="apiKey")
+    def api_key(self) -> pulumi.Input[str]:
+        """
+        The API key
+        """
+        return pulumi.get(self, "api_key")
+
+    @api_key.setter
+    def api_key(self, value: pulumi.Input[str]):
+        pulumi.set(self, "api_key", value)
 
     @property
     @pulumi.getter
     def enabled(self) -> pulumi.Input[bool]:
         """
-        Whether the integration is enabled or not
+        Whether the integration is enabled.
         """
         return pulumi.get(self, "enabled")
 
     @enabled.setter
     def enabled(self, value: pulumi.Input[bool]):
         pulumi.set(self, "enabled", value)
 
     @property
-    @pulumi.getter
-    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]:
+    @pulumi.getter(name="apiUrl")
+    def api_url(self) -> Optional[pulumi.Input[str]]:
         """
-        HTTP headers to pass in the request
+        Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
         """
-        return pulumi.get(self, "headers")
+        return pulumi.get(self, "api_url")
 
-    @headers.setter
-    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]):
-        pulumi.set(self, "headers", value)
+    @api_url.setter
+    def api_url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "api_url", value)
 
     @property
     @pulumi.getter
     def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Name of the integration
+        Name of the integration.
         """
         return pulumi.get(self, "name")
 
     @name.setter
     def name(self, value: Optional[pulumi.Input[str]]):
         pulumi.set(self, "name", value)
 
-    @property
-    @pulumi.getter(name="sharedSecret")
-    def shared_secret(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "shared_secret")
-
-    @shared_secret.setter
-    def shared_secret(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "shared_secret", value)
-
-    @property
-    @pulumi.getter
-    def url(self) -> Optional[pulumi.Input[str]]:
-        """
-        Webhook URL
-        """
-        return pulumi.get(self, "url")
-
-    @url.setter
-    def url(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "url", value)
-
 
 @pulumi.input_type
-class _WebhookIntegrationState:
+class _IntegrationState:
     def __init__(__self__, *,
+                 api_key: Optional[pulumi.Input[str]] = None,
+                 api_url: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
-                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]] = None,
-                 name: Optional[pulumi.Input[str]] = None,
-                 shared_secret: Optional[pulumi.Input[str]] = None,
-                 url: Optional[pulumi.Input[str]] = None):
-        """
-        Input properties used for looking up and filtering WebhookIntegration resources.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]] headers: HTTP headers to pass in the request
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] url: Webhook URL
+                 name: Optional[pulumi.Input[str]] = None):
         """
+        Input properties used for looking up and filtering Integration resources.
+        :param pulumi.Input[str] api_key: The API key
+        :param pulumi.Input[str] api_url: Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
+        """
+        if api_key is not None:
+            pulumi.set(__self__, "api_key", api_key)
+        if api_url is not None:
+            pulumi.set(__self__, "api_url", api_url)
         if enabled is not None:
             pulumi.set(__self__, "enabled", enabled)
-        if headers is not None:
-            pulumi.set(__self__, "headers", headers)
         if name is not None:
             pulumi.set(__self__, "name", name)
-        if shared_secret is not None:
-            pulumi.set(__self__, "shared_secret", shared_secret)
-        if url is not None:
-            pulumi.set(__self__, "url", url)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> Optional[pulumi.Input[bool]]:
+    @pulumi.getter(name="apiKey")
+    def api_key(self) -> Optional[pulumi.Input[str]]:
         """
-        Whether the integration is enabled or not
+        The API key
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "api_key")
 
-    @enabled.setter
-    def enabled(self, value: Optional[pulumi.Input[bool]]):
-        pulumi.set(self, "enabled", value)
+    @api_key.setter
+    def api_key(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "api_key", value)
 
     @property
-    @pulumi.getter
-    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]:
+    @pulumi.getter(name="apiUrl")
+    def api_url(self) -> Optional[pulumi.Input[str]]:
         """
-        HTTP headers to pass in the request
+        Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
         """
-        return pulumi.get(self, "headers")
+        return pulumi.get(self, "api_url")
 
-    @headers.setter
-    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookIntegrationHeaderArgs']]]]):
-        pulumi.set(self, "headers", value)
+    @api_url.setter
+    def api_url(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "api_url", value)
 
     @property
     @pulumi.getter
-    def name(self) -> Optional[pulumi.Input[str]]:
+    def enabled(self) -> Optional[pulumi.Input[bool]]:
         """
-        Name of the integration
+        Whether the integration is enabled.
         """
-        return pulumi.get(self, "name")
-
-    @name.setter
-    def name(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "name", value)
+        return pulumi.get(self, "enabled")
 
-    @property
-    @pulumi.getter(name="sharedSecret")
-    def shared_secret(self) -> Optional[pulumi.Input[str]]:
-        return pulumi.get(self, "shared_secret")
-
-    @shared_secret.setter
-    def shared_secret(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "shared_secret", value)
+    @enabled.setter
+    def enabled(self, value: Optional[pulumi.Input[bool]]):
+        pulumi.set(self, "enabled", value)
 
     @property
     @pulumi.getter
-    def url(self) -> Optional[pulumi.Input[str]]:
+    def name(self) -> Optional[pulumi.Input[str]]:
         """
-        Webhook URL
+        Name of the integration.
         """
-        return pulumi.get(self, "url")
+        return pulumi.get(self, "name")
 
-    @url.setter
-    def url(self, value: Optional[pulumi.Input[str]]):
-        pulumi.set(self, "url", value)
+    @name.setter
+    def name(self, value: Optional[pulumi.Input[str]]):
+        pulumi.set(self, "name", value)
 
 
-class WebhookIntegration(pulumi.CustomResource):
+class Integration(pulumi.CustomResource):
     @overload
     def __init__(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 api_key: Optional[pulumi.Input[str]] = None,
+                 api_url: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
-                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 shared_secret: Optional[pulumi.Input[str]] = None,
-                 url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         """
-        Splunk Observability Cloud webhook integration.
+        Splunk Observability Cloud Opsgenie integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `url` - (Required) The URL to request
-        * `shared_secret` - (Optional)
-        * `headers` - (Optional) A header to send with the request
-          * `header_key` - (Required) The key of the header to send
-          * `header_value` - (Required) The value of the header to send
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]] headers: HTTP headers to pass in the request
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] url: Webhook URL
+        :param pulumi.Input[str] api_key: The API key
+        :param pulumi.Input[str] api_url: Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         ...
     @overload
     def __init__(__self__,
                  resource_name: str,
-                 args: WebhookIntegrationArgs,
+                 args: IntegrationArgs,
                  opts: Optional[pulumi.ResourceOptions] = None):
         """
-        Splunk Observability Cloud webhook integration.
+        Splunk Observability Cloud Opsgenie integration.
 
         > **NOTE** When managing integrations, use a session token of an administrator to authenticate the Splunk Observability Cloud provider. See [Operations that require a session token for an administrator](https://dev.splunk.com/observability/docs/administration/authtokens#Operations-that-require-a-session-token-for-an-administrator). Otherwise you'll receive a 4xx error.
 
         ## Example
 
-        ## Arguments
-
-        * `name` - (Required) Name of the integration.
-        * `enabled` - (Required) Whether the integration is enabled.
-        * `url` - (Required) The URL to request
-        * `shared_secret` - (Optional)
-        * `headers` - (Optional) A header to send with the request
-          * `header_key` - (Required) The key of the header to send
-          * `header_value` - (Required) The value of the header to send
-
-        ## Attributes
-
-        In a addition to all arguments above, the following attributes are exported:
-
-        * `id` - The ID of the integration.
-
         :param str resource_name: The name of the resource.
-        :param WebhookIntegrationArgs args: The arguments to use to populate this resource's properties.
+        :param IntegrationArgs args: The arguments to use to populate this resource's properties.
         :param pulumi.ResourceOptions opts: Options for the resource.
         """
         ...
     def __init__(__self__, resource_name: str, *args, **kwargs):
-        resource_args, opts = _utilities.get_resource_args_opts(WebhookIntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
+        resource_args, opts = _utilities.get_resource_args_opts(IntegrationArgs, pulumi.ResourceOptions, *args, **kwargs)
         if resource_args is not None:
             __self__._internal_init(resource_name, opts, **resource_args.__dict__)
         else:
             __self__._internal_init(resource_name, *args, **kwargs)
 
     def _internal_init(__self__,
                  resource_name: str,
                  opts: Optional[pulumi.ResourceOptions] = None,
+                 api_key: Optional[pulumi.Input[str]] = None,
+                 api_url: Optional[pulumi.Input[str]] = None,
                  enabled: Optional[pulumi.Input[bool]] = None,
-                 headers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]]] = None,
                  name: Optional[pulumi.Input[str]] = None,
-                 shared_secret: Optional[pulumi.Input[str]] = None,
-                 url: Optional[pulumi.Input[str]] = None,
                  __props__=None):
         opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
         if not isinstance(opts, pulumi.ResourceOptions):
             raise TypeError('Expected resource options to be a ResourceOptions instance')
         if opts.id is None:
             if __props__ is not None:
                 raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
-            __props__ = WebhookIntegrationArgs.__new__(WebhookIntegrationArgs)
+            __props__ = IntegrationArgs.__new__(IntegrationArgs)
 
+            if api_key is None and not opts.urn:
+                raise TypeError("Missing required property 'api_key'")
+            __props__.__dict__["api_key"] = None if api_key is None else pulumi.Output.secret(api_key)
+            __props__.__dict__["api_url"] = api_url
             if enabled is None and not opts.urn:
                 raise TypeError("Missing required property 'enabled'")
             __props__.__dict__["enabled"] = enabled
-            __props__.__dict__["headers"] = None if headers is None else pulumi.Output.secret(headers)
             __props__.__dict__["name"] = name
-            __props__.__dict__["shared_secret"] = None if shared_secret is None else pulumi.Output.secret(shared_secret)
-            __props__.__dict__["url"] = url
-        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["headers", "sharedSecret"])
+        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["apiKey"])
         opts = pulumi.ResourceOptions.merge(opts, secret_opts)
-        super(WebhookIntegration, __self__).__init__(
-            'signalfx:index/webhookIntegration:WebhookIntegration',
+        super(Integration, __self__).__init__(
+            'signalfx:opsgenie/integration:Integration',
             resource_name,
             __props__,
             opts)
 
     @staticmethod
     def get(resource_name: str,
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions] = None,
+            api_key: Optional[pulumi.Input[str]] = None,
+            api_url: Optional[pulumi.Input[str]] = None,
             enabled: Optional[pulumi.Input[bool]] = None,
-            headers: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]]] = None,
-            name: Optional[pulumi.Input[str]] = None,
-            shared_secret: Optional[pulumi.Input[str]] = None,
-            url: Optional[pulumi.Input[str]] = None) -> 'WebhookIntegration':
+            name: Optional[pulumi.Input[str]] = None) -> 'Integration':
         """
-        Get an existing WebhookIntegration resource's state with the given name, id, and optional extra
+        Get an existing Integration resource's state with the given name, id, and optional extra
         properties used to qualify the lookup.
 
         :param str resource_name: The unique name of the resulting resource.
         :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
         :param pulumi.ResourceOptions opts: Options for the resource.
-        :param pulumi.Input[bool] enabled: Whether the integration is enabled or not
-        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['WebhookIntegrationHeaderArgs']]]] headers: HTTP headers to pass in the request
-        :param pulumi.Input[str] name: Name of the integration
-        :param pulumi.Input[str] url: Webhook URL
+        :param pulumi.Input[str] api_key: The API key
+        :param pulumi.Input[str] api_url: Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
+        :param pulumi.Input[bool] enabled: Whether the integration is enabled.
+        :param pulumi.Input[str] name: Name of the integration.
         """
         opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))
 
-        __props__ = _WebhookIntegrationState.__new__(_WebhookIntegrationState)
+        __props__ = _IntegrationState.__new__(_IntegrationState)
 
+        __props__.__dict__["api_key"] = api_key
+        __props__.__dict__["api_url"] = api_url
         __props__.__dict__["enabled"] = enabled
-        __props__.__dict__["headers"] = headers
         __props__.__dict__["name"] = name
-        __props__.__dict__["shared_secret"] = shared_secret
-        __props__.__dict__["url"] = url
-        return WebhookIntegration(resource_name, opts=opts, __props__=__props__)
+        return Integration(resource_name, opts=opts, __props__=__props__)
 
     @property
-    @pulumi.getter
-    def enabled(self) -> pulumi.Output[bool]:
+    @pulumi.getter(name="apiKey")
+    def api_key(self) -> pulumi.Output[str]:
         """
-        Whether the integration is enabled or not
+        The API key
         """
-        return pulumi.get(self, "enabled")
+        return pulumi.get(self, "api_key")
 
     @property
-    @pulumi.getter
-    def headers(self) -> pulumi.Output[Optional[Sequence['outputs.WebhookIntegrationHeader']]]:
+    @pulumi.getter(name="apiUrl")
+    def api_url(self) -> pulumi.Output[Optional[str]]:
         """
-        HTTP headers to pass in the request
+        Opsgenie API URL. Will default to `https://api.opsgenie.com`. You might also want `https://api.eu.opsgenie.com`.
         """
-        return pulumi.get(self, "headers")
+        return pulumi.get(self, "api_url")
 
     @property
     @pulumi.getter
-    def name(self) -> pulumi.Output[str]:
+    def enabled(self) -> pulumi.Output[bool]:
         """
-        Name of the integration
+        Whether the integration is enabled.
         """
-        return pulumi.get(self, "name")
-
-    @property
-    @pulumi.getter(name="sharedSecret")
-    def shared_secret(self) -> pulumi.Output[Optional[str]]:
-        return pulumi.get(self, "shared_secret")
+        return pulumi.get(self, "enabled")
 
     @property
     @pulumi.getter
-    def url(self) -> pulumi.Output[Optional[str]]:
+    def name(self) -> pulumi.Output[str]:
         """
-        Webhook URL
+        Name of the integration.
         """
-        return pulumi.get(self, "url")
+        return pulumi.get(self, "name")
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/PKG-INFO` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pulumi_signalfx
-Version: 7.2.0a1716157100
+Version: 7.2.0a1716512682
 Summary: A Pulumi package for creating and managing SignalFx resources.
 License: Apache-2.0
 Project-URL: Homepage, https://pulumi.io
 Project-URL: Repository, https://github.com/pulumi/pulumi-signalfx
 Keywords: pulumi,signalfx
 Requires-Python: >=3.8
 Description-Content-Type: text/markdown
```

### Comparing `pulumi_signalfx-7.2.0a1716157100/pulumi_signalfx.egg-info/SOURCES.txt` & `pulumi_signalfx-7.2.0a1716512682/pulumi_signalfx.egg-info/SOURCES.txt`

 * *Files identical despite different names*

### Comparing `pulumi_signalfx-7.2.0a1716157100/pyproject.toml` & `pulumi_signalfx-7.2.0a1716512682/pyproject.toml`

 * *Files 3% similar despite different names*

```diff
@@ -1,15 +1,15 @@
 [project]
   name = "pulumi_signalfx"
   description = "A Pulumi package for creating and managing SignalFx resources."
   dependencies = ["parver>=0.2.1", "pulumi>=3.0.0,<4.0.0", "semver>=2.8.1"]
   keywords = ["pulumi", "signalfx"]
   readme = "README.md"
   requires-python = ">=3.8"
-  version = "7.2.0a1716157100"
+  version = "7.2.0a1716512682"
   [project.license]
     text = "Apache-2.0"
   [project.urls]
     Homepage = "https://pulumi.io"
     Repository = "https://github.com/pulumi/pulumi-signalfx"
 
 [build-system]
```

