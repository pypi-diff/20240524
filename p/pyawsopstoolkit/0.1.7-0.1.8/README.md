# Comparing `tmp/pyawsopstoolkit-0.1.7-py3-none-any.whl.zip` & `tmp/pyawsopstoolkit-0.1.8-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 28290 bytes, number of entries: 21
--rw-r--r--  2.0 unx      943 b- defN 24-May-22 18:46 pyawsopstoolkit/__init__.py
--rw-r--r--  2.0 unx     4884 b- defN 24-May-22 18:46 pyawsopstoolkit/__interfaces__.py
--rw-r--r--  2.0 unx    16853 b- defN 24-May-22 18:46 pyawsopstoolkit/__main__.py
--rw-r--r--  2.0 unx      780 b- defN 24-May-22 18:46 pyawsopstoolkit/__validations__.py
--rw-r--r--  2.0 unx      761 b- defN 24-May-22 18:46 pyawsopstoolkit/advsearch/__init__.py
--rw-r--r--  2.0 unx    27483 b- defN 24-May-22 18:46 pyawsopstoolkit/advsearch/__main__.py
--rw-r--r--  2.0 unx      605 b- defN 24-May-22 18:46 pyawsopstoolkit/exceptions/__init__.py
--rw-r--r--  2.0 unx     4453 b- defN 24-May-22 18:46 pyawsopstoolkit/exceptions/__main__.py
--rw-r--r--  2.0 unx      512 b- defN 24-May-22 18:46 pyawsopstoolkit/insights/__init__.py
--rw-r--r--  2.0 unx     3482 b- defN 24-May-22 18:46 pyawsopstoolkit/insights/__main__.py
--rw-r--r--  2.0 unx      583 b- defN 24-May-22 18:46 pyawsopstoolkit/models/__init__.py
--rw-r--r--  2.0 unx    29487 b- defN 24-May-22 18:46 pyawsopstoolkit/models/__main__.py
--rw-r--r--  2.0 unx      502 b- defN 24-May-22 18:46 pyawsopstoolkit/security/__init__.py
--rw-r--r--  2.0 unx     2822 b- defN 24-May-22 18:46 pyawsopstoolkit/security/__main__.py
--rw-r--r--  2.0 unx      874 b- defN 24-May-22 18:46 pyawsopstoolkit/validators/__init__.py
--rw-r--r--  2.0 unx    30261 b- defN 24-May-22 18:46 pyawsopstoolkit/validators/__main__.py
--rw-r--r--  2.0 unx     1069 b- defN 24-May-22 18:46 pyawsopstoolkit-0.1.7.dist-info/LICENSE
--rw-r--r--  2.0 unx     8776 b- defN 24-May-22 18:46 pyawsopstoolkit-0.1.7.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-May-22 18:46 pyawsopstoolkit-0.1.7.dist-info/WHEEL
--rw-r--r--  2.0 unx       16 b- defN 24-May-22 18:46 pyawsopstoolkit-0.1.7.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1893 b- defN 24-May-22 18:46 pyawsopstoolkit-0.1.7.dist-info/RECORD
-21 files, 137131 bytes uncompressed, 25156 bytes compressed:  81.7%
+Zip file size: 30754 bytes, number of entries: 21
+-rw-r--r--  2.0 unx      943 b- defN 24-May-24 21:00 pyawsopstoolkit/__init__.py
+-rw-r--r--  2.0 unx     4884 b- defN 24-May-24 21:00 pyawsopstoolkit/__interfaces__.py
+-rw-r--r--  2.0 unx    16853 b- defN 24-May-24 21:00 pyawsopstoolkit/__main__.py
+-rw-r--r--  2.0 unx      780 b- defN 24-May-24 21:00 pyawsopstoolkit/__validations__.py
+-rw-r--r--  2.0 unx      761 b- defN 24-May-24 21:00 pyawsopstoolkit/advsearch/__init__.py
+-rw-r--r--  2.0 unx    35284 b- defN 24-May-24 21:00 pyawsopstoolkit/advsearch/__main__.py
+-rw-r--r--  2.0 unx      605 b- defN 24-May-24 21:00 pyawsopstoolkit/exceptions/__init__.py
+-rw-r--r--  2.0 unx     4453 b- defN 24-May-24 21:00 pyawsopstoolkit/exceptions/__main__.py
+-rw-r--r--  2.0 unx      512 b- defN 24-May-24 21:00 pyawsopstoolkit/insights/__init__.py
+-rw-r--r--  2.0 unx     6170 b- defN 24-May-24 21:00 pyawsopstoolkit/insights/__main__.py
+-rw-r--r--  2.0 unx      679 b- defN 24-May-24 21:00 pyawsopstoolkit/models/__init__.py
+-rw-r--r--  2.0 unx    43380 b- defN 24-May-24 21:00 pyawsopstoolkit/models/__main__.py
+-rw-r--r--  2.0 unx      502 b- defN 24-May-24 21:00 pyawsopstoolkit/security/__init__.py
+-rw-r--r--  2.0 unx     2822 b- defN 24-May-24 21:00 pyawsopstoolkit/security/__main__.py
+-rw-r--r--  2.0 unx      874 b- defN 24-May-24 21:00 pyawsopstoolkit/validators/__init__.py
+-rw-r--r--  2.0 unx    30261 b- defN 24-May-24 21:00 pyawsopstoolkit/validators/__main__.py
+-rw-r--r--  2.0 unx     1069 b- defN 24-May-24 21:00 pyawsopstoolkit-0.1.8.dist-info/LICENSE
+-rw-r--r--  2.0 unx     8776 b- defN 24-May-24 21:00 pyawsopstoolkit-0.1.8.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-May-24 21:00 pyawsopstoolkit-0.1.8.dist-info/WHEEL
+-rw-r--r--  2.0 unx       16 b- defN 24-May-24 21:00 pyawsopstoolkit-0.1.8.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1893 b- defN 24-May-24 21:00 pyawsopstoolkit-0.1.8.dist-info/RECORD
+21 files, 161609 bytes uncompressed, 27620 bytes compressed:  82.9%
```

## zipnote {}

```diff
@@ -42,23 +42,23 @@
 
 Filename: pyawsopstoolkit/validators/__init__.py
 Comment: 
 
 Filename: pyawsopstoolkit/validators/__main__.py
 Comment: 
 
-Filename: pyawsopstoolkit-0.1.7.dist-info/LICENSE
+Filename: pyawsopstoolkit-0.1.8.dist-info/LICENSE
 Comment: 
 
-Filename: pyawsopstoolkit-0.1.7.dist-info/METADATA
+Filename: pyawsopstoolkit-0.1.8.dist-info/METADATA
 Comment: 
 
-Filename: pyawsopstoolkit-0.1.7.dist-info/WHEEL
+Filename: pyawsopstoolkit-0.1.8.dist-info/WHEEL
 Comment: 
 
-Filename: pyawsopstoolkit-0.1.7.dist-info/top_level.txt
+Filename: pyawsopstoolkit-0.1.8.dist-info/top_level.txt
 Comment: 
 
-Filename: pyawsopstoolkit-0.1.7.dist-info/RECORD
+Filename: pyawsopstoolkit-0.1.8.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pyawsopstoolkit/__init__.py

```diff
@@ -5,15 +5,15 @@
     "advsearch",
     "exceptions",
     "insights",
     "models",
     "validators"
 ]
 __name__ = "pyawsopstoolkit"
-__version__ = "0.1.7"
+__version__ = "0.1.8"
 __description__ = """
 This extensive package, AWS Ops Toolkit, offers a wide range of features and enhancements designed to streamline
 and optimize interactions with Amazon Web Services (AWS). As of now, the toolkit includes a robust set of
 functionalities including validators for ensuring the correctness of AWS ARNs, IAM policy formats, and more.
 Furthermore, it provides session management classes tailored for seamless integration within the application
 ecosystem, complete with a versatile assume role function.
```

## pyawsopstoolkit/advsearch/__main__.py

```diff
@@ -1,15 +1,16 @@
 import re
 from concurrent.futures import ThreadPoolExecutor, as_completed
 from datetime import datetime
-from typing import Any
+from typing import Any, Optional
 
 import pyawsopstoolkit.models
 from pyawsopstoolkit.__interfaces__ import IAccount, ISession
 from pyawsopstoolkit.__validations__ import Validation
+from pyawsopstoolkit.models import IAMUserLoginProfile, IAMUserAccessKey
 
 MAX_WORKERS = 10
 
 # This module supports various conditions for advanced searches, outlined below as global constants.
 OR: str = 'OR'  # Represents the "or" condition
 AND: str = 'AND'  # Represents the "and" condition
 
@@ -18,36 +19,40 @@
 GREATER_THAN: str = 'gt'  # Represents the greater than (">") value
 GREATER_THAN_OR_EQUAL_TO: str = 'gte'  # Represents the greater than or equal to (">=") value
 EQUAL_TO: str = 'eq'  # Represents the equal to ("=") value
 NOT_EQUAL_TO: str = 'ne'  # Represents the not equal to ("!=") value
 BETWEEN: str = 'between'  # Represents the between range ("< x <") value
 
 
-def _match_condition(value: str, role_field: str, condition: str, matched: bool) -> bool:
+def _match_condition(value: str, role_field: str | list, condition: str, matched: bool) -> bool:
     """
     Matches the condition based on the specified parameters.
     :param value: The value to be evaluated.
     :type value: str
-    :param role_field: The value to compare against.
-    :type role_field: str
+    :param role_field: The value or list of values to compare against.
+    :type role_field: str | list
     :param condition: The condition to be applied: 'OR' or 'AND'.
     :type condition: str
     :param matched: The current matching status.
     :type matched: bool
     :return: Returns a boolean value (True or False) based on the comparison.
     :rtype: bool
     """
     if not value or not role_field:
         return False
 
-    if re.search(value, role_field, re.IGNORECASE):
-        if condition == OR:
-            return True
+    if isinstance(role_field, str):
+        role_field = [role_field]
+
+    found_match = any(re.search(value, field, re.IGNORECASE) for field in role_field)
+
+    if condition == OR:
+        return matched or found_match
     elif condition == AND:
-        return False
+        return matched and found_match if matched else found_match
 
     return matched
 
 
 def _match_compare_condition(value: dict, role_field: Any, condition: str, matched: bool) -> bool:
     """
     Matches the condition by comparing based on the specified parameters.
@@ -217,14 +222,36 @@
             for page in iam_paginator.paginate():
                 users_to_process.extend(page.get('Users', []))
         except ClientError as e:
             raise e
 
         return users_to_process
 
+    def _list_access_keys(self, user_name: str) -> list:
+        """
+        Utilizing boto3 IAM, this method retrieves a list of all access keys associated with IAM user leveraging the
+        provided ISession object. For further details,
+        https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/iam/paginator/ListAccessKeys.html
+        :return: A list containing IAM user access keys.
+        :rtype: list
+        """
+        access_keys_to_process = []
+
+        from botocore.exceptions import ClientError
+        try:
+            iam_client = self.session.get_session().client('iam')
+            iam_paginator = iam_client.get_paginator('list_access_keys')
+
+            for page in iam_paginator.paginate(UserName=user_name):
+                access_keys_to_process.extend(page.get('AccessKeyMetadata', []))
+        except ClientError as e:
+            raise e
+
+        return access_keys_to_process
+
     def _get_role(self, role_name: str) -> dict:
         """
         Utilizing boto3 IAM, this method retrieves comprehensive details of an IAM role identified by the
         specified role name.
         :return: Details of the IAM role.
         :rtype: dict
         """
@@ -245,14 +272,42 @@
         from botocore.exceptions import ClientError
         try:
             iam_client = self.session.get_session().client('iam')
             return iam_client.get_user(UserName=user_name)
         except ClientError as e:
             raise e
 
+    def _get_login_profile(self, user_name: str) -> dict:
+        """
+        Utilizing boto3 IAM, this method retrieves comprehensive details of an IAM user login profile identified
+        by the specified username.
+        :return: Details of the IAM user login profile.
+        :rtype: dict
+        """
+        from botocore.exceptions import ClientError
+        try:
+            iam_client = self.session.get_session().client('iam')
+            return iam_client.get_login_profile(UserName=user_name)
+        except ClientError as e:
+            raise e
+
+    def _get_access_key_last_used(self, access_key_id: str) -> dict:
+        """
+        Utilizing boto3 IAM, this method retrieves comprehensive details of IAM user access key last used information
+        identified by the specified username.
+        :return: Details of the IAM user access key last used.
+        :rtype: dict
+        """
+        from botocore.exceptions import ClientError
+        try:
+            iam_client = self.session.get_session().client('iam')
+            return iam_client.get_access_key_last_used(AccessKeyId=access_key_id)
+        except ClientError as e:
+            raise e
+
     @staticmethod
     def _convert_to_iam_role(account: IAccount, role: dict) -> pyawsopstoolkit.models.IAMRole:
         """
         This function transforms the dictionary response from boto3 IAM into a format compatible with the
         AWS Ops Toolkit, adhering to the pyawsopstoolkit.models structure. Additionally, it incorporates
         account-related summary information into the IAM role details.
         :param account: An IAccount object containing AWS account information.
@@ -293,23 +348,32 @@
         _tags = role.get('Tags', [])
         if _tags:
             iam_role.tags = _tags
 
         return iam_role
 
     @staticmethod
-    def _convert_to_iam_user(account: IAccount, user: dict) -> pyawsopstoolkit.models.IAMUser:
+    def _convert_to_iam_user(
+            account: IAccount,
+            user: dict,
+            login_profile: Optional[dict] = None,
+            access_keys: Optional[list] = None
+    ) -> pyawsopstoolkit.models.IAMUser:
         """
         This function transforms the dictionary response from boto3 IAM into a format compatible with the
         AWS Ops Toolkit, adhering to the pyawsopstoolkit.models structure. Additionally, it incorporates
         account-related summary information into the IAM user details.
         :param account: An IAccount object containing AWS account information.
         :type account: IAccount
         :param user: The boto3 IAM service response for an IAM user.
         :type user: dict
+        :param login_profile: The boto3 IAM login profile service response for an IAM user.
+        :type login_profile: dict
+        :param access_keys: The boto3 IAM access keys service response for an IAM user.
+        :type access_keys: list
         :return: An AWS Ops Toolkit compatible object containing all IAM user details.
         :rtype: IAMUser
         """
         iam_user = pyawsopstoolkit.models.IAMUser(
             account=account,
             name=user.get('UserName', ''),
             id=user.get('UserId', ''),
@@ -323,14 +387,36 @@
         if _permissions_boundary:
             boundary = pyawsopstoolkit.models.IAMPermissionsBoundary(
                 type=_permissions_boundary.get('PermissionsBoundaryType', ''),
                 arn=_permissions_boundary.get('PermissionsBoundaryArn', '')
             )
             iam_user.permissions_boundary = boundary
 
+        if login_profile is not None:
+            _login_profile = IAMUserLoginProfile(
+                created_date=login_profile.get('CreateDate', None),
+                password_reset_required=login_profile.get('PasswordResetRequired', False)
+            )
+            iam_user.login_profile = _login_profile
+
+        if access_keys is not None:
+            for a_key in access_keys:
+                _access_key = IAMUserAccessKey(
+                    id=a_key.get('access_key', {}).get('AccessKeyId', ''),
+                    status=a_key.get('access_key', {}).get('Status', ''),
+                    created_date=a_key.get('access_key', {}).get('CreateDate', None),
+                    last_used_date=a_key.get('last_used', {}).get('AccessKeyLastUsed', {}).get('LastUsedDate', None),
+                    last_used_service=a_key.get('last_used', {}).get('AccessKeyLastUsed', {}).get('ServiceName', None),
+                    last_used_region=a_key.get('last_used', {}).get('AccessKeyLastUsed', {}).get('Region', None)
+                )
+                if iam_user.access_keys is None:
+                    iam_user.access_keys = [_access_key]
+                else:
+                    iam_user.access_keys.append(_access_key)
+
         _tags = user.get('Tags', [])
         if _tags:
             iam_user.tags = _tags
 
         return iam_user
 
     def search_roles(
@@ -430,23 +516,26 @@
                     return _process_role(role_detail)
 
         roles_to_return = []
 
         from botocore.exceptions import ClientError
         try:
             include_details_keys = {
-                'permissions_boundary_type', 'permissions_boundary_arn', 'last_used_date', 'last_used_region',
-                'tag', 'tag_key'
+                'permissions_boundary_type',
+                'permissions_boundary_arn',
+                'last_used_date',
+                'last_used_region',
+                'tag',
+                'tag_key'
             }
 
             if not include_details and any(k in include_details_keys for k in kwargs):
                 from pyawsopstoolkit.exceptions import SearchAttributeError
                 raise SearchAttributeError(
-                    'include_details is required for below keys: permissions_boundary_type, '
-                    'permissions_boundary_arn, last_used_date, last_used_region, tag, tag_key.'
+                    f'include_details is required for below keys: {", ".join(sorted(include_details_keys))}'
                 )
 
             roles_to_process = self._list_roles()
 
             if len(kwargs) == 0:
                 with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
                     future_to_role = {executor.submit(_process_role, role): role for role in roles_to_process}
@@ -484,18 +573,30 @@
         :return: A list of IAM users.
         :rtype: list
         """
         Validation.validate_type(condition, str, 'condition should be a string and should be either "OR" or "AND".')
         Validation.validate_type(include_details, bool, 'include_details should be a boolean.')
 
         def _process_user(user_detail):
+            login_profile_detail = None
+            access_keys_detail = []
+
             if include_details:
                 user_detail = self._get_user(user_detail.get('UserName', '')).get('User', {})
+                login_profile_detail = self._get_login_profile(user_detail.get('UserName', '')).get('LoginProfile', {})
+                for a_key in self._list_access_keys(user_detail.get('UserName', '')):
+                    a_key_last_used = self._get_access_key_last_used(a_key.get('AccessKeyId', ''))
+                    access_keys_detail.append({
+                        'access_key': a_key,
+                        'last_used': a_key_last_used
+                    })
 
-            return self._convert_to_iam_user(self.session.get_account(), user_detail)
+            return self._convert_to_iam_user(
+                self.session.get_account(), user_detail, login_profile_detail, access_keys_detail
+            )
 
         def _match_user(user_detail):
             if user_detail:
                 matched = False if condition == OR else True
                 for key, value in kwargs.items():
                     if value is not None:
                         user_field = ''
@@ -533,39 +634,86 @@
                                 tags = {tag['Key']: tag['Value'] for tag in user_detail.get('Tags', [])}
                                 matched = _match_tag_condition(value, tags, condition, matched, key_only=True)
                         elif key.lower() == 'tag':
                             if include_details:
                                 user_detail = self._get_user(user_detail.get('UserName', '')).get('User', {})
                                 tags = {tag['Key']: tag['Value'] for tag in user_detail.get('Tags', [])}
                                 matched = _match_tag_condition(value, tags, condition, matched, key_only=False)
+                        elif key.lower() == 'login_profile_created_date':
+                            if include_details:
+                                login_profile_detail = (
+                                    self._get_login_profile(user_detail.get('UserName', '')).get('LoginProfile', {})
+                                )
+                                user_field = login_profile_detail.get('CreateDate', None)
+                                if isinstance(user_field, datetime):
+                                    user_field = user_field.replace(tzinfo=None)
+                                    matched = _match_compare_condition(value, user_field, condition, matched)
+                        elif key.lower() == 'login_profile_password_reset_required':
+                            if include_details:
+                                login_profile_detail = (
+                                    self._get_login_profile(user_detail.get('UserName', '')).get('LoginProfile', {})
+                                )
+                                user_field = login_profile_detail.get('PasswordResetRequired', False)
+                        elif key.lower() == 'access_key_id':
+                            if include_details:
+                                user_field = []
+                                for access_key in self._list_access_keys(user_detail.get('UserName', '')):
+                                    user_field.append(access_key.get('AccessKeyId', ''))
+                        elif key.lower() == 'access_key_status':
+                            if include_details:
+                                user_field = []
+                                for access_key in self._list_access_keys(user_detail.get('UserName', '')):
+                                    user_field.append(access_key.get('Status', ''))
+                        elif key.lower() == 'access_key_service':
+                            if include_details:
+                                user_field = []
+                                for access_key in self._list_access_keys(user_detail.get('UserName', '')):
+                                    detail = self._get_access_key_last_used(access_key.get('AccessKeyId', ''))
+                                    if detail is not None:
+                                        user_field.append(detail.get('AccessKeyLastUsed', {}).get('ServiceName', ''))
+                        elif key.lower() == 'access_key_region':
+                            if include_details:
+                                user_field = []
+                                for access_key in self._list_access_keys(user_detail.get('UserName', '')):
+                                    detail = self._get_access_key_last_used(access_key.get('AccessKeyId', ''))
+                                    if detail is not None:
+                                        user_field.append(detail.get('AccessKeyLastUsed', {}).get('Region', ''))
 
                         if key.lower() not in [
-                            'created_date', 'password_last_used_date', 'tag_key', 'tag'
+                            'created_date', 'password_last_used_date', 'tag_key', 'tag', 'login_profile_created_date'
                         ]:
                             matched = _match_condition(value, user_field, condition, matched)
 
                         if (condition == OR and matched) or (condition == AND and not matched):
                             break
 
                 if matched:
                     return _process_user(user_detail)
 
         users_to_return = []
 
         from botocore.exceptions import ClientError
         try:
             include_details_keys = {
-                'permissions_boundary_type', 'permissions_boundary_arn', 'tag', 'tag_key'
+                'permissions_boundary_type',
+                'permissions_boundary_arn',
+                'tag',
+                'tag_key',
+                'login_profile_created_date',
+                'login_profile_password_reset_required',
+                'access_key_id',
+                'access_key_status',
+                'access_key_service',
+                'access_key_region'
             }
 
             if not include_details and any(k in include_details_keys for k in kwargs):
                 from pyawsopstoolkit.exceptions import SearchAttributeError
                 raise SearchAttributeError(
-                    'include_details is required for below keys: permissions_boundary_type, '
-                    'permissions_boundary_arn, tag, tag_key.'
+                    f'include_details is required for below keys: {", ".join(sorted(include_details_keys))}'
                 )
 
             users_to_process = self._list_users()
 
             if len(kwargs) == 0:
                 with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
                     future_to_user = {executor.submit(_process_user, user): user for user in users_to_process}
```

## pyawsopstoolkit/insights/__main__.py

```diff
@@ -93,7 +93,77 @@
                     if (
                             (current_date - role.created_date.replace(tzinfo=None)).days > no_of_days
                             and role_is_unused(role)
                     ):
                         unused_roles_list.append(role)
 
         return unused_roles_list
+
+    def unused_users(
+            self,
+            no_of_days: Optional[int] = 90,
+            include_newly_created: Optional[bool] = False
+    ) -> list[pyawsopstoolkit.models.IAMUser]:
+        """
+        Returns a list of unused IAM users based on the specified parameters.
+        :param no_of_days: The number of days (integer) to check if the IAM user has been used within the
+        specified period. Defaults to 90 days.
+        :type no_of_days: int
+        :param include_newly_created: A flag indicating whether to include newly created IAM users within the
+        specified number of days. Defaults to False.
+        :type include_newly_created: bool
+        :return: A list of unused IAM users.
+        :rtype: list
+        """
+        Validation.validate_type(no_of_days, int, 'no_of_days should be an integer.')
+        Validation.validate_type(include_newly_created, bool, 'include_newly_created should be a boolean.')
+
+        from pyawsopstoolkit import advsearch
+
+        current_date = datetime.today().replace(tzinfo=None)
+        iam_object = advsearch.IAM(self.session)
+        iam_users = iam_object.search_users(include_details=True)
+
+        if iam_users is None:
+            return []
+
+        def user_is_unused(_user):
+            _last_login = None
+            _access_key_last_used = None
+
+            if _user.login_profile is not None:
+                _last_login = _user.login_profile.created_date
+
+            if _user.access_keys is not None:
+                for _key in _user.access_keys:
+                    _last_used_date = _key.last_used_date
+                    if not _access_key_last_used or _last_used_date > _access_key_last_used:
+                        _access_key_last_used = _last_used_date
+
+            _password_last_used = _user.password_last_used_date
+
+            _recent_activity_date: datetime = max(
+                filter(None, [_last_login, _access_key_last_used, _password_last_used]), default=None
+            )
+
+            if _recent_activity_date is None:
+                return True
+
+            if (current_date - _recent_activity_date.replace(tzinfo=None)).days <= no_of_days:
+                return False
+
+            return True
+
+        unused_users_list = []
+
+        for user in iam_users:
+            if include_newly_created:
+                if user_is_unused(user):
+                    unused_users_list.append(user)
+            else:
+                if (
+                        (current_date - user.created_date.replace(tzinfo=None)).days > no_of_days
+                        and user_is_unused(user)
+                ):
+                    unused_users_list.append(user)
+
+        return unused_users_list
```

## pyawsopstoolkit/models/__init__.py

```diff
@@ -1,15 +1,18 @@
 __all__ = [
     "IAMRole",
     "IAMUser",
     "IAMRoleLastUsed",
+    "IAMUserLoginProfile",
+    "IAMUserAccessKey",
     "IAMPermissionsBoundary"
 ]
 __name__ = "pyawsopstoolkit.models"
 __description__ = """
 This package provides a comprehensive collection of data model classes specifically designed for various
 AWS Ops Toolkit packages, such as finops and advsearch. These models are meticulously crafted to align
 closely with AWS services and their respective properties, ensuring seamless integration and optimal
 performance.
 """
 
-from pyawsopstoolkit.models.__main__ import IAMRole, IAMRoleLastUsed, IAMPermissionsBoundary, IAMUser
+from pyawsopstoolkit.models.__main__ import IAMRole, IAMRoleLastUsed, IAMPermissionsBoundary, IAMUser, \
+    IAMUserLoginProfile, IAMUserAccessKey
```

## pyawsopstoolkit/models/__main__.py

```diff
@@ -105,16 +105,15 @@
         """
         Initializes the IAMRoleLastUsed instance with optional used_date and region.
         :param used_date: The last date and time the IAM role was used.
         :type used_date: datetime
         :param region: The AWS region where the IAM role was last used.
         :type region: str
         """
-        if used_date is not None:
-            Validation.validate_type(used_date, Union[datetime, None], 'used_date should be a datetime.')
+        Validation.validate_type(used_date, Union[datetime, None], 'used_date should be a datetime.')
 
         if region is not None:
             Validator.region(region, True)
 
         self._used_date = used_date
         self._region = region
 
@@ -183,14 +182,310 @@
 
         return {
             "used_date": used_date,
             "region": region
         }
 
 
+class IAMUserLoginProfile:
+    """
+    A class representing the login profile information of an IAM user.
+    """
+
+    def __init__(
+            self,
+            created_date: Optional[datetime] = None,
+            password_reset_required: Optional[bool] = False
+    ) -> None:
+        """
+        Initialize the IAMUserLoginProfile object.
+        :param created_date: The created date of the IAM user login profile.
+        :type created_date: datetime
+        :param password_reset_required: Flag to indicate if password reset required for the IAM user. Defaults to False.
+        :type password_reset_required: bool
+        """
+        Validation.validate_type(created_date, Union[datetime, None], 'created_date should be a datetime.')
+        Validation.validate_type(password_reset_required, bool, 'password_reset_required should be a boolean.')
+
+        self._created_date = created_date
+        self._password_reset_required = password_reset_required
+
+    @property
+    def created_date(self) -> Optional[datetime]:
+        """
+        Gets the created date of the IAM user login profile.
+        :return: The created date of the IAM user login profile.
+        :rtype: datetime
+        """
+        return self._created_date
+
+    @created_date.setter
+    def created_date(self, value: Optional[datetime]) -> None:
+        """
+        Sets the created date of the IAM user login profile.
+        :param value: The created date of the IAM user login profile.
+        :type value: datetime
+        """
+        Validation.validate_type(value, Union[datetime, None], 'created_date should be a datetime.')
+
+        self._created_date = value
+
+    @property
+    def password_reset_required(self) -> Optional[bool]:
+        """
+        Gets the flag to indicate if password reset required for the IAM user.
+        :return: Flag to indicate if password reset required for the IAM user.
+        :rtype: bool
+        """
+        return self._password_reset_required
+
+    @password_reset_required.setter
+    def password_reset_required(self, value: Optional[bool] = False) -> None:
+        """
+        Sets the flag to indicate if password reset required for the IAM user.
+        :param value: The flag to indicate if password reset required for the IAM user. Defaults to False.
+        :type value: bool
+        """
+        Validation.validate_type(value, bool, 'password_reset_required should be a boolean.')
+
+        self._password_reset_required = value
+
+    def __str__(self) -> str:
+        """
+        Return a string representation of the IAMUserLoginProfile object.
+        :return: String representation of the IAMUserLoginProfile object.
+        :rtype: str
+        """
+        created_date = self.created_date.isoformat() if self.created_date else None
+
+        return (
+            f'IAMUserLoginProfile('
+            f'created_date={created_date},'
+            f'password_reset_required={self.password_reset_required}'
+            f')'
+        )
+
+    def __dict__(self) -> dict:
+        """
+        Return a dictionary representation of the IAMUserLoginProfile object.
+        :return: Dictionary representation of the IAMUserLoginProfile object.
+        :rtype: dict
+        """
+        created_date = self.created_date.isoformat() if self.created_date else None
+
+        return {
+            "created_date": created_date,
+            "password_reset_required": self.password_reset_required
+        }
+
+
+class IAMUserAccessKey:
+    """
+    A class representing the access key information of an IAM user.
+    """
+
+    def __init__(
+            self,
+            id: str,
+            status: str,
+            created_date: Optional[datetime] = None,
+            last_used_date: Optional[datetime] = None,
+            last_used_service: Optional[str] = None,
+            last_used_region: Optional[str] = None
+    ) -> None:
+        """
+        Initializes the IAMUserAccessKey instance.
+        :param id: The ID of the IAM user access key.
+        :type id: str
+        :param status: The status of the IAM user access key.
+        :type status: str
+        :param created_date: The created date of the IAM user access key. Defaults to None.
+        :type created_date: datetime
+        :param last_used_date: The last used date of the IAM user access key. Defaults to None.
+        :type last_used_date: datetime
+        :param last_used_service: The last used service of the IAM user access key. Defaults to None.
+        :type last_used_service: str
+        :param last_used_region: The last used region of the IAM user access key. Defaults to None.
+        :type last_used_region: str
+        """
+        Validation.validate_type(id, str, 'id should be a string.')
+        Validation.validate_type(status, str, 'status should be a string.')
+        Validation.validate_type(created_date, Union[datetime, None], 'created_date should be a datetime.')
+        Validation.validate_type(last_used_date, Union[datetime, None], 'last_used_date should be a datetime.')
+        Validation.validate_type(last_used_service, Union[str, None], 'last_used_service should be a string.')
+        if last_used_region is not None:
+            Validator.region(last_used_region)
+
+        self._id = id
+        self._status = status
+        self._created_date = created_date
+        self._last_used_date = last_used_date
+        self._last_used_service = last_used_service
+        self._last_used_region = last_used_region
+
+    @property
+    def created_date(self) -> Optional[datetime]:
+        """
+        Gets the created date of the IAM user access key.
+        :return: The created date of the IAM user access key.
+        :rtype: datetime
+        """
+        return self._created_date
+
+    @created_date.setter
+    def created_date(self, value: Optional[datetime]) -> None:
+        """
+        Sets the created date of the IAM user access key.
+        :param value: The created date of the IAM user access key.
+        :type value: datetime
+        """
+        Validation.validate_type(value, Union[datetime, None], 'created_date should be a datetime.')
+
+        self._created_date = value
+
+    @property
+    def id(self) -> str:
+        """
+        Gets the ID of the IAM user access key.
+        :return: The ID of the IAM user access key.
+        :rtype: str
+        """
+        return self._id
+
+    @id.setter
+    def id(self, value: str) -> None:
+        """
+        Sets the ID of the IAM user access key.
+        :param value: The ID of the IAM user access key.
+        :type value: str
+        """
+        Validation.validate_type(value, str, 'id should be a string.')
+
+        self._id = value
+
+    @property
+    def last_used_date(self) -> Optional[datetime]:
+        """
+        Gets the last used date of the IAM user access key.
+        :return: The last used date of the IAM user access key.
+        :rtype: datetime
+        """
+        return self._last_used_date
+
+    @last_used_date.setter
+    def last_used_date(self, value: Optional[datetime]) -> None:
+        """
+        Sets the last used date of the IAM user access key.
+        :param value: The last used date of the IAM user access key.
+        :type value: datetime
+        """
+        Validation.validate_type(value, Union[datetime, None], 'last_used_date should be a datetime.')
+
+        self._last_used_date = value
+
+    @property
+    def last_used_region(self) -> Optional[str]:
+        """
+        Gets the last used region of the IAM user access key.
+        :return: The last used region of the IAM user access key.
+        :rtype: str
+        """
+        return self._last_used_region
+
+    @last_used_region.setter
+    def last_used_region(self, value: Optional[str]) -> None:
+        """
+        Sets the last used region of the IAM user access key.
+        :param value: The last used region of the IAM user access key.
+        :type value: str
+        """
+        if value is not None:
+            Validator.region(value)
+
+        self._last_used_region = value
+
+    @property
+    def last_used_service(self) -> Optional[str]:
+        """
+        Gets the last used service of the IAM user access key.
+        :return: The last used service of the IAM user access key.
+        :rtype: str
+        """
+        return self._last_used_service
+
+    @last_used_service.setter
+    def last_used_service(self, value: Optional[str]) -> None:
+        """
+        Sets the last used service of the IAM user access key.
+        :param value: The last used service of the IAM user access key.
+        :type value: str
+        """
+        Validation.validate_type(value, Union[str, None], 'last_used_service should be a string.')
+
+        self._last_used_service = value
+
+    @property
+    def status(self) -> str:
+        """
+        Gets the status of the IAM user access key.
+        :return: The status of the IAM user access key.
+        :rtype: str
+        """
+        return self._status
+
+    @status.setter
+    def status(self, value: str) -> None:
+        """
+        Sets the status of the IAM user access key.
+        :param value: The status of the IAM user access key.
+        :type value: str
+        """
+        Validation.validate_type(value, str, 'status should be a string.')
+
+        self._status = value
+
+    def __str__(self) -> str:
+        """
+        Return a string representation of the IAMUserAccessKey object.
+        :return: String representation of the IAMUserAccessKey object.
+        :rtype: str
+        """
+        created_date = self.created_date.isoformat() if self.created_date else None
+        last_used_date = self.last_used_date.isoformat() if self._last_used_date else None
+
+        return (
+            f'IAMUserAccessKey('
+            f'id={self.id},'
+            f'status={self.status},'
+            f'created_date={created_date},'
+            f'last_used_date={last_used_date},'
+            f'last_used_service={self.last_used_service},'
+            f'last_used_region={self.last_used_region}'
+            f')'
+        )
+
+    def __dict__(self) -> dict:
+        """
+        Return a dictionary representation of the IAMUserAccessKey object.
+        :return: Dictionary representation of the IAMUserAccessKey object.
+        :rtype: dict
+        """
+        created_date = self.created_date.isoformat() if self.created_date else None
+        last_used_date = self.last_used_date.isoformat() if self._last_used_date else None
+
+        return {
+            "id": self.id,
+            "status": self.status,
+            "created_date": created_date,
+            "last_used_date": last_used_date,
+            "last_used_service": self.last_used_service,
+            "last_used_region": self.last_used_region
+        }
+
+
 class IAMRole:
     """
     A class representing an IAM role.
     """
 
     def __init__(
             self,
@@ -470,16 +765,17 @@
     @permissions_boundary.setter
     def permissions_boundary(self, value: Optional[IAMPermissionsBoundary] = None) -> None:
         """
         Sets the permissions boundary associated with the IAM role.
         :param value: The permissions boundary asociated with the IAM role.
         :type value: IAMPermissionsBoundary
         """
-        Validation.validate_type(value, Union[IAMPermissionsBoundary, None],
-                                 'permissions_boundary should be of IAMPermissionsBoundary type.')
+        Validation.validate_type(
+            value, Union[IAMPermissionsBoundary, None], 'permissions_boundary should be of IAMPermissionsBoundary type.'
+        )
         self._permissions_boundary = value
 
     @property
     def tags(self) -> Optional[list]:
         """
         Gets the tags associated with the IAM role.
         :return: The tags associated with the IAM role.
@@ -569,14 +865,16 @@
             name: str,
             id: str,
             arn: str,
             path: str = '/',
             created_date: Optional[datetime] = None,
             password_last_used_date: Optional[datetime] = None,
             permissions_boundary: Optional[IAMPermissionsBoundary] = None,
+            login_profile: Optional[IAMUserLoginProfile] = None,
+            access_keys: Optional[list[IAMUserAccessKey]] = None,
             tags: Optional[list] = None
     ) -> None:
         """
         Initialize a new IAMUser instance.
         :param account: The account associated with the IAM user.
         :type account: IAccount
         :param name: The name of the IAM user.
@@ -590,14 +888,18 @@
         :param created_date: The creation date of the IAM user. Defaults to None.
         :type created_date: datetime
         :param password_last_used_date: Information about the last time the IAM user password was used.
         Defaults to None.
         :type password_last_used_date: datetime
         :param permissions_boundary: The permissions boundary for the IAM user. Defaults to None.
         :type permissions_boundary: IAMPermissionsBoundary
+        :param login_profile: The login profile of the IAM user. Defaults to None.
+        :type login_profile: IAMUserLoginProfile
+        :param access_keys: A list of access keys associated with the IAM user. Defaults to None.
+        :type access_keys: list
         :param tags: A list of tags associated with the IAM user. Defaults to None.
         :type tags: list
         """
         Validation.validate_type(account, IAccount, 'account should be of Account type.')
         Validation.validate_type(name, str, 'name should be a string.')
         Validation.validate_type(id, str, 'id should be a string.')
         ArnValidator.arn(arn, True)
@@ -607,27 +909,65 @@
             password_last_used_date, Union[datetime, None], 'password_last_used_date should be a datetime.'
         )
         Validation.validate_type(
             permissions_boundary,
             Union[IAMPermissionsBoundary, None],
             'permissions_boundary should be of IAMPermissionsBoundary type.'
         )
+        Validation.validate_type(
+            login_profile, Union[IAMUserLoginProfile, None], 'login_profile should be of IAMUserLoginProfile type.'
+        )
+        Validation.validate_type(access_keys, Union[list, None], 'access_keys should be a list of IAMUserAccessKey.')
+        if access_keys is not None and len(access_keys) > 0:
+            all(
+                Validation.validate_type(
+                    access_key, IAMUserAccessKey, 'access_keys should be a list of IAMUserAccessKey.'
+                ) for access_key in access_keys
+            )
         Validation.validate_type(tags, Union[list, None], 'tags should be a list.')
 
         self._account = account
         self._name = name
         self._id = id
         self._arn = arn
         self._path = path
         self._created_date = created_date
         self._password_last_used_date = password_last_used_date
         self._permissions_boundary = permissions_boundary
+        self._login_profile = login_profile
+        self._access_keys = access_keys
         self._tags = tags
 
     @property
+    def access_keys(self) -> Optional[list[IAMUserAccessKey]]:
+        """
+        Gets the list of access keys associated with the IAM user.
+        :return: The list of access keys associated with the IAM user.
+        :rtype: list
+        """
+        return self._access_keys
+
+    @access_keys.setter
+    def access_keys(self, value: Optional[list[IAMUserAccessKey]]) -> None:
+        """
+        Sets the list of access keys associated with the IAM user.
+        :param value: The list of access keys associated with the IAM user.
+        :type value: list
+        """
+        Validation.validate_type(value, Union[list, None], 'access_keys should be a list of IAMUserAccessKey.')
+        if value is not None and len(value) > 0:
+            all(
+                Validation.validate_type(
+                    access_key, IAMUserAccessKey, 'access_keys should be a list of IAMUserAccessKey.'
+                ) for access_key in value
+            )
+
+        self._access_keys = value
+
+    @property
     def account(self) -> IAccount:
         """
         Gets the account associated with the IAM user.
         :return: The account associated with the IAM user.
         :rtype: IAccount
         """
         return self._account
@@ -696,14 +1036,36 @@
         :param value: The ID of the IAM user.
         :type value: str
         """
         Validation.validate_type(value, str, 'id should be a string.')
         self._id = value
 
     @property
+    def login_profile(self) -> Optional[IAMUserLoginProfile]:
+        """
+        Gets the login profile of the IAM user.
+        :return: The login profile of the IAM user.
+        :rtype: IAMUserLoginProfile
+        """
+        return self._login_profile
+
+    @login_profile.setter
+    def login_profile(self, value: Optional[IAMUserLoginProfile]) -> None:
+        """
+        Sets the login profile of the IAM user.
+        :param value: The login profile of the IAM user.
+        :type value: IAMUserLoginProfile
+        """
+        Validation.validate_type(
+            value, Union[IAMUserLoginProfile, None], 'login_profile should be of IAMUserLoginProfile type.'
+        )
+
+        self._login_profile = value
+
+    @property
     def name(self) -> str:
         """
         Gets the name of the IAM user.
         :return: The name of the IAM user.
         :rtype: str
         """
         return self._name
@@ -802,25 +1164,29 @@
         :rtype: str
         """
         account = self.account if self.account else None
         created_date = self.created_date.isoformat() if self.created_date else None
         password_last_used_date = self.password_last_used_date.isoformat() if self.password_last_used_date else None
         permissions_boundary = self.permissions_boundary if self.permissions_boundary else None
         tags = self.tags if self.tags else None
+        login_profile = self.login_profile if self.login_profile else None
+        access_keys = self.access_keys if self.access_keys and len(self.access_keys) > 0 else None
 
         return (
             f'IAMUser('
             f'account={account},'
             f'path={self.path},'
             f'name={self.name},'
             f'id={self.id},'
             f'arn={self.arn},'
             f'created_date={created_date},'
             f'password_last_used_date={password_last_used_date},'
             f'permissions_boundary={permissions_boundary},'
+            f'login_profile={login_profile},'
+            f'access_keys={access_keys},'
             f'tags={tags}'
             f')'
         )
 
     def __dict__(self) -> dict:
         """
         Return a dictionary representation of the IAMUser object.
@@ -828,19 +1194,23 @@
         :rtype: dict
         """
         account = self.account.__dict__() if self.account else None
         created_date = self.created_date.isoformat() if self.created_date else None
         password_last_used_date = self.password_last_used_date.isoformat() if self.password_last_used_date else None
         permissions_boundary = self.permissions_boundary.__dict__() if self.permissions_boundary else None
         tags = self.tags if self.tags else None
+        login_profile = self.login_profile.__dict__() if self.login_profile else None
+        access_keys = self.access_keys if self.access_keys and len(self.access_keys) > 0 else None
 
         return {
             "account": account,
             "path": self.path,
             "name": self.name,
             "id": self.id,
             "arn": self.arn,
             "created_date": created_date,
             "password_last_used_date": password_last_used_date,
             "permissions_boundary": permissions_boundary,
+            "login_profile": login_profile,
+            "access_keys": access_keys,
             "tags": tags
         }
```

## Comparing `pyawsopstoolkit-0.1.7.dist-info/LICENSE` & `pyawsopstoolkit-0.1.8.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pyawsopstoolkit-0.1.7.dist-info/METADATA` & `pyawsopstoolkit-0.1.8.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pyawsopstoolkit
-Version: 0.1.7
+Version: 0.1.8
 Summary: This extensive package, AWS Ops Toolkit, offers a wide range of features and enhancements designed to streamline
 Home-page: https://github.com/coldsofttech/pyawsopstoolkit.git
 Author: coldsofttech
 License: MIT
 Keywords: aws,toolkit,operations,tools,development,python,validation,session-management,utilities,enhancements,integration,amazon-web-services,models,search,advance-search,filtering,security-risks,risks,vulnerabilities,insights,hygiene
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Developers
```

## Comparing `pyawsopstoolkit-0.1.7.dist-info/RECORD` & `pyawsopstoolkit-0.1.8.dist-info/RECORD`

 * *Files 21% similar despite different names*

```diff
@@ -1,21 +1,21 @@
-pyawsopstoolkit/__init__.py,sha256=QYESZWcZYs5vzqaVoZQaJGDjO3C663m12Pg9K1Go5lk,943
+pyawsopstoolkit/__init__.py,sha256=ZELlj_bgCjypPWQiLZ818zCZecQLrjsY-BDFBuenFos,943
 pyawsopstoolkit/__interfaces__.py,sha256=T7YRsadf_RKS1yHNu5xIZqxqhyAPWWK4iLStSKBs7sw,4884
 pyawsopstoolkit/__main__.py,sha256=18yPre01EWwMSk1B9UgCeCt1XTzHA9xWCXyq4LsInLk,16853
 pyawsopstoolkit/__validations__.py,sha256=RFgQuG2EuIxoD3INJBY-QnPwuEbBSG2IXxGnySjceOY,780
 pyawsopstoolkit/advsearch/__init__.py,sha256=N221tQFzuxokrai8Sf4zgjk_1ljoz_0kHWVPIJYjVlE,761
-pyawsopstoolkit/advsearch/__main__.py,sha256=OJ8W21KDeiH4MRXcOfzGB9NkMZvq2I6H8waDXXyAqlc,27483
+pyawsopstoolkit/advsearch/__main__.py,sha256=fEPp3FQsh65DJ2gs-bV72YaJfBs4Zkg_YFDi1LxEhiU,35284
 pyawsopstoolkit/exceptions/__init__.py,sha256=m5FsbBGnm6ykCmFbIpQRRag9lq7wOXb42XhjGknqPo0,605
 pyawsopstoolkit/exceptions/__main__.py,sha256=DO2Nx_1AFYZwzatBYecyTrwpHLdI_6fLCP2mJJtixVk,4453
 pyawsopstoolkit/insights/__init__.py,sha256=07t44I6W7MVCM0RJ4UT0jNiYHqFMlCLqTky0gDbGbjM,512
-pyawsopstoolkit/insights/__main__.py,sha256=_RJUqn2hc2aAasdgaegPxpxjUbA0sCGUHcmimsLc8F4,3482
-pyawsopstoolkit/models/__init__.py,sha256=3U9kmXjKc9geYxDZ5g4s2pISDKtd_Fxxqhj47STW7xM,583
-pyawsopstoolkit/models/__main__.py,sha256=jMMv8hh3GGXwALhuCT-4kcBIbNRxAob8z6unv7AwnL0,29487
+pyawsopstoolkit/insights/__main__.py,sha256=RH79qSIt-OmFSjYJNFbWzgA6YbEU7El1k_sdYUxnVxE,6170
+pyawsopstoolkit/models/__init__.py,sha256=WJRwWfBLZ_VWQqei64Aqc2Y6eIrlmqnaMoxhxdAHroI,679
+pyawsopstoolkit/models/__main__.py,sha256=1YXvu0VIeKawTrM12WXAVu8MlDWjuDL5GOhuCPWKJWY,43380
 pyawsopstoolkit/security/__init__.py,sha256=dkROdft2HGxO6bfgV9DCIJFtD18mYp7yVeGvoiM34II,502
 pyawsopstoolkit/security/__main__.py,sha256=nbKkfu0PbX2EsiD0dZrKZDIuTxiCqtlk0T0hytRgnyo,2822
 pyawsopstoolkit/validators/__init__.py,sha256=-khHtJO3JNO0EqJipUiOk5tlRF4siVjDTWAV9dSiCW4,874
 pyawsopstoolkit/validators/__main__.py,sha256=EU2coEi04GO9EPTxjuRvqY681liuhTVJ5Enps6Ofiqg,30261
-pyawsopstoolkit-0.1.7.dist-info/LICENSE,sha256=QDd-5ssO5cRVguOaD889uNuqyZlNg2DQS6VjttE-8Dk,1069
-pyawsopstoolkit-0.1.7.dist-info/METADATA,sha256=tAeXA196Y9DWkpotYOkTUXzycyFB9rljwAwFoHKBgrU,8776
-pyawsopstoolkit-0.1.7.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-pyawsopstoolkit-0.1.7.dist-info/top_level.txt,sha256=Sf9U8aiv7IzpPAt3wJmc0sUFQ7q_PyyOqUmugSJpwbA,16
-pyawsopstoolkit-0.1.7.dist-info/RECORD,,
+pyawsopstoolkit-0.1.8.dist-info/LICENSE,sha256=QDd-5ssO5cRVguOaD889uNuqyZlNg2DQS6VjttE-8Dk,1069
+pyawsopstoolkit-0.1.8.dist-info/METADATA,sha256=8Pj8EOSIwh5TJSlTvkOG_Xs3A5FOYNGclBBOVoVxlvA,8776
+pyawsopstoolkit-0.1.8.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+pyawsopstoolkit-0.1.8.dist-info/top_level.txt,sha256=Sf9U8aiv7IzpPAt3wJmc0sUFQ7q_PyyOqUmugSJpwbA,16
+pyawsopstoolkit-0.1.8.dist-info/RECORD,,
```

